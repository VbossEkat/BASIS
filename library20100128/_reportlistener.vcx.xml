<?xml version = "1.0" encoding="UTF-8" standalone="yes"?>
<VFPData>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>Class</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname/>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>VERSION =   3.00</reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1PC0NFKPY</uniqueid>
		<timestamp>877020253</timestamp>
		<class>custom</class>
		<classloc/>
		<baseclass>custom</baseclass>
		<objname>fxabstract</objname>
		<parent/>
		<properties>_memberdata = &lt;VFPData&gt;&lt;memberdata name="applyfx" type="property" display="applyFX" favorites="True"/&gt;&lt;/VFPData&gt;
Name = "fxabstract"
</properties>
		<protected/>
		<methods>PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12


ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>_memberdata XML Metadata for customizable properties
*applyfx Required method to implement the FX interface.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Custom-derived class, supplying an abstract instance of the required interface to implement an FX or GFX object. For use with FXListener as a report decorator.</reserved7>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>fxabstract</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1Q40K9H6C</uniqueid>
		<timestamp>877293344</timestamp>
		<class>fxabstract</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>gfxexample</objname>
		<parent/>
		<properties>showdatasessionissue = .T.
_memberdata = &lt;VFPData&gt;&lt;memberdata name="applyfx" type="property" display="applyFX" favorites="True"/&gt;&lt;memberdata name="showdatasessionissue" display="showDataSessionIssue" favorites="True" type="property"/&gt;&lt;/VFPData&gt;
Name = "gfxexample"
</properties>
		<protected/>
		<methods>PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6,;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12


IF m.tcMethodToken == "BEFOREREPORT" AND ;
THIS.showDataSessionIssue AND ;
(m.toListener.CurrentDataSession = m.toListener.CommandClauses.StartDataSession)
MESSAGEBOX("This report does not use a private data session," + CHR(13) + ;
"so you won't see the problem.")
ENDIF
IF m.tcMethodToken == "BEFOREBAND"
SET DATASESSION TO (m.toListener.CurrentDataSession)
m.toListener.doStatus("working here... ")
IF THIS.showDataSessionIssue
* no switch back here.
*!*	   ELSE
*!*	      SET DATASESSION TO (m.toListener.ListenerDataSession)
ENDIF
ENDIF

IF (NOT THIS.showDataSessionIssue) AND ;
m.tcMethodToken == "AFTERREPORT"
* if the following is not included,
* a "stuck" datasession results unless
* some additional object later in
* the collection did the switch back
m.toListener.removeCollectionMember(THIS.Name,.T.)
RELEASE THIS
ENDIF

ENDPROC
PROCEDURE showdatasessionissue_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.showDataSessionIssue = m.vNewVal
ENDIF

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>showdatasessionissue Toggles demonstration of proper datasession handling in this example GFX class.
*showdatasessionissue_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Example GFX class to show technique the object can use to remove itself from FXListener's collection at the conclusion of a report run. This technique is critical to safe use of FX and GFX objects that do not closely monitor their use of datasessions. </reserved7>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>gfxexample</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1Q20UZXVD</uniqueid>
		<timestamp>878213316</timestamp>
		<class>fxabstract</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>fxresetpagetotal</objname>
		<parent/>
		<properties>resetcount = 0
oldpass = 0
dothisrun = .F.
resetalias = ("GR"+SYS(2015))
_memberdata =      524&lt;VFPData&gt;&lt;memberdata name="applyfx" type="property" display="applyFX" favorites="True"/&gt;&lt;memberdata name="dothisrun" type="property" display="doThisRun" favorites="True"/&gt;&lt;memberdata name="oldpass" type="property" display="oldPass"/&gt; &lt;memberdata name="resetcount" type="property" display="resetCount"/&gt;&lt;memberdata name="resetalias" type="property" display="resetAlias"/&gt;&lt;memberdata name="dobeforeband" type="method" display="doBeforeBand"/&gt;&lt;memberdata name="dobeforereport" type="method" display="doBeforeReport"/&gt;&lt;/VFPData&gt;
Name = "fxresetpagetotal"
</properties>
		<protected>resetcount
oldpass
dothisrun
resetalias
dobeforeband
dobeforereport
</protected>
		<methods>PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6,   ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

DO CASE
CASE m.tcMethodToken == "BEFOREREPORT" AND ;
TYPE("_ResetPageTotal") # "U"
* we can turn on behavior explicitly
toListener.TwoPassProcess = .T.
THIS.doThisRun = .T.
THIS.doBeforeReport(toListener)
CASE m.tcMethodToken == "BEFOREREPORT" AND ;
(TYPE("_ResetPageTotal") = "U")
THIS.doThisRun = .F.
CASE NOT THIS.DoThisRun
* do nothing
CASE m.tcMethodToken == "BEFOREBAND"
THIS.doBeforeBand(toListener,tP1)
OTHERWISE
* do nothing
ENDCASE



ENDPROC
PROCEDURE dobeforeband
LPARAMETERS m.toListener,m.tnBandCode

LOCAL m.liSession, m.liSelect
IF m.tnBandCode = 1 &amp;&amp; pageheader
m.liSession = SET("DATASESSION")
SET DATASESSION TO (m.toListener.FRXDataSession )
liSelect = SELECT(0)
SELECT (THIS.resetAlias)
IF _PAGENO = 1 &amp;&amp; user reset occurred
IF THIS.oldPass = 0 AND toListener.CurrentPass = 1
* we're entering the rendering pass
THIS.resetCount = 1
THIS.oldPass = 1
IF TYPE("_ReportPageTotal") = "N"
CALCULATE SUM(ResetPageTotal) TO _ReportPageTotal
ENDIF
ELSE
THIS.resetCount = THIS.resetCount + 1
ENDIF
IF m.toListener.CurrentPass = 0
INSERT INTO (THIS.resetAlias) VALUES (THIS.ResetCount, 1)
ENDIF
ELSE
* we're not starting a set of page numbers,
* so we need to keep track of the pages in
* this particular group.
IF m.toListener.CurrentPass = 0
SEEK THIS.ResetCount
REPLACE ResetPageTotal WITH ResetPageTotal + 1
ENDIF
ENDIF
IF m.toListener.CurrentPass = 1
* make the current group's page total available
* for display/output
SEEK THIS.ResetCount
_ResetPageTotal = ResetPageTotal
_ReportPageNo = m.toListener.PageNo &amp;&amp; don't even worry about whether the var has been declared
ENDIF
SELECT (m.liSelect)
SET DATASESSION TO (m.toListener.CurrentDataSession)
ENDIF

ENDPROC
PROCEDURE dobeforereport
LPARAMETERS m.toListener
LOCAL liSession, liSelect
liSession = SET("DATASESSION")
SET DATASESSION TO (m.toListener.FRXDataSession )
liSelect = SELECT(0)
SELECT 0
CREATE CURSOR (THIS.resetAlias) (ResetsNo i, ResetPageTotal i)
INDEX ON ResetsNo TAG Resets
THIS.resetCount = 0
THIS.oldPass = 0
_ResetPageTotal = 0
SELECT (liSelect)
SET DATASESSION TO (m.toListener.CurrentDataSession)

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>resetcount Internal processing variable.
oldpass Internal processing variable.
dothisrun Holds assessment of whether this object must perform its function during the current report run.
resetalias Alias of cursor used to accumulate page counts for groups.
*dobeforeband Accumulates page counts into the ResetAlias cursor as the report run progresses.
*dobeforereport Initializes page count activity at the start of a report run.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides page count &amp; total in any report. Runs if _ResetPageTotal var exists, also fills vars _ReportPageNo &amp; _ReportPageTotal if available. Results are similar to system variables _PAGENO &amp; _PAGETOTAL, but accurate in reports that reset _PAGENO on band.</reserved7>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>fxresetpagetotal</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1Q210400D</uniqueid>
		<timestamp>878213337</timestamp>
		<class>fxabstract</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>gfxrotate</objname>
		<parent/>
		<properties>Name = "gfxrotate"
</properties>
		<protected/>
		<methods>PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

LOCAL liSession, liAngle, liSelect, liFRXRecno, liReturn

m.liReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR

IF m.tcMethodToken == "RENDER" AND ;
NOT ISNULL(m.toListener.FFCGraphics)

TRY
m.liSession = SET("DATASESSION")
IF m.toListener.FRXDataSession &gt; -1
SET DATASESSION TO m.toListener.FRXDataSession
ENDIF
m.liSelect = SELECT(0)
IF USED(m.toListener.MemberDataAlias)
SELECT (m.toListener.MemberDataAlias)
m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
LOCATE FOR FrxRecno = m.liFRXRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ROTATE AND ;
NOT EMPTY(Execute)

IF FOUND() AND NOT EMPTY(INT(VAL(Execute)))
m.liAngle = INT(VAL(Execute))
m.toListener.FFCGraphics.TranslateTransform(tP2, tP3)
m.toListener.FFCGraphics.RotateTransform(m.liAngle)
m.liReturn = OUTPUTFX_BASERENDER_RENDER_BEFORE_RESTORE
m.toListener.FFCGraphics.TranslateTransform(-tP2, -tP3)
ENDIF
ENDIF
CATCH TO err
* could expose the error but won't,
* we'll just swallow it
FINALLY
SELECT (m.liSelect)
SET DATASESSION TO (m.liSession)
ENDTRY

ENDIF

RETURN  m.liReturn
ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Changes default rendering behavior for report layout controls by rotating them according to a MemberData-specified number of degrees.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>gfxrotate</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1PQ0P76WP</uniqueid>
		<timestamp>878213455</timestamp>
		<class>fxabstract</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>fxmemberdatascript</objname>
		<parent/>
		<properties>scriptalias = ("S"+SYS(2015))
removescriptonfailure = .T.
_memberdata =      783&lt;VFPData&gt;&lt;memberdata name="applyfx" type="property" display="applyFX" favorites="True"/&gt;&lt;memberdata name="gatherscripts" type="method" display="gatherScripts"/&gt;&lt;memberdata name="processmemberdatascript" type="method" display="processMemberDataScript"/&gt;&lt;memberdata name="processdynamicmethodscript" type="method" display="processDynamicMethodScript"/&gt;&lt;memberdata name="usememberdata" type="method" display="useMemberData"/&gt;&lt;memberdata name="scriptalias" display="scriptAlias" type="property"/&gt;&lt;memberdata name="adjustdynamiccalls" type="method" display="adjustDynamicCalls"/&gt;&lt;memberdata name="removescriptonfailure" display="removeScriptOnFailure" type="property" favorites="True"/&gt;&lt;memberdata name="findparametersstatement" type="method" display="findParametersStatement"/&gt;&lt;/VFPData&gt;
Name = "fxmemberdatascript"
</properties>
		<protected>scriptalias
usememberdata
processmemberdatascript
processdynamicmethodscript
gatherscripts
adjustdynamiccalls
findparametersstatement
</protected>
		<methods>PROCEDURE adjustdynamiccalls
LPARAMETERS m.toListener

* change m.toListener.CallEvaluateContents and
* m.toListener.CallAdjustObjectSize if necessary

SET DATASESSION TO (m.toListener.FRXDataSession)

IF INLIST(m.toListener.callEvaluateContents,;
LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
LISTENER_CALLDYNAMICMETHOD_NEVER)

SELECT FRX
GO TOP
SCAN FOR ObjType = FRX_OBJTYP_FIELD AND Platform = FRX_PLATFORM_WINDOWS
IF THIS.useMemberData(RECNO())
SELECT (THIS.scriptAlias)
IF ATC("EvaluateContents",ExecWhen) &gt; 0 OR ;
ATC("EvaluateContents",Execute) &gt; 0 OR ;
(NOT EMPTY(UserScript))
* UserScript for a Field-type item
* has to be EvaluateContents
m.toListener.callEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
EXIT
ENDIF
ENDIF
SELECT FRX
ENDSCAN

ENDIF

IF INLIST(m.toListener.callAdjustObjectSize,;
LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
LISTENER_CALLDYNAMICMETHOD_NEVER)

SELECT FRX
GO TOP
SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND INLIST(ObjType,FRX_OBJTYP_LINE,FRX_OBJTYP_RECTANGLE,FRX_OBJTYP_PICTURE)
IF THIS.useMemberData(RECNO())
SELECT (THIS.scriptAlias)
IF ATC("AdjustObjectSize",ExecWhen) &gt; 0 OR ;
ATC("AdjustObjectSize",Execute) &gt; 0 OR ;
(NOT EMPTY(UserScript))
* UserScript for a Shape-Picture-type item
* has to be AdjustObjectSize
m.toListener.callAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
EXIT
ENDIF
ENDIF
SELECT FRX
ENDSCAN

ENDIF

ENDPROC
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
TRY
IF m.toListener.FRXDataSession &gt; 0
SET DATASESSION TO (m.toListener.FRXDataSession)
ENDIF

LOCAL m.liFRXRecno

IF m.tcMethodToken == "BEFOREREPORT"
THIS.gatherScripts(m.toListener)
THIS.adjustDynamicCalls(m.toListener)
ENDIF

IF m.toListener.FRXDataSession &gt; 0
SET DATASESSION TO (m.toListener.FRXDataSession)
ENDIF

m.liFRXRecno = m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)

IF USED("FRX") AND m.liFRXRecno &gt; 0
GO (m.liFRXRecno) IN FRX
ENDIF

IF THIS.useMemberData(m.liFRXRecno)
THIS.processMemberDataScript(m.toListener, m.tcMethodToken,;
@m.tP1, @m.tP2, @m.tP3, @m.tP4, @m.tP5, @m.tP6, ;
@m.tP7, @m.tP8, @m.tP9, @m.tP10, @m.tP11, @m.tP12)
IF INLIST(m.tcMethodToken,"EVALUATECONTENTS","ADJUSTOBJECTSIZE")
THIS.processDynamicMethodScript(m.toListener,m.tP1, m.tP2)
ENDIF
ENDIF

IF m.toListener.FRXDataSession &gt; 0
SET DATASESSION TO (m.toListener.FRXDataSession)
ENDIF
IF USED("FRX")
SELECT FRX
ENDIF
SET DATASESSION TO (m.toListener.ListenerDataSession)

CATCH TO err

#IF OUTPUTCLASS_DEBUGGING
SUSPEND
#ENDIF

ENDTRY

ENDPROC
PROCEDURE findparametersstatement
LPARAMETERS m.tcScript
LOCAL laLines[1], liLine, lcLine, llFound
IF VARTYPE(m.tcScript) = "C" AND NOT EMPTY(m.tcScript)
FOR m.liLine = 1 TO ALINES(laLines,CHRTRAN(m.tcScript,CHR(10),CHR(13)),1+4,CHR(13))
m.lcLine = ALLTRIM(UPPER(m.laLines[liLine]))
DO CASE
CASE LEFT(m.lcLine,1) == "*" OR LEFT(m.lcLine,2) == REPLICATE(CHR(38),2)
* skip leading comments
CASE BETWEEN(ATC("PARAM",m.lcLine),1,2)
m.llFound = .T.
EXIT
OTHERWISE
EXIT
ENDCASE
ENDFOR
ENDIF

RETURN m.llFound
ENDPROC
PROCEDURE gatherscripts
LPARAMETERS m.toListener
LOCAL lcTemp1, lcTemp2, lcTemp3, liSelect
SET DATASESSION TO (m.toListener.FRXDataSession)
m.liSelect = SELECT(0)
SELECT 0
CREATE CURSOR (THIS.scriptAlias) ;
(FRXRecno i, ExecWhen M, Execute M, UserScript M)
IF USED(m.toListener.MemberDataAlias) AND ;
RECCOUNT(m.toListener.MemberDataAlias) &gt; 0
SELECT FRX
GO TOP
SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND NOT EMPTY(Style)
SELECT (m.toListener.MemberDataAlias)
LOCATE FOR FRXRecno = RECNO("FRX") AND ;
EMPTY(Name) AND Type = FRX_BLDR_MEMBERDATATYPE
m.lcTemp1 = ExecWhen
m.lcTemp2 = Execute
m.lcTemp3 = ""
IF NOT EMPTY(m.lcTemp2)
IF NOT THIS.findParametersStatement(m.lcTemp2)
* add a parameters statement
m.lcTemp2 =  "LPARAMETERS toFX, toListener, tcMethodToken,;"+ CHR(13) + CHR(10) + ;
"tP1, tP2, tP3, tP4, tP5, tP6,"+;
"tP7, tP8, tP9, tP10, tP11, tP12" + CHR(13) + CHR(10) + ;
m.lcTemp2
ENDIF
ENDIF
DO CASE
CASE INLIST(FRX.ObjType,FRX_OBJTYP_LINE,FRX_OBJTYP_RECTANGLE,FRX_OBJTYP_PICTURE)
LOCATE FOR FRXRecno = RECNO("FRX") AND ;
Type = FRX_BLDR_MEMBERDATATYPE   AND ;
Name == FRX_BLDR_NAMESPACE_ADJUSTOBJECTSIZE
IF NOT EOF()
m.lcTemp3 = ;
m.toListener.FRXCursor.GenerateAdjustObjectSizeScript("frx",m.toListener.MemberDataAlias,m.toListener.FRXDataSession)
ENDIF
CASE FRX.ObjType = FRX_OBJTYP_FIELD
LOCATE FOR FRXRecno = RECNO("FRX") AND ;
Type = FRX_BLDR_MEMBERDATATYPE   AND ;
Name == FRX_BLDR_NAMESPACE_EVALUATECONTENTS
IF NOT EOF()
m.lcTemp3 = ;
m.toListener.FRXCursor.GenerateEvaluateContentsScript("frx",m.toListener.MemberDataAlias,m.toListener.FRXDataSession)
ENDIF
OTHERWISE
m.lcTemp3 = ""
ENDCASE
SET DATASESSION TO (m.toListener.FRXDataSession)
IF NOT EMPTY(m.lcTemp1 + m.lcTemp2 + m.lcTemp3)
INSERT INTO (THIS.scriptAlias) ;
VALUES (RECNO("FRX"),m.lcTemp1, m.lcTemp2, m.lcTemp3)
ENDIF
SELECT FRX
ENDSCAN

ENDIF

SELECT (THIS.scriptAlias)
INDEX ON FrxRecno TAG FrxRecno

SELECT (m.liSelect)

ENDPROC
PROCEDURE processdynamicmethodscript
LPARAMETERS m.toListener,  m.tnFRXRecno, m.toProps
* we are already positioned on the correct MemberData record
* in the script alias and in the FRXDataSession
* by the calling method.
IF (NOT EOF(THIS.scriptAlias))
LOCAL lcScript
m.lcScript = EVALUATE(THIS.scriptAlias + ".UserScript" )
IF NOT EMPTY(m.lcScript)
TRY
EXECSCRIPT(m.lcScript,m.toListener, m.tnFRXRecno, m.toProps )
CATCH TO err
IF THIS.removeScriptOnFailure AND ;
(m.toListener.FRXDataSession &gt; 0)
SET DATASESSION TO (m.toListener.FRXDataSession)
REPLACE UserScript WITH "" IN (THIS.scriptAlias)
ENDIF
#IF OUTPUTCLASS_DEBUGGING
SUSPEND
#ENDIF
FINALLY
IF m.toListener.FRXDataSession &gt; 0
SET DATASESSION TO (m.toListener.FRXDataSession)
ENDIF
ENDTRY
ENDIF
ENDIF
ENDPROC
PROCEDURE processmemberdatascript
LPARAMETERS m.toListener, m.tcMethodToken,;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

* we are already positioned on the correct MemberData record
* in the FRXDataSession in the script alias
* by the calling method.
IF (NOT EOF(THIS.scriptAlias))
LOCAL llExecute, lcExecute, lcExecWhen
m.lcExecute = EVALUATE(THIS.scriptAlias + ".Execute")
m.lcExecWhen = EVALUATE(THIS.scriptAlias + ".ExecWhen")
SET DATASESSION TO (m.toListener.CurrentDataSession)
DO CASE
CASE EMPTY(m.lcExecute)
* nothing to execute
CASE EMPTY(m.lcExecWhen)
* always execute
m.llExecute = .T.
CASE UPPER(m.lcExecWhen)== m.tcMethodToken
* simple event evaluation
* ExecWhen contains an event name
* Note that each event, via script,
* could potentially change the contents of
* ExecWhen to hold another value (the next
* event during which this script should be evaluated)
m.llExecute = .T.
CASE (TYPE(m.lcExecWhen) = "L") AND ;
EVALUATE(m.lcExecWhen)
* ExecWhen contains a logical expression to be evaluated
m.llExecute = .T.
CASE ATC("|"+m.tcMethodToken+"|","|" + m.lcExecWhen + "|") &gt; 0
* ExecWhen contains a delimited string of events
m.llExecute = .T.
ENDCASE

IF m.llExecute
TRY
ExecScript(m.lcExecute,;
THIS, m.toListener, m.tcMethodToken,;
@tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
@tP7, @tP8, @tP9, @tP10, @tP11, @tP12)
CATCH TO err
IF THIS.removeScriptOnFailure AND ;
(m.toListener.FRXDataSession &gt; 0)
SET DATASESSION TO (m.toListener.FRXDataSession)
REPLACE Execute WITH "" IN (THIS.scriptAlias)
ENDIF
#IF OUTPUTCLASS_DEBUGGING
SUSPEND
#ENDIF
ENDTRY
ENDIF
IF m.toListener.FRXDataSession &gt; 0
SET DATASESSION TO (m.toListener.FRXDataSession)
ENDIF
ENDIF



ENDPROC
PROCEDURE removescriptonfailure_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.removeScriptOnFailure = m.vNewVal
ENDIF

ENDPROC
PROCEDURE usememberdata
LPARAMETERS m.tiFRXRecno

LOCAL m.llUseMemberData, m.liSelect

IF (m.tiFRXRecno &gt; 0)
IF USED(THIS.scriptAlias)
m.liSelect = SELECT(0)
SELECT (THIS.scriptAlias)
m.llUseMemberData = ;
SEEK(m.tiFRXRecno,THIS.scriptAlias,"FRXRecno")
SELECT (m.liSelect)
ENDIF
ENDIF

RETURN m.llUseMemberData

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>scriptalias The alias of a cursor holding script information during the report run.
removescriptonfailure Indicates whether any script failure should remove the  failed script for the balance of the report run. If .F., this script continues to be executed for additional report events and errors are handled silently. Defaults to .T.. 
*usememberdata Evaluates whether the current event and the current FRX layout element have MemberData that this class can process and positions the MemberData and Scripting cursors appropriately.
*processmemberdatascript Executes MemberData script from the main MemberData row for the current FRX layout element.
*processdynamicmethodscript Processes specialized MemberData rows for the current layout control for dynamic methods EvaluateContents and AdjustObjectSize.
*gatherscripts Sets up script elements at the beginning of a report run.
*adjustdynamiccalls Ensures that dynamic method calls are made if there is relevant MemberData script attached to them.
*removescriptonfailure_assign 
*findparametersstatement Checks FX scripts for a parameter statement as required for ApplyFX() method.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Executes script stored in FRX Memberdata, reading it from a cursor in the FRX datasession.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>fxmemberdatascript</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1530WWJY4</uniqueid>
		<timestamp>880432494</timestamp>
		<class>_reportlistener</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>reportlistener</baseclass>
		<objname>updatelistener</objname>
		<parent/>
		<properties>FRXDataSession = -1
thermform = .NULL.
thermformheight = 40
thermformwidth = 356
thermmargin = 5
thermformcaption = ("")
reportstartrundatetime = (DTOT({}))
reportstoprundatetime = (DTOT({}))
includeseconds = .T.
secondstext = ("secs")
escapereference = ("")
onescapecommand = ("")
thermcaption =      284[m.cMessage+ " "+ TRANSFORM(THIS.PercentDone,"999"+IIF(THIS.ThermPrecision=0,"","."+REPL("9",THIS.ThermPrecision))) + "%" + IIF(NOT THIS.IncludeSeconds, "" , " "+TRANSFORM(IIF(THIS.IsRunning,DATETIME(), THIS.ReportStopRunDateTime)-THIS.ReportStartRunDateTime)+" " + THIS.SecondsText)]
initstatustext = ("")
prepassstatustext = ("")
runstatustext = ("")
percentdone = (0)
currentrecord = (0)
drivingaliascurrentrecno = (0)
frxbandrecno = (0)
designateddriver = ("")
successorsys2024 = ("N")
thermprecision = (0)
_memberdata =     2919&lt;VFPData&gt;&lt;memberdata name="percentdone" type="property" display="percentDone" favorites="False" /&gt; &lt;memberdata name="createtherm" type="method" display="createTherm" favorites="False" /&gt; &lt;memberdata name="currentrecord" type="property" display="currentRecord" favorites="False" /&gt;&lt;memberdata name="designateddriver" type="property" display="designatedDriver" favorites="False" /&gt; &lt;memberdata name="drivingaliascurrentrecno" type="property" display="drivingAliasCurrentRecno" favorites="False" /&gt; &lt;memberdata name="escapereference" type="property" display="escapeReference" favorites="False" /&gt; &lt;memberdata name="frxbandrecno" type="property" display="frxBandRecno" favorites="False" /&gt; &lt;memberdata name="getparentwindowref" type="method" display="getParentWindowRef" favorites="False" /&gt; &lt;memberdata name="getreportscopedriver" type="method" display="getReportScopeDriver" favorites="False"/&gt;&lt;memberdata name="includeseconds" type="property" display="includeSeconds" favorites="True" /&gt; &lt;memberdata name="initstatustext" type="property" display="initStatusText" favorites="True" /&gt; &lt;memberdata name="onescapecommand" type="property" display="onEscapeCommand" favorites="False" /&gt; &lt;memberdata name="prepassstatustext" type="property" display="prepassStatusText" favorites="True" /&gt; &lt;memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" /&gt; &lt;memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" /&gt; &lt;memberdata name="resetuserfeedback" type="method" display="resetUserFeedback" favorites="False" /&gt; &lt;memberdata name="runstatustext" type="property" display="runStatusText" favorites="True" /&gt; &lt;memberdata name="secondstext" type="property" display="secondsText" favorites="True" /&gt; &lt;memberdata name="setescape" type="property" display="setEscape" favorites="False" /&gt; &lt;memberdata name="setnotifycursor" type="property" display="setNotifyCursor" favorites="False" /&gt; &lt;memberdata name="setthermformcaption" type="method" display="setThermformCaption" favorites="False" /&gt; &lt;memberdata name="thermcaption" type="property" display="thermCaption" favorites="True" /&gt; &lt;memberdata name="thermprecision" type="property" display="thermPrecision" favorites="True" /&gt; &lt;memberdata name="thermform" type="property" display="thermForm" favorites="False" /&gt; &lt;memberdata name="thermformcaption" type="property" display="thermFormCaption" favorites="True" /&gt; &lt;memberdata name="thermformheight" type="property" display="thermFormHeight" favorites="True" /&gt; &lt;memberdata name="thermformwidth" type="property" display="thermFormWidth" favorites="True" /&gt; &lt;memberdata name="thermmargin" type="property" display="thermMargin" favorites="True" /&gt; &lt;memberdata name="synchstatus" type="method" display="synchStatus" favorites="False" /&gt;&lt;memberdata name="successorsys2024" type="property" display="successorSys2024" favorites="False" /&gt;&lt;/VFPData&gt;
Name = "updatelistener"
</properties>
		<protected>thermform
setnotifycursor
setescape
escapereference
onescapecommand
percentdone
currentrecord
drivingaliascurrentrecno
frxbandrecno
designateddriver
successorsys2024
createtherm
getparentwindowref
setthermformcaption
resetuserfeedback
getreportscopedriver
synchstatus
</protected>
		<methods>PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
THIS.synchStatus(m.nBandObjCode,m.nFRXRecNo)
THIS.resetDataSession()

ENDPROC
PROCEDURE AfterReport
IF SYS(2024) # "Y"
IF THIS.IsRunning OR TYPE("THIS.CommandClauses.RecordTotal") = "N"
THIS.CurrentRecord = THIS.CommandClauses.RecordTotal
ENDIF
THIS.UpdateStatus()
ENDIF
THIS.IsRunning = .F.
THIS.ClearStatus()
THIS.designatedDriver = ""
THIS.successorSys2024 = "N"
THIS.ThermForm = NULL
THIS.ReportStopRunDateTime = DATETIME()
THIS.PopGlobalSets()
DODEFAULT()



ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
IF THIS.successorSys2024 = "Y" AND ;
THIS.CurrentPass = LISTENER_FULLPASS
* user cancelled during the prepass,
* we need to re-cancel.
THIS.setCurrentDataSession()
IF USED(THIS.designatedDriver)
GO BOTTOM IN (THIS.designatedDriver)
ENDIF
ENDIF

THIS.synchStatus(m.nBandObjCode,m.nFRXRecNo)
THIS.resetDataSession()
ENDPROC
PROCEDURE BeforeReport
DODEFAULT()
* THIS.ResetUserFeedback(.T.)
THIS.DrivingAliasCurrentRecno = 0
THIS.IsRunning = .T.
THIS.resetDataSession()



ENDPROC
PROCEDURE CancelReport
IF THIS.IsRunning AND ;
(THIS.QuietMode OR ;
(THIS.pageLimit &gt; 0 AND THIS.PageNo &gt; THIS.pageLimit) OR ;
(NOT THIS.AllowModalMessages) OR ;
THIS.DoMessage(OUTPUTCLASS_REPORT_CANCELQUERY_LOC,;
MB_ICONQUESTION+MB_YESNO) =  IDYES )

IF THIS.isSuccessor AND NOT EMPTY(THIS.designatedDriver)
* make an exception for this Listener
* to the rule that Successors don't
* handle cancelling the report, because
* this guy's job is to handle user intervention:
THIS.successorSys2024 = "Y"
LOCAL m.liSession
m.liSession = SET("DATASESSION")
THIS.setCurrentDataSession()
IF USED(THIS.designatedDriver)
GO BOTTOM IN (THIS.designatedDriver)
ENDIF
SET DATASESSION TO (m.liSession)
ENDIF

DODEFAULT()
IF SYS(2024) = "Y"  OR THIS.IsSuccessor
THIS.ThermForm = NULL
IF (THIS.pageLimit = -1 OR THIS.PageNo &lt;= THIS.pageLimit)
THIS.DoMessage(OUTPUTCLASS_REPORT_INCOMPLETE_LOC, ;
MB_ICONEXCLAMATION)
THIS.lastErrorMessage = OUTPUTCLASS_REPORT_INCOMPLETE_LOC
ENDIF
ENDIF
ELSE
NODEFAULT
ENDIF

ENDPROC
PROCEDURE ClearStatus
NODEFAULT
IF NOT ISNULL(THIS.ThermForm)
IF THIS.ThermForm.Visible
THIS.ThermForm.Visible = .F.
ENDIF
ENDIF

IF NOT ISNULL(THIS.Successor)
THIS.Successor.ClearStatus()
ENDIF
ENDPROC
PROCEDURE createtherm
#define CTLCOLOR_MSGBOX             0
#define CTLCOLOR_EDIT               1
#define CTLCOLOR_LISTBOX            2
#define CTLCOLOR_BTN                3
#define CTLCOLOR_DLG                4
#define CTLCOLOR_SCROLLBAR          5
#define CTLCOLOR_STATIC             6
#define CTLCOLOR_MAX                7
#define COLOR_SCROLLBAR             0
#define COLOR_BACKGROUND            1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER         10
#define COLOR_INACTIVEBORDER       11
#define COLOR_APPWORKSPACE         12
#define COLOR_HIGHLIGHT            13
#define COLOR_HIGHLIGHTTEXT        14
#define COLOR_BTNFACE              15
#define COLOR_BTNSHADOW            16
#define COLOR_GRAYTEXT             17
#define COLOR_BTNTEXT              18
#define COLOR_INACTIVECAPTIONTEXT  19
#define COLOR_BTNHIGHLIGHT         20
#if("4" $ OS())
#define COLOR_3DDKSHADOW           21
#define COLOR_3DLIGHT              22
#define COLOR_INFOTEXT             23
#define COLOR_INFOBK               24
#define COLOR_DESKTOP           COLOR_BACKGROUND
#define COLOR_3DFACE            COLOR_BTNFACE
#define COLOR_3DSHADOW          COLOR_BTNSHADOW
#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
#endif

IF ISNULL(THIS.ThermForm)

DECLARE INTEGER GetSysColor IN Win32API INTEGER

LOCAL m.liThermTop, m.liThermLeft, m.liThermWidth, m.liThermHeight, m.liSession
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
THIS.ThermForm = CREATEOBJECT("FORM")

WITH THIS.ThermForm

.ScaleMode = SCALEMODE_PIXELS
.Height = THIS.ThermFormHeight
.HalfHeightCaption = .T.
.Width = THIS.ThermFormWidth
.AutoCenter = .T.
.BorderStyle = BORDER_DOUBLE  &amp;&amp; fixed dialog
.ControlBox = .F.
.Closable = (NOT THIS.IsRunning)
.MaxButton = .F.
.MinButton = .F.
.Movable = (NOT THIS.IsRunning)
.AlwaysOnTop = .T.
.AllowOutput = .F.
.AddObject("ThermBack","shape")
.AddObject("ThermLabel","label")
.AddObject("ThermShape","shape")
m.liThermHeight = .Height - (THIS.ThermMargin* 2)
m.liThermWidth =  .Width - (THIS.ThermMargin*2)
ENDWITH

THIS.setCurrentDataSession()

THIS.SetThermFormCaption()

m.liThermTop = THIS.ThermMargin
m.liThermLeft = THIS.ThermMargin

WITH THIS.ThermForm.ThermBack
.Top = m.liThermTop
.Left = m.liThermLeft
.Height = m.liThermHeight
.Width = m.liThermWidth
.Visible = .T.
.BorderStyle = BORDER_SINGLE
.BackStyle = 0
ENDWITH

WITH THIS.ThermForm.ThermLabel
.Top = (.Parent.Height - .Height) /2
.Autosize = .T.
.BackStyle = FILLSTYLE_SOLID
.Caption = ""
.Visible = .T.
.ForeColor = GetSysColor( COLOR_MENUTEXT )
ENDWITH

WITH THIS.ThermForm.ThermShape
.Top = m.liThermTop +1
.Left = m.liThermLeft+1
.Height = m.liThermHeight -2
.Width = 0
.Visible = .T.
.BorderStyle = BORDER_NONE
.BackStyle = FILLSTYLE_SOLID
.FillStyle = FILLSTYLE_SOLID
.BackColor = .Parent.BackColor
.FillColor = GetSysColor(COLOR_HIGHLIGHT)
.DrawMode = DRAWMODE_MERGE_PEN_NOT
ENDWITH

SET DATASESSION TO (m.liSession)

ENDIF

RETURN NOT ISNULL(THIS.ThermForm)
ENDPROC
PROCEDURE Destroy
STORE NULL TO THIS.thermForm

DODEFAULT()
ENDPROC
PROCEDURE DoStatus
LPARAMETERS m.cMessage
LOCAL m.loParentForm, m.lcCaption, m.lcParentFormName
NODEFAULT

IF (NOT (THIS.QuietMode or ;
(THIS.IsRunning AND THIS.CommandClauses.NoDialog)))

IF EMPTY(m.cMessage) OR ISNULL(m.cMessage)
m.cMessage = ""
ENDIF

m.lcCaption = EVALUATE(THIS.ThermCaption)
IF ((NOT ISNULL(THIS.ThermForm)) OR (THIS.CreateTherm()) )

WITH THIS.ThermForm

IF THIS.IsRunning
.Closable = .F.
.Movable = .F.
ENDIF

.ThermShape.Width = MAX( (((THIS.PercentDone/100) * .ThermBack.Width)-2) ,0)

IF NOT .Visible

m.loParentForm = THIS.GetParentWindowRef()

DO CASE
CASE VARTYPE(m.loParentForm) # "O" AND (NOT _SCREEN.Visible)
m.lcParentFormName = "MACDESKTOP"
CASE VARTYPE(m.loParentForm) # "O"
m.lcParentFormName = "SCREEN"
CASE (NOT m.loParentForm.Visible) AND ;
(m.loParentForm.DeskTop OR NOT EMPTY(m.loParentForm.MacDesktop) OR ;
m.loParentForm.ShowWindow = 2 OR (NOT _SCREEN.Visible))
* in many cases,
* they've probably made a programming error,
* the parent should be visible according to
* the requirements of REPORT FORM ... IN WINDOW
* if it's a WINDOW clause they
* have no need to show it, might not be an error
* Either way, they should see the therm
* to know that the report is progressing
m.lcParentFormName = "MACDESKTOP"
CASE (NOT m.loParentForm.Visible)
* same comment as above
m.lcParentFormName = "SCREEN"
OTHERWISE
m.lcParentFormName = m.loParentForm.Name
ENDCASE

SHOW WINDOW (.Name) IN WINDOW (m.lcParentFormName)
.AlwaysOnTop = .T.
.AutoCenter = .T.
.Visible = .T.

ENDIF
.ThermLabel.Visible = .F.
.ThermLabel.Caption = m.lcCaption
.ThermLabel.Left = (.Width - .ThermLabel.Width) /2  &amp;&amp; must be after visible
.ThermLabel.Visible = .T.

ENDWITH


ENDIF

ENDIF



ENDPROC
PROCEDURE getfrxstartupinfo
DODEFAULT()

LOCAL m.llFRXAvailable, m.lcAlias

m.llFRXAvailable = THIS.getReportScopeDriver()

IF m.llFRXAvailable
THIS.SetFRXDataSession()
THIS.FRXBandRecno = 0

SELECT FRX

IF THIS.CommandClauses.Summary
* don't use groups unless
* we're forced to by Summary.
* Group usage will not work if
* there's a group on .T. or some
* other nonsensical expression that
* doesn't change.

LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_GROUPHEADER AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT DELETED()
DO WHILE NOT EOF()
* find the innermost group
THIS.FRXBandRecno = RECNO()
CONTINUE
ENDDO

IF THIS.frxBandRecno = 0
* no groups in a Summary report
* doesn't make a lot of sense, but
* can happen.
LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_PAGEHEADER AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT DELETED()
IF NOT EOF()
THIS.FRXBandRecno = RECNO()
ENDIF
ENDIF

ENDIF

IF THIS.FRXBandRecno = 0
* not a Summary report.
* look for the appropriate detail
* using the report driver
LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
TYPE(Expr) = "C" AND ;
NOT (EMPTY(Expr) OR DELETED())
DO WHILE NOT EOF()
m.lcAlias = ALLTRIM(Expr)
THIS.SetCurrentDataSession()
m.lcAlias = UPPER(EVALUATE(m.lcAlias))
THIS.SetFRXDataSession()
IF m.lcAlias == UPPER(THIS.DrivingAlias)
THIS.FRXBandRecno = RECNO()
ENDIF
CONTINUE &amp;&amp; try not to use the first detail band
ENDDO
ENDIF

IF THIS.frxBandRecno = 0
* couldn't match up a band with
* the known driver
LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
EMPTY(Expr) AND NOT DELETED()
IF NOT EOF()
THIS.FRXBandRecno = RECNO()
ELSE
IF THIS.FRXBandRecno = 0
LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
NOT DELETED()
IF NOT EOF()
THIS.FRXBandRecno = RECNO()
ENDIF
ENDIF
ENDIF
ENDIF

ENDIF

THIS.setCurrentDataSession()

ENDPROC
PROCEDURE getparentwindowref
LOCAL m.loForm, m.loTopForm, m.lcInWindow

* first top form in the list
* will be the current top form.

ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)

m.loTopForm = NULL

IF TYPE("THIS.CommandClauses.InWindow") = "C"
m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.InWindow))
ENDIF

IF EMPTY(lcInWindow) AND TYPE("THIS.CommandClauses.Window") = "C"
m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.Window))
ENDIF


IF NOT EMPTY(m.lcInWindow)

FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
IF m.loForm.ShowWindow = 2  AND ;
UPPER(m.loForm.Name) == m.lcInWindow
m.loTopForm = m.loForm
EXIT
ENDIF
ENDFOR

ENDIF

DO CASE

CASE VARTYPE(m.loTopForm) = "O"
* already found
CASE _SCREEN.FormCount = 0 OR ;
(TYPE("_SCREEN.ActiveForm") = "O" AND ;
_SCREEN.ActiveForm.ShowWindow = 0 )     &amp;&amp; ShowWindow In Screen
		
m.loTopForm = _SCREEN

CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
_SCREEN.ActiveForm.ShowWindow = 2 )    &amp;&amp; ShowWindow As Top Form

m.loTopForm = _SCREEN.ActiveForm
		
OTHERWISE
		
FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
IF m.loForm.ShowWindow = 2
m.loTopForm = m.loForm
EXIT
ENDIF
ENDFOR
		
IF VARTYPE(m.loTopForm) # "O"
m.loTopForm = _SCREEN
ENDIF
		
ENDCASE

IF VARTYPE(m.loTopForm) # "O" OR ;
EMPTY(m.loTopForm.Name)
m.loTopForm = NULL
ENDIF

RETURN m.loTopForm

ENDPROC
PROCEDURE getreportscopedriver
LOCAL m.liSelect, m.lcAlias, ;
m.liSkips,  laSkips[1]

THIS.designatedDriver = THIS.drivingAlias
* used later if we have to cancel report as
* a Successor

THIS.setFRXDataSession()

IF USED("frx")

m.liSelect = SELECT(0)
m.lcAlias = ""

SELECT FRX
* first look for any target alias that
* is the same as the driver

SCAN ALL FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
TYPE(Expr) = "C" AND ;
NOT (EMPTY(Expr)  OR DELETED())

m.lcAlias = ALLTRIM(Expr)
THIS.setCurrentDataSession()
m.lcAlias = UPPER(EVALUATE(m.lcAlias))
THIS.setFRXDataSession()
IF m.lcAlias == UPPER(THIS.drivingAlias)
EXIT
ENDIF
ENDSCAN

IF m.lcAlias == UPPER(THIS.drivingAlias)
SELECT (m.liSelect)
* if the driver is also a target alias,
* don't touch.
* otherwise:
ELSE

LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT (EMPTY(Expr) OR DELETED())
IF FOUND()
* use the first detail band, on the theory
* that people are going to put pre-processing
* calculations before other bands,
* so an early band has the best chance to be
* the right driver.
m.lcAlias = ALLTRIM(Expr)
THIS.setCurrentDataSession()
THIS.drivingAlias = UPPER(EVALUATE(m.lcAlias))
THIS.setFRXDataSession()
SELECT (m.liSelect)

ELSE

* adjust the driver based on any
* one to many relationships we can find.

SELECT (m.liSelect)

THIS.setCurrentDataSession()

m.lcAlias = THIS.drivingAlias

m.liSelect = SELECT(0)

DO WHILE NOT EMPTY(m.lcAlias)

SELECT (m.lcAlias)
m.liSkips = ALINES(laSkips,SET("SKIP"),",")
IF m.liSkips = 0 OR EMPTY(laSkips[1])
THIS.drivingAlias = m.lcAlias
m.lcAlias = ""
ELSE
m.lcAlias = laSkips[1]
* it doesn't really matter how many lines there
* are in the array; this is not going to be perfect
* but we can't predict which child
* has the most records.
ENDIF
ENDDO

SELECT (m.liSelect)

ENDIF

ENDIF
ELSE
RETURN .F.
ENDIF
ENDPROC
PROCEDURE includeseconds_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.includeseconds = m.vNewVal
ENDIF

ENDPROC
PROCEDURE Init
IF DODEFAULT()
THIS.InitStatusText = OUTPUTCLASS_INITSTATUS_LOC
THIS.PrepassStatusText = OUTPUTCLASS_PREPSTATUS_LOC
THIS.RunStatusText =  OUTPUTCLASS_RUNSTATUS_LOC
THIS.SecondsText = OUTPUTCLASS_TIME_SECONDS_LOC
THIS.thermCaption = OUTPUTCLASS_THERMCAPTION_LOC
RETURN (NOT THIS.HadError)
ELSE
RETURN .F.
ENDIF

ENDPROC
PROCEDURE initstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.InitStatusText = m.vNewVal
ENDIF
ENDPROC
PROCEDURE LoadReport
IF DODEFAULT()
THIS.ResetUserFeedback(.T.)
IF NOT (THIS.QuietMode OR ;
(TYPE("THIS.CommandClauses.NoDialog") = "L" AND ;
THIS.CommandClauses.NoDialog) )
THIS.DoStatus(THIS.initStatusText)
* NB: a user can call LoadReport manually,
* hence the need for a TYPE() check here.
ENDIF
THIS.PushGlobalSets()
ELSE
THIS.ClearStatus()
RETURN .F.
ENDIF
ENDPROC
PROCEDURE popglobalsets
DODEFAULT()
IF (NOT INLIST(_VFP.StartMode,2,3,5))
LOCAL m.lcRef
m.lcRef = THIS.EscapeReference
IF (NOT EMPTY(m.lcRef)) AND ;
TYPE(m.lcRef) = "O"
* push occurred earlier
STORE NULL TO (m.lcRef)
RELEASE &amp;lcRef.
THIS.escapeReference = ""
m.lcRef = THIS.OnEscapeCommand
ON ESCAPE &amp;lcRef
POP KEY
IF THIS.SetNotifyCursor
SET NOTIFY CURSOR ON
ENDIF
IF THIS.SetEscape
SET ESCAPE OFF
ENDIF
ENDIF
ENDIF


ENDPROC
PROCEDURE prepassstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.PrepassStatusText = m.vNewVal
ENDIF

ENDPROC
PROCEDURE pushglobalsets
DODEFAULT()
IF (NOT INLIST(_VFP.StartMode,2,3,5))
PUSH KEY CLEAR
LOCAL m.lcRef
SET MESSAGE TO ""
THIS.SetNotifyCursor = (SET("Notify",2) = "ON")
IF THIS.SetNotifyCursor
SET NOTIFY CURSOR OFF
ENDIF
THIS.OnEscapeCommand = ON("ESCAPE")
m.lcRef = SYS(2015)
PUBLIC &amp;lcRef.
STORE THIS TO (m.lcRef)
ON ESCAPE &amp;lcRef..CancelReport()
THIS.EscapeReference = m.lcRef
THIS.SetEscape = (SET("ESCAPE")="OFF")
IF THIS.SetEscape
SET ESCAPE ON
ENDIF
ENDIF


ENDPROC
PROCEDURE resetuserfeedback
LPARAMETERS m.tlResetTimes
THIS.CurrentRecord = 0
THIS.PercentDone = 0
IF m.tlResetTimes
THIS.ReportStartRunDateTime= DATETIME()
THIS.ReportStopRunDateTime= DTOT({})
ENDIF

ENDPROC
PROCEDURE runstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.RunStatusText = m.vNewVal
ENDIF


ENDPROC
PROCEDURE secondstext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.SecondsText = m.vNewVal
ENDIF

ENDPROC
PROCEDURE setfrxrunstartupconditions
DODEFAULT()
IF TYPE("THIS.CommandClauses.Summary") # "L"
ADDPROPERTY(THIS.CommandClauses,"Summary",.F.)
ENDIF
IF TYPE("THIS.CommandClauses.RecordTotal") # "N"
ADDPROPERTY(THIS.CommandClauses,"RecordTotal",0)
ENDIF

ENDPROC
PROCEDURE setthermformcaption
IF NOT ISNULL(THIS.ThermForm)
IF EMPTY(THIS.ThermFormCaption)

IF TYPE("THIS.CommandClauses.File") = "C"
LOCAL m.cName
IF EMPTY(THIS.PrintJobName)
m.cName = PROPER(JUSTFNAME(THIS.CommandClauses.File))
ELSE
m.cName = THIS.PrintJobName
ENDIF
THIS.ThermForm.Caption = ;
m.cName + ": " + OUTPUTCLASS_CANCEL_INSTRUCTIONS_LOC
ELSE
THIS.ThermForm.Caption = ""
ENDIF
ELSE
THIS.ThermForm.Caption = THIS.ThermFormCaption
ENDIF
ENDIF





ENDPROC
PROCEDURE synchstatus
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
IF THIS.isRunning AND (NOT THIS.hadError) AND ;
THIS.frxBandRecno = m.nFRXRecNo
THIS.setCurrentDataSession()
IF THIS.drivingAliasCurrentRecno  # RECNO(THIS.drivingAlias)
THIS.currentRecord = THIS.CurrentRecord + 1
THIS.drivingAliasCurrentRecno = RECNO(THIS.drivingAlias)
ENDIF
IF THIS.currentRecord &gt;= THIS.CommandClauses.RecordTotal
IF THIS.CurrentPass = 0 AND THIS.TwoPassProcess
THIS.resetUserFeedback()
ELSE
THIS.currentRecord = THIS.CommandClauses.RecordTotal
ENDIF
ENDIF
THIS.UpdateStatus()
THIS.resetDataSession()
ENDIF


ENDPROC
PROCEDURE thermcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
LOCAL m.lcType, m.cMessage
m.cMessage = ""
TRY
m.lcType = VARTYPE(EVALUATE(m.vNewVal))
IF m.lcType = "C"
THIS.ThermCaption = m.vNewVal
ENDIF
CATCH
ENDTRY
ENDIF

ENDPROC
PROCEDURE thermformcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.ThermFormCaption = m.vNewVal
THIS.SetThermFormCaption()
ENDIF

ENDPROC
PROCEDURE thermformheight_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
BETWEEN(m.vNewVal,30,SYSMETRIC(SYSMETRIC_SCREENHEIGHT )-30)  AND ;
INT(m.vNewVal) # THIS.ThermFormHeight
THIS.thermformheight = INT(m.vNewVal)
IF THIS.ThermMargin &gt; THIS.ThermFormHeight/4
THIS.ThermMargin = THIS.ThermFormHeight/4
ENDIF
THIS.thermForm = NULL
ENDIF

ENDPROC
PROCEDURE thermformwidth_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
BETWEEN(m.vNewVal,100,SYSMETRIC( SYSMETRIC_SCREENWIDTH  )-100) AND ;
INT(m.vNewVal) # THIS.ThermFormWidth
THIS.thermformwidth = INT(m.vNewVal)
IF THIS.ThermMargin &gt; THIS.ThermFormWidth/4
THIS.ThermMargin = THIS.ThermFormWidth/4
ENDIF
THIS.ThermForm = NULL
ENDIF

ENDPROC
PROCEDURE thermmargin_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
BETWEEN(m.vNewVal,1,MIN(THIS.ThermFormHeight/4,THIS.ThermFormWidth/4)) AND ;
INT(m.vNewVal) # THIS.ThermMargin
THIS.thermmargin = INT(m.vNewVal)
THIS.thermForm = NULL
ENDIF

ENDPROC
PROCEDURE thermprecision_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.thermPrecision  = ABS(INT(m.vNewVal))
ENDIF
ENDPROC
PROCEDURE UnloadReport
IF THIS.IsRunning
THIS.IsRunning = .F.
THIS.PopGlobalSets()
ENDIF

THIS.ReportStopRunDateTime = DATETIME()
THIS.ClearStatus()
THIS.ThermForm = NULL

DODEFAULT()

THIS.resetDataSession()

ENDPROC
PROCEDURE UpdateStatus
NODEFAULT
* the THIS.IsRunning check here
* make sure that this code doesn't
* run if the Engine calls UpdateStatus
* after we're through

IF THIS.isRunning
LOCAL m.liRecTotal, m.lnNewPercent, m.llShow
m.liRecTotal = THIS.CommandClauses.RecordTotal
IF m.liRecTotal &gt; 0
m.lnNewPercent = ROUND(THIS.CurrentRecord/m.liRecTotal,(THIS.ThermPrecision + 2) ) * 100
IF (THIS.PercentDone # m.lnNewPercent)
THIS.PercentDone = m.lnNewPercent
m.llShow = .T.
#IF OUTPUTCLASS_DEBUGGING
? THIS.PercentDone, THIS.CurrentRecord, m.liRecTotal, THIS.PageTotal
? REPL(OUTPUTCLASS_STATUSCHAR_PCT_DONE,INT(THIS.PercentDone/100* OUTPUTCLASS_ONE_HUNDRED_PCT_MARK))+ ;
REPL(OUTPUTCLASS_STATUSCHAR_PCT_NOT_DONE,MAX(FLOOR(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK - ;
(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK *THIS.PercentDone/100)),0) )
#ENDIF
ENDIF
ELSE
m.llShow = .T.
ENDIF
IF m.llShow
THIS.DoStatus( IIF(THIS.CurrentPass = LISTENER_PREPASS  AND THIS.TwoPassProcess,;
THIS.PrepassStatusText, ;
THIS.RunStatusText) )
ENDIF
ENDIF



ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>thermform Holds an object reference to the user feedback form.
thermformheight Holds the height of the user feedback form, in pixels.  
thermformwidth Holds the width of the user feedback form, in pixels.  
thermmargin Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
thermformcaption Holds the value used to set the title of the user feedback form.
reportstartrundatetime A datetime value indicating when the last report generation run began.
reportstoprundatetime A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
includeseconds Indicates whether the default user feedback message should include timing data.
secondstext Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
setnotifycursor Saves the state of SET NOTIFY CURSOR previous to the report run, for later restoration.
setescape Saves the state of SET ESCAPE previous to the report run, for later restoration.
escapereference Holds the name of a public variable used to facilitate interrupting a report run.
onescapecommand Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
thermcaption Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
initstatustext Provides the user message shown when user feedback first appears.
prepassstatustext User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
runstatustext Provides a user message shown during the course of a report run.
percentdone Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
currentrecord Holds the current record relative to the recordtotal in scope for the current report run.
drivingaliascurrentrecno Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
frxbandrecno Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
designateddriver Original selected alias for the report.
successorsys2024 Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
thermprecision The number of places (precision) to use for evaluating and (by default) showing the percentage done.
*createtherm Creates and configures the "update" feedback window.
*secondstext_assign 
*thermformcaption_assign 
*thermformheight_assign 
*thermformwidth_assign 
*thermmargin_assign 
*includeseconds_assign 
*getparentwindowref Provides a window reference for the top form in which the user feedback window should appear.
*setthermformcaption Sets the user feedback window title using the ThermFormCaption property.
*thermcaption_assign 
*initstatustext_assign 
*prepassstatustext_assign 
*runstatustext_assign 
*resetuserfeedback Sets user feedback to an initialized state.
*getreportscopedriver Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
*synchstatus Compares driving recno with currrently-saved information to evaluate need to update user feedback.
*thermprecision_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides user feedback while report output is generated.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>updatelistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1L50OW0FK</uniqueid>
		<timestamp>880432495</timestamp>
		<class>form</class>
		<classloc/>
		<baseclass>form</baseclass>
		<objname>fxtherm</objname>
		<parent/>
		<properties>Height = 40
Width = 356
DoCreate = .T.
AutoCenter = .T.
BorderStyle = 2
Caption = "ThermForm"
ControlBox = .F.
HalfHeightCaption = .T.
MaxButton = .F.
MinButton = .F.
AlwaysOnTop = .T.
AllowOutput = .F.
_memberdata =     3665&lt;VFPDATA&gt;&lt;memberdata name="applyfx" display="applyFX" type="method"/&gt;
&lt;memberdata name="percentdone" type="property" display="percentDone" favorites="False" /&gt; &lt;memberdata name="currentrecord" type="property" display="currentRecord" favorites="False" /&gt;&lt;memberdata name="designateddriver" type="property" display="designatedDriver" favorites="False" /&gt; &lt;memberdata name="drivingaliascurrentrecno" type="property" display="drivingAliasCurrentRecno" favorites="False" /&gt; &lt;memberdata name="escapereference" type="property" display="escapeReference" favorites="False" /&gt; &lt;memberdata name="frxbandrecno" type="property" display="frxBandRecno" favorites="False" /&gt; &lt;memberdata name="getparentwindowref" type="method" display="getParentWindowRef" favorites="False" /&gt; &lt;memberdata name="getreportscopedriver" type="method" display="getReportScopeDriver" favorites="False"/&gt;&lt;memberdata name="includeseconds" type="property" display="includeSeconds" favorites="True" /&gt; &lt;memberdata name="initstatustext" type="property" display="initStatusText" favorites="True" /&gt; &lt;memberdata name="onescapecommand" type="property" display="onEscapeCommand" favorites="False" /&gt; &lt;memberdata name="prepassstatustext" type="property" display="prepassStatusText" favorites="True" /&gt; &lt;memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" /&gt; &lt;memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" /&gt; &lt;memberdata name="resetuserfeedback" type="method" display="resetUserFeedback" favorites="False" /&gt; &lt;memberdata name="runstatustext" type="property" display="runStatusText" favorites="True" /&gt; &lt;memberdata name="secondstext" type="property" display="secondsText" favorites="True" /&gt; &lt;memberdata name="setescape" type="property" display="setEscape" favorites="False" /&gt; &lt;memberdata name="setnotifycursor" type="property" display="setNotifyCursor" favorites="False" /&gt; &lt;memberdata name="setthermformcaption" type="method" display="setThermformCaption" favorites="False" /&gt; &lt;memberdata name="thermcaption" type="property" display="thermCaption" favorites="True" /&gt; &lt;memberdata name="thermform" type="property" display="thermForm" favorites="False" /&gt; &lt;memberdata name="thermformcaption" type="property" display="thermFormCaption" favorites="True" /&gt; &lt;memberdata name="thermformheight" type="property" display="thermFormHeight" favorites="True" /&gt; &lt;memberdata name="thermformwidth" type="property" display="thermFormWidth" favorites="True" /&gt; 
&lt;memberdata name="thermprecision" type="property" display="thermPrecision" favorites="True" /&gt; &lt;memberdata name="thermmargin" type="property" display="thermMargin" favorites="True" /&gt; &lt;memberdata name="synchstatus" type="method" display="synchStatus" favorites="False" /&gt;&lt;memberdata name="successorsys2024" type="property" display="successorSys2024" favorites="False" /&gt;&lt;memberdata name="dostatus" type="method" display="doStatus" favorites="True" /&gt;&lt;memberdata name="clearstatus" type="method" display="clearStatus" favorites="True" /&gt;&lt;memberdata name="updatestatus" type="method" display="updateStatus" favorites="True" /&gt;&lt;memberdata name="pushuserfeedbackglobalsets" display="pushUserFeedbackGlobalSets" type="method"/&gt;&lt;memberdata name="popuserfeedbackglobalsets" display="popUserFeedbackGlobalSets" type="method"/&gt;&lt;memberdata name="synchuserinterface" display="synchUserInterface" type="method"/&gt;&lt;memberdata name="setupreport" type="method" display="setupReport"/&gt;&lt;memberdata name="drivingalias" type="method" display="drivingAlias"/&gt;&lt;memberdata name="persistbetweenruns" display="persistBetweenRuns" type="property" favorites="True"/&gt;
&lt;/VFPDATA&gt;
successorsys2024 = ("N")
currentrecord = (0)
designateddriver = ("")
drivingaliascurrentrecno = (0)
escapereference = ("")
frxbandrecno = (0)
includeseconds = .T.
initstatustext = ("")
onescapecommand = ("")
percentdone = (0)
prepassstatustext = ("")
reportstartrundatetime = (DTOT({}))
reportstoprundatetime = (DTOT({}))
runstatustext = ("secs")
secondstext = ("")
thermcaption =      284[m.cMessage+ " "+ TRANSFORM(THIS.PercentDone,"999"+IIF(THIS.ThermPrecision=0,"","."+REPL("9",THIS.ThermPrecision))) + "%" + IIF(NOT THIS.IncludeSeconds, "" , " "+TRANSFORM(IIF(THIS.IsRunning,DATETIME(), THIS.ReportStopRunDateTime)-THIS.ReportStartRunDateTime)+" " + THIS.SecondsText)]
thermformcaption = ("")
thermformheight = (40)
thermformwidth = (356)
thermmargin = (5)
setescape = .F.
setnotifycursor = .F.
isrunning = .F.
drivingalias = ("")
thermprecision = (2)
persistbetweenruns = .F.
Name = "fxtherm"
</properties>
		<protected>successorsys2024
currentrecord
designateddriver
drivingaliascurrentrecno
escapereference
frxbandrecno
onescapecommand
percentdone
setescape
setnotifycursor
isrunning
drivingalias
getparentwindowref
getreportscopedriver
resetuserfeedback
setthermformcaption
synchstatus
pushuserfeedbackglobalsets
popuserfeedbackglobalsets
synchuserinterface
setupreport
</protected>
		<methods>PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

LOCAL m.liSession
IF VARTYPE(m.toListener) = "O" &amp;&amp; AND ;
(NOT m.toListener.IsSuccessor)
DO CASE
CASE m.tcMethodToken == "DOSTATUS"
THIS.DoStatus(m.toListener, m.tP1)
CASE m.tcMethodToken == "UPDATESTATUS"
THIS.UpdateStatus(m.toListener)
CASE m.tcMethodToken == "CLEARSTATUS"
THIS.ClearStatus(m.toListener)
CASE m.tcMethodToken == "AFTERBAND"
THIS.synchStatus(m.toListener,m.tP1,m.tP2)
CASE m.tcMethodToken == "AFTERREPORT"
IF SYS(2024) # "Y"
IF THIS.isRunning AND TYPE("m.toListener.CommandClauses.RecordTotal") = "N"
THIS.CurrentRecord = m.toListener.CommandClauses.RecordTotal
ENDIF
THIS.UpdateStatus(m.toListener)
ENDIF
THIS.designatedDriver = ""
THIS.drivingAlias = ""
THIS.successorSys2024 = "N"
THIS.Visible = .F.
THIS.ReportStopRunDateTime = DATETIME()
THIS.popUserFeedbackGlobalSets()
THIS.ClearStatus(m.toListener)
CASE m.tcMethodToken == "BEFOREBAND"
IF THIS.successorSys2024 = "Y" AND ;
m.toListener.CurrentPass = LISTENER_FULLPASS
* user cancelled during the prepass,
* we need to re-cancel.
m.liSession = SET("DATASESSION")
SET DATASESSION TO (m.toListener.CurrentDataSession)
IF USED(THIS.designatedDriver)
GO BOTTOM IN (THIS.designatedDriver)
ENDIF
SET DATASESSION TO (m.liSession)
ENDIF
THIS.synchStatus(m.toListener,m.tP1,m.tP2)
CASE m.tcMethodToken == "BEFOREREPORT"
THIS.setupReport(m.toListener)
CASE m.tcMethodToken == "CANCELREPORT"
IF THIS.isRunning AND ;
(m.toListener.QuietMode OR ;
(m.toListener.pageLimit &gt; 0 AND m.toListener.PageNo &gt; m.toListener.pageLimit) OR ;
(NOT m.toListener.AllowModalMessages) OR ;
m.toListener.DoMessage(OUTPUTCLASS_REPORT_CANCELQUERY_LOC,;
MB_ICONQUESTION+MB_YESNO) =  IDYES )

m.toListener.cancelRequested = .T.

IF m.toListener.isSuccessor AND NOT EMPTY(THIS.designatedDriver)
* NB: FX should ordinarily not be used in a successor,
* but this won't hurt and will take care of the exception
THIS.successorSys2024 = "Y"
m.liSession = SET("DATASESSION")
SET DATASESSION TO (m.toListener.CurrentDataSession)
IF USED(THIS.designatedDriver)
GO BOTTOM IN (THIS.designatedDriver)
ENDIF
SET DATASESSION TO (m.liSession)
ENDIF
IF SYS(2024) = "Y"  OR m.toListener.IsSuccessor
THIS.Visible = .F.
IF (m.toListener.pageLimit = -1 OR m.toListener.PageNo &lt;= m.toListener.pageLimit)
m.toListener.DoMessage(OUTPUTCLASS_REPORT_INCOMPLETE_LOC, ;
MB_ICONEXCLAMATION)
ENDIF
ENDIF
RETURN .F.
ELSE
RETURN .T. &amp;&amp; did not handle, use default behavior
ENDIF
CASE m.tcMethodToken == "LOADREPORT"
THIS.ResetUserFeedback(.T.)
m.toListener.AddProperty("reportStartRunDatetime",THIS.reportStartRunDatetime)
IF NOT (m.toListener.QuietMode OR ;
(TYPE("m.toListener.CommandClauses.NoDialog") = "L" AND ;
m.toListener.CommandClauses.NoDialog) )
THIS.DoStatus(m.toListener,THIS.initStatusText)
* NB: a user can call LoadReport manually,
* hence the need for a TYPE() check here.
ENDIF
THIS.pushUserFeedbackGlobalSets(m.toListener)
CASE m.tcMethodToken == "UNLOADREPORT"
THIS.ReportStopRunDateTime = DATETIME()
m.toListener.AddProperty("reportStopRunDatetime",THIS.reportStopRunDatetime)
THIS.IsRunning = .F.
THIS.ClearStatus()
IF NOT THIS.persistBetweenRuns
SET DATASESSION TO (m.toListener.ListenerDataSession)
THIS.Release()
ENDIF
ENDCASE
SET DATASESSION TO (m.toListener.ListenerDataSession)
ENDIF


ENDPROC
PROCEDURE clearstatus
LPARAMETERS m.toListener
IF THIS.Visible
THIS.Visible = .F.
ENDIF

ENDPROC
PROCEDURE dostatus
LPARAMETERS m.toListener, m.cMessage
LOCAL m.loParentForm, m.lcCaption, m.lcParentFormName

IF (VARTYPE(m.toListener) # "O") OR (NOT (m.toListener.QuietMode OR ;
(THIS.isRunning AND m.toListener.CommandClauses.NoDialog)))

IF EMPTY(m.cMessage) OR ISNULL(m.cMessage)
m.cMessage = ""
ENDIF

m.lcCaption = EVALUATE(THIS.ThermCaption)

WITH THIS

IF THIS.isRunning
THIS.Closable = .F.
THIS.Movable = .F.
ENDIF
.ThermShape.Width = MAX( (((THIS.PercentDone/100) * .ThermBack.Width)-2) ,0)
IF NOT .Visible

m.loParentForm = THIS.GetParentWindowRef()

DO CASE
CASE VARTYPE(m.loParentForm) # "O" AND (NOT _SCREEN.Visible)
m.lcParentFormName = "MACDESKTOP"
CASE VARTYPE(m.loParentForm) # "O"
m.lcParentFormName = "SCREEN"
CASE (NOT m.loParentForm.Visible) AND ;
(m.loParentForm.DeskTop OR NOT EMPTY(m.loParentForm.MacDesktop) OR ;
m.loParentForm.ShowWindow = 2 OR (NOT _SCREEN.Visible))
* in many cases,
* they've probably made a programming error,
* the parent should be visible according to
* the requirements of REPORT FORM ... IN WINDOW
* if it's a WINDOW clause they
* have no need to show it, might not be an error
* Either way, they should see the therm
* to know that the report is progressing
m.lcParentFormName = "MACDESKTOP"
CASE (NOT m.loParentForm.Visible)
* same comment as above
m.lcParentFormName = "SCREEN"
OTHERWISE
m.lcParentFormName = m.loParentForm.Name
ENDCASE

SHOW WINDOW (.Name) IN WINDOW (m.lcParentFormName)
.AlwaysOnTop = .T.
.AutoCenter = .T.
.Visible = .T.
ENDIF
.ThermLabel.Visible = .F.
.ThermLabel.Caption = m.lcCaption
.ThermLabel.Left = (.Width - .ThermLabel.Width) /2 &amp;&amp; doesn't work until after visibility of form
.ThermLabel.Visible = .T.

ENDWITH

m.loParentForm = NULL


ENDIF



ENDPROC
PROCEDURE getparentwindowref
LOCAL m.loForm, m.loTopForm, m.lcInWindow

* first top form in the list
* will be the current top form.

ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)

m.loTopForm = NULL

IF TYPE("THIS.CommandClauses.InWindow") = "C"
m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.InWindow))
ENDIF

IF EMPTY(lcInWindow) AND TYPE("THIS.CommandClauses.Window") = "C"
m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.Window))
ENDIF


IF NOT EMPTY(m.lcInWindow)

FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
IF m.loForm.ShowWindow = 2  AND ;
UPPER(m.loForm.Name) == m.lcInWindow
m.loTopForm = m.loForm
EXIT
ENDIF
ENDFOR

ENDIF

DO CASE

CASE VARTYPE(m.loTopForm) = "O"
* already found
CASE _SCREEN.FormCount = 0 OR ;
(TYPE("_SCREEN.ActiveForm") = "O" AND ;
_SCREEN.ActiveForm.ShowWindow = 0 )     &amp;&amp; ShowWindow In Screen
		
m.loTopForm = _SCREEN

CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
_SCREEN.ActiveForm.ShowWindow = 2 )    &amp;&amp; ShowWindow As Top Form

m.loTopForm = _SCREEN.ActiveForm
		
OTHERWISE
		
FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
IF m.loForm.ShowWindow = 2
m.loTopForm = m.loForm
EXIT
ENDIF
ENDFOR
		
IF VARTYPE(m.loTopForm) # "O"
m.loTopForm = _SCREEN
ENDIF
		
ENDCASE

IF VARTYPE(m.loTopForm) # "O" OR ;
EMPTY(m.loTopForm.Name)
m.loTopForm = NULL
ENDIF

RETURN m.loTopForm

ENDPROC
PROCEDURE getreportscopedriver
LPARAMETERS m.toListener

LOCAL m.liSelect, m.lcAlias, ;
m.liSkips,  laSkips[1]

IF m.toListener.FRXDataSession &gt; 0
SET DATASESSION TO (m.toListener.FRXDataSession)
ELSE
RETURN .F.
ENDIF

THIS.designatedDriver = THIS.drivingAlias
* used later if we have to cancel report as
* a Successor

IF USED("frx")

m.liSelect = SELECT(0)
m.lcAlias = ""

SELECT FRX
* first look for any target alias that
* is the same as the driver

SCAN ALL FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
TYPE(Expr) = "C" AND ;
NOT (EMPTY(Expr)  OR DELETED())
m.lcAlias = ALLTRIM(Expr)
SET DATASESSION TO (m.toListener.CurrentDataSession)
m.lcAlias = UPPER(EVALUATE(m.lcAlias))
SET DATASESSION TO (m.toListener.FRXDataSession)
IF m.lcAlias == UPPER(THIS.drivingAlias)
EXIT
ENDIF
ENDSCAN

IF m.lcAlias == UPPER(THIS.drivingAlias)

SELECT (m.liSelect)
* if the driver is also a target alias,
* don't touch.
* otherwise:
ELSE

LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT (EMPTY(Expr) OR DELETED())
IF FOUND()
* use the first detail band, on the theory
* that people are going to put pre-processing
* calculations before other bands,
* so an early band has the best chance to be
* the right driver.
m.lcAlias = ALLTRIM(Expr)
SET DATASESSION TO (m.toListener.CurrentDataSession)
THIS.drivingAlias = UPPER(EVALUATE(m.lcAlias))
SET DATASESSION TO (m.toListener.FrxDataSession)
SELECT (m.liSelect)

ELSE

* adjust the driver based on any
* one to many relationships we can find.

SELECT (m.liSelect)
SET DATASESSION TO (m.toListener.CurrentDataSession)

m.lcAlias = THIS.drivingAlias

m.liSelect = SELECT(0)

DO WHILE NOT EMPTY(m.lcAlias)

SELECT (m.lcAlias)
m.liSkips = ALINES(laSkips,SET("SKIP"),",")
IF m.liSkips = 0 OR EMPTY(laSkips[1])
THIS.drivingAlias = m.lcAlias
m.lcAlias = ""
ELSE
m.lcAlias = laSkips[1]
* it doesn't really matter how many lines there
* are in the array; this is not going to be perfect
* but we can't predict which child
* has the most records.
ENDIF
ENDDO

SELECT (m.liSelect)

ENDIF

ENDIF
ELSE
RETURN .F.
ENDIF

ENDPROC
PROCEDURE includeseconds_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.includeSeconds = m.vNewVal
ENDIF

ENDPROC
PROCEDURE Init
THIS.Name = "X"+SYS(2015)
WITH THIS
.InitStatusText = OUTPUTCLASS_INITSTATUS_LOC
.PrepassStatusText = OUTPUTCLASS_PREPSTATUS_LOC
.RunStatusText =  OUTPUTCLASS_RUNSTATUS_LOC
.SecondsText = OUTPUTCLASS_TIME_SECONDS_LOC
.thermCaption = OUTPUTCLASS_THERMCAPTION_LOC
.resetUserFeedback()
ENDWITH



ENDPROC
PROCEDURE initstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.initStatusText = m.vNewVal
ENDIF
ENDPROC
PROCEDURE Load


ENDPROC
PROCEDURE persistbetweenruns_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.persistBetweenRuns = m.vNewVal
ENDIF

ENDPROC
PROCEDURE popuserfeedbackglobalsets
IF (NOT INLIST(_VFP.StartMode,2,3,5))
LOCAL m.lcRef
m.lcRef = THIS.EscapeReference
IF (NOT EMPTY(m.lcRef)) AND ;
TYPE(m.lcRef) = "O"
* push occurred earlier
STORE NULL TO (m.lcRef)
RELEASE &amp;lcRef.
THIS.escapeReference = ""
m.lcRef = THIS.OnEscapeCommand
ON ESCAPE &amp;lcRef
POP KEY
IF THIS.SetNotifyCursor
SET NOTIFY CURSOR ON
ENDIF
IF THIS.SetEscape
SET ESCAPE OFF
ENDIF
ENDIF
ENDIF


ENDPROC
PROCEDURE prepassstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.prepassStatusText = m.vNewVal
ENDIF

ENDPROC
PROCEDURE pushuserfeedbackglobalsets
LPARAMETERS m.toListener
IF (NOT INLIST(_VFP.StartMode,2,3,5))
PUSH KEY CLEAR
LOCAL m.lcRef
SET MESSAGE TO ""
THIS.SetNotifyCursor = (SET("Notify",2) = "ON")
IF THIS.SetNotifyCursor
SET NOTIFY CURSOR OFF
ENDIF
THIS.OnEscapeCommand = ON("ESCAPE")
m.lcRef = SYS(2015)
PUBLIC &amp;lcRef.
STORE m.toListener TO (m.lcRef)
ON ESCAPE &amp;lcRef..CancelReport()
THIS.EscapeReference = m.lcRef
THIS.SetEscape = (SET("ESCAPE")="OFF")
IF THIS.SetEscape
SET ESCAPE ON
ENDIF
ENDIF


ENDPROC
PROCEDURE resetuserfeedback
LPARAMETERS m.tlResetTimes

THIS.CurrentRecord = 0
THIS.PercentDone = 0
IF m.tlResetTimes
THIS.ReportStartRunDateTime= DATETIME()
THIS.ReportStopRunDateTime= DTOT({})
THIS.thermFormCaption = ""
THIS.synchUserInterface()
ENDIF

ENDPROC
PROCEDURE runstatustext_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
THIS.runStatusText = m.vNewVal

ENDPROC
PROCEDURE secondstext_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
THIS.secondsText = m.vNewVal

ENDPROC
PROCEDURE setthermformcaption
LPARAMETERS tcCommandClausesFile, tcPrintJobName
IF EMPTY(THIS.ThermFormCaption)
IF VARTYPE(tcCommandClausesFile) = "C"
LOCAL m.cName
IF EMPTY( tcPrintJobName) OR VARTYPE( tcPrintJobName) # "C"
m.cName = PROPER(JUSTFNAME(tcCommandClausesFile))
ELSE
m.cName =  tcPrintJobName
ENDIF
THIS.thermFormCaption = ;
m.cName + ": " + OUTPUTCLASS_CANCEL_INSTRUCTIONS_LOC
ELSE
THIS.thermFormCaption = ""
ENDIF
ENDIF
THIS.Caption = THIS.thermFormCaption






ENDPROC
PROCEDURE setupreport
LPARAMETERS m.toListener

LOCAL m.llFRXAvailable, m.lcAlias

THIS.isRunning = .T.

WITH m.toListener
SET DATASESSION TO (.CurrentDataSession)
THIS.DrivingAlias = UPPER(ALIAS())
IF .FRXDataSession &gt; 0
SET DATASESSION TO (.FRXDataSession)
ENDIF
m.llFRXAvailable = THIS.getReportScopeDriver(m.toListener)

IF m.llFRXAvailable
THIS.setThermformCaption(m.toListener.CommandClauses.File, m.toListener.PrintJobName)

IF TYPE("m.toListener.CommandClauses.Summary") # "L"
ADDPROPERTY(.CommandClauses,"Summary",.F.)
ENDIF
IF TYPE("m.toListener.CommandClauses.RecordTotal") # "N"
ADDPROPERTY(.CommandClauses,"RecordTotal",0)
ENDIF
IF TYPE("m.toListener.CommandClauses.NoDialog") # "L"
ADDPROPERTY(.CommandClauses,"NoDialog",.F.)
ENDIF
SET DATASESSION TO (.FRXDataSession)
THIS.FRXBandRecno = 0
SELECT FRX

IF .CommandClauses.Summary
* don't use groups unless
* we're forced to by Summary.
* Group usage will not work if
* there's a group on .T. or some
* other nonsensical expression that
* doesn't change.

LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_GROUPHEADER AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT DELETED()
DO WHILE NOT EOF()
* find the innermost group
THIS.FRXBandRecno = RECNO()
CONTINUE
ENDDO

IF THIS.frxBandRecno = 0
* no groups in a Summary report
* doesn't make a lot of sense, but
* can happen.
LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
Objcode = FRX_OBJCOD_PAGEHEADER AND ;
NOT DELETED()
IF NOT EOF()
THIS.FRXBandRecno = RECNO()
ENDIF
ENDIF

ENDIF

IF THIS.FRXBandRecno = 0
* not a Summary report.
* look for the appropriate detail
* using the report driver

LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
TYPE(Expr) = "C" AND ;
NOT (EMPTY(Expr) OR DELETED())
DO WHILE NOT EOF()
m.lcAlias = ALLTRIM(Expr)
SET DATASESSION TO (.CurrentDataSession)
m.lcAlias = UPPER(EVALUATE(m.lcAlias))
SET DATASESSION TO (.FRXDataSession)
IF m.lcAlias == UPPER(THIS.DrivingAlias)
THIS.FRXBandRecno = RECNO()
ENDIF
CONTINUE &amp;&amp; try not to use the first detail band
ENDDO

ENDIF

IF THIS.frxBandRecno = 0
* couldn't match up a band with
* the known driver
LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
EMPTY(Expr) AND NOT DELETED()
IF NOT EOF()
THIS.FRXBandRecno = RECNO()
ELSE
IF THIS.FRXBandRecno = 0
LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
Objcode = FRX_OBJCOD_DETAIL AND ;
NOT DELETED()
IF NOT EOF()
THIS.FRXBandRecno = RECNO()
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
THIS.DrivingAliasCurrentRecno = 0
SET DATASESSION TO (.ListenerDataSession)

ENDWITH




ENDPROC
PROCEDURE synchstatus
LPARAMETERS m.toListener, m.nBandObjCode, m.nFRXRecNo

IF THIS.isRunning AND ;
THIS.frxBandRecno = m.nFRXRecNo
WITH m.toListener
TRY
SET DATASESSION TO (.CurrentDataSession)
IF THIS.drivingAliasCurrentRecno  # RECNO(THIS.drivingAlias)
THIS.currentRecord = THIS.CurrentRecord + 1
THIS.drivingAliasCurrentRecno = RECNO(THIS.drivingAlias)
ENDIF
IF THIS.currentRecord &gt;= .CommandClauses.RecordTotal
IF .CurrentPass = 0 AND .TwoPassProcess
THIS.resetUserFeedback()
ELSE
THIS.currentRecord = .CommandClauses.RecordTotal
ENDIF
ENDIF
THIS.updateStatus(m.toListener)
CATCH TO err
#IF OUTPUTCLASS_DEBUGGING
SUSPEND
#ENDIF
ENDTRY
SET DATASESSION TO (.ListenerDataSession)
ENDWITH
ENDIF


ENDPROC
PROCEDURE synchuserinterface

#define CTLCOLOR_MSGBOX             0
#define CTLCOLOR_EDIT               1
#define CTLCOLOR_LISTBOX            2
#define CTLCOLOR_BTN                3
#define CTLCOLOR_DLG                4
#define CTLCOLOR_SCROLLBAR          5
#define CTLCOLOR_STATIC             6
#define CTLCOLOR_MAX                7
#define COLOR_SCROLLBAR             0
#define COLOR_BACKGROUND            1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER         10
#define COLOR_INACTIVEBORDER       11
#define COLOR_APPWORKSPACE         12
#define COLOR_HIGHLIGHT            13
#define COLOR_HIGHLIGHTTEXT        14
#define COLOR_BTNFACE              15
#define COLOR_BTNSHADOW            16
#define COLOR_GRAYTEXT             17
#define COLOR_BTNTEXT              18
#define COLOR_INACTIVECAPTIONTEXT  19
#define COLOR_BTNHIGHLIGHT         20
#if("4" $ OS())
#define COLOR_3DDKSHADOW           21
#define COLOR_3DLIGHT              22
#define COLOR_INFOTEXT             23
#define COLOR_INFOBK               24
#define COLOR_DESKTOP           COLOR_BACKGROUND
#define COLOR_3DFACE            COLOR_BTNFACE
#define COLOR_3DSHADOW          COLOR_BTNSHADOW
#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
#endif


DECLARE INTEGER GetSysColor IN Win32API INTEGER

LOCAL m.liThermTop, m.liThermLeft, m.liThermWidth, m.liThermHeight

WITH THIS
.Height = .ThermFormHeight
.Width = .ThermFormWidth
.ControlBox = .F.
.Closable = .T.
.Movable = .T.
m.liThermHeight = .Height - (.ThermMargin* 2)
m.liThermWidth =  .Width - (.ThermMargin*2)
.SetThermFormCaption()
m.liThermTop =  .ThermMargin
m.liThermLeft = .ThermMargin
ENDWITH

WITH THIS.ThermBack
.Top = m.liThermTop
.Left = m.liThermLeft
.Height = m.liThermHeight
.Width = m.liThermWidth
ENDWITH

WITH THIS.ThermLabel
.Top = (.Parent.Height - .Height) /2
.ForeColor = GetSysColor( COLOR_MENUTEXT )
ENDWITH

WITH THIS.ThermShape
.Top = m.liThermTop +1
.Left = m.liThermLeft+1
.Height = m.liThermHeight -2
.Width = 0
.BackColor = .Parent.BackColor
.FillColor = GetSysColor(COLOR_HIGHLIGHT)
ENDWITH




ENDPROC
PROCEDURE thermcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
LOCAL m.lcType, m.cMessage
m.cMessage = ""
TRY
m.lcType = VARTYPE(EVALUATE(m.vNewVal))
IF m.lcType = "C"
THIS.thermCaption = m.vNewVal
ENDIF
CATCH
ENDTRY

ENDIF

ENDPROC
PROCEDURE thermformcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.thermFormCaption = m.vNewVal
THIS.setThermFormCaption()
ENDIF

ENDPROC
PROCEDURE thermformheight_assign
LPARAMETERS m.vNewVal
IF  VARTYPE(m.vNewVal) = "N" AND ;
BETWEEN(m.vNewVal,30,SYSMETRIC(SYSMETRIC_SCREENHEIGHT )-30)  AND ;
INT(m.vNewVal) # THIS.thermFormHeight
THIS.thermFormHeight = INT(m.vNewVal)
IF THIS.thermMargin &gt; THIS.thermFormHeight/4
THIS.thermMargin = THIS.thermFormHeight/4
ENDIF
THIS.synchUserInterface()
ENDIF

ENDPROC
PROCEDURE thermformwidth_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
BETWEEN(m.vNewVal,100,SYSMETRIC( SYSMETRIC_SCREENWIDTH  )-100) AND ;
INT(m.vNewVal) # THIS.ThermFormWidth
THIS.thermFormWidth = INT(m.vNewVal)
IF THIS.thermMargin &gt; THIS.thermFormWidth/4
THIS.thermMargin = THIS.thermFormWidth/4
ENDIF
THIS.synchUserInterface()
ENDIF

ENDPROC
PROCEDURE thermmargin_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
BETWEEN(m.vNewVal,1,MIN(THIS.ThermFormHeight/4,THIS.ThermFormWidth/4)) AND ;
INT(m.vNewVal) # THIS.thermMargin
THIS.thermMargin = INT(m.vNewVal)
THIS.synchUserInterface()
ENDIF

ENDPROC
PROCEDURE thermprecision_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.thermPrecision  = ABS(INT(m.vNewVal))
ENDIF
ENDPROC
PROCEDURE updatestatus
LPARAMETERS m.toListener
IF VARTYPE(m.toListener) = "O" AND THIS.isRunning
LOCAL m.liRecTotal, m.lnNewPercent, m.llShow
m.liRecTotal = m.toListener.CommandClauses.RecordTotal
IF m.liRecTotal &gt; 0
m.lnNewPercent = ROUND(THIS.CurrentRecord/m.liRecTotal,(THIS.ThermPrecision + 2) ) * 100
IF (THIS.PercentDone # m.lnNewPercent)
THIS.PercentDone = m.lnNewPercent
m.llShow = .T.
#IF OUTPUTCLASS_DEBUGGING
? THIS.PercentDone, THIS.CurrentRecord, m.liRecTotal, m.toListener.PageTotal
? REPL(OUTPUTCLASS_STATUSCHAR_PCT_DONE,INT(THIS.PercentDone/100* OUTPUTCLASS_ONE_HUNDRED_PCT_MARK))+ ;
REPL(OUTPUTCLASS_STATUSCHAR_PCT_NOT_DONE,MAX(FLOOR(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK - ;
(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK *THIS.PercentDone/100)),0) )
#ENDIF
ENDIF
ELSE
m.llShow = .T.
ENDIF
IF m.llShow
THIS.DoStatus(m.toListener, ;
IIF(m.toListener.CurrentPass = LISTENER_PREPASS  AND m.toListener.TwoPassProcess,;
THIS.PrepassStatusText, ;
THIS.RunStatusText) )
ENDIF
ENDIF




ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>4</reserved2>
		<reserved3>_memberdata XML Metadata for customizable properties
successorsys2024 Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
currentrecord Holds the current record relative to the recordtotal in scope for the current report run.
designateddriver Original selected alias for the report.
drivingaliascurrentrecno Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
escapereference Holds the name of a public variable used to facilitate interrupting a report run.
frxbandrecno Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
includeseconds Indicates whether the default user feedback message should include timing data.
initstatustext Provides the user message shown when user feedback first appears.
onescapecommand Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
percentdone Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
prepassstatustext User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
reportstartrundatetime A datetime value indicating when the last report generation run began.
reportstoprundatetime A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
runstatustext Provides a user message shown during the course of a report run.
secondstext Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
thermcaption Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
thermformcaption Holds the value used to set the title of the user feedback form.
thermformheight Holds the height of the user feedback form, in pixels.  
thermformwidth Holds the width of the user feedback form, in pixels.  
thermmargin Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
setescape Saves the state of SET ESCAPE previous to the report run, for later restoration.
setnotifycursor Saves the state of SET NOTIFY CURSOR previous to the report run, for later restoration.
isrunning Indicates whether a report run is in progress.
drivingalias Stores the effective driving alias for a report from the point of view of the therm update.
thermprecision The number of places (precision) to use for evaluating and (by default) showing the percentage done.
persistbetweenruns Allows the therm window to continue to exist (maintaining its end-of-run contents) after the run of the report.  It may potentially show up on the automatic _MWINDOW list if this is turned on.
*applyfx Implements required API for an object included in the FXListener FXs collection.
*includeseconds_assign 
*initstatustext_assign 
*prepassstatustext_assign 
*runstatustext_assign 
*secondstext_assign 
*thermcaption_assign 
*thermformcaption_assign 
*thermformheight_assign 
*thermformwidth_assign 
*thermmargin_assign 
*getparentwindowref Provides a window reference for the top form in which the user feedback window should appear.
*getreportscopedriver Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
*resetuserfeedback Sets user feedback to an initialized state.
*setthermformcaption Sets the user feedback window title using the ThermFormCaption property.
*synchstatus Compares driving recno with currrently-saved information to evaluate need to update user feedback.
*dostatus Delegate for ReportListener DoStatus method.
*clearstatus Delegate for ReportListener ClearStatus method.
*updatestatus Delegate for ReportListener UpdateStatus method.
*pushuserfeedbackglobalsets Handles non-session-specific user feedback SETtings and behavior.
*popuserfeedbackglobalsets Handles non-session-specific user feedback SETtings and behavior.
*synchuserinterface Set up therm form to match latest user specifications.
*setupreport Handles ReportListener's BeforeReport status preparation chores.
*thermprecision_assign 
*persistbetweenruns_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>FX interface-conformant object derived from form class, providing user feedback during a report run.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1L50TVYFO</uniqueid>
		<timestamp>880432495</timestamp>
		<class>shape</class>
		<classloc/>
		<baseclass>shape</baseclass>
		<objname>THERMBACK</objname>
		<parent>fxtherm</parent>
		<properties>DefTop = 
DefLeft = 
DefHeight = 
DefWidth = 
Top = 5
Left = 0
Height = 30
Width = 276
BackStyle = 0
Visible = .T.
Name = "THERMBACK"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1L50TX61Q</uniqueid>
		<timestamp>880432495</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>THERMLABEL</objname>
		<parent>fxtherm</parent>
		<properties>AutoSize = .T.
DefTop = 
BackStyle = 1
Caption = ""
Left = 8
Top = ( (THISFORM.Height - THIS.Height) /2)
Visible = .T.
Width = 2
ForeColor = 0,0,0
Name = "THERMLABEL"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1L50UUD6E</uniqueid>
		<timestamp>880432495</timestamp>
		<class>shape</class>
		<classloc/>
		<baseclass>shape</baseclass>
		<objname>THERMSHAPE</objname>
		<parent>fxtherm</parent>
		<properties>DefTop = 
DefLeft = 
DefHeight = 
Top = (THISFORM.ThermBack.Top + 1)
Left = (THISFORM.ThermBack.Left + 1)
Height = (THISFORM.ThermBack.Height -2)
Width = 0
BorderStyle = 0
DrawMode = 14
FillStyle = 0
Visible = .T.
BackColor = (THISFORM.BackColor)
FillColor = 178,180,191
Name = "THERMSHAPE"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>fxtherm</objname>
		<parent/>
		<properties>Arial, 0, 9, 5, 15, 12, 32, 3, 0
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_16E19GTD6</uniqueid>
		<timestamp>894986849</timestamp>
		<class>xmllistener</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>reportlistener</baseclass>
		<objname>xmldisplaylistener</objname>
		<parent/>
		<properties>FRXDataSession = -1
jpgclsid = (.NULL.)
oldsendgdiplusimage = 0
oldexternalfilelocation = ("")
imagefieldinstance = 0
imagefieldtofile = ("")
imagesrcattr = ("img")
imagefilebasename = ("")
utilityimage = .NULL.
fillalphaattr = ("FA")
fillredattr = ("FR")
fillgreenattr = ("FG")
fillblueattr = ("FB")
penalphaattr = ("PA")
penredattr = ("PR")
pengreenattr = ("PG")
penblueattr = ("PB")
fontnameattr = ("FNAME")
fontstyleattr = ("FSTYLE")
fontsizeattr = ("FSIZE")
externalfilelocation = ("")
includeformattinginlayoutobjects = .T.
includebandswithnoobjects = .T.
_memberdata =     1925&lt;VFPData&gt; &lt;memberdata name="copyimagefilestoexternalfilelocation" type="property" display="copyImageFilesToExternalFileLocation" favorites="True" /&gt; &lt;memberdata name="imagefieldinstance" type="property" display="imageFieldInstance"  /&gt; &lt;memberdata name="imagefieldtofile" type="property" display="imageFieldToFile"  /&gt; &lt;memberdata name="imagefilebasename" type="property" display="imageFileBaseName" favorites="True" /&gt; &lt;memberdata name="imagesrcattr" type="property" display="imageSrcAttr" favorites="True" /&gt; &lt;memberdata name="jpgclsid" type="property" display="JPGclsid" /&gt; &lt;memberdata name="oldexternalfilelocation" type="property" display="oldExternalFileLocation"  /&gt; &lt;memberdata name="oldsendgdiplusimage" type="property" display="oldSendGDIPlusImage"/&gt; &lt;memberdata name="checkreportforgeneralfields" type="method" display="checkReportForGeneralFields" /&gt;&lt;memberdata name="initializefilecopysettings" type="method" display="initializeFileCopySettings" /&gt;&lt;memberdata name="utilityimage" type="property" display="utilityImage" /&gt;&lt;memberdata name="adjustshapeaspectratio" type="method" display="adjustShapeAspectRatio" /&gt;&lt;memberdata name="fillalphaattr" display="fillAlphaAttr" type="property"/&gt;&lt;memberdata name="fillredattr" display="fillRedAttr" type="property"/&gt;&lt;memberdata name="fillgreenattr" display="fillGreenAttr" type="property"/&gt;&lt;memberdata name="fillblueattr" display="fillBlueAttr" type="property"/&gt;&lt;memberdata name="penalphaattr" display="penAlphaAttr" type="property"/&gt;&lt;memberdata name="penredattr" display="penRedAttr" type="property"/&gt;&lt;memberdata name="pengreenattr" display="penGreenAttr" type="property"/&gt;&lt;memberdata name="penblueattr" display="penBlueAttr" type="property"/&gt;&lt;memberdata name="fontnameattr" display="fontNameAttr" type="property"/&gt;&lt;memberdata name="fontstyleattr" display="fontStyleAttr" type="property"/&gt;&lt;memberdata name="fontsizeattr" display="fontSizeAttr" type="property"/&gt;&lt;/VFPData&gt;
Name = "xmldisplaylistener"
</properties>
		<protected>jpgclsid
oldsendgdiplusimage
oldexternalfilelocation
imagefieldinstance
imagefieldtofile
utilityimage
checkreportforgeneralfields
initializefilecopysettings
adjustshapeaspectratio
</protected>
		<methods>PROCEDURE adjustshapeaspectratio
LPARAMETERS m.tnWidth, m.tnHeight
IF VARTYPE(THIS.utilityImage) = "O"
* the image is coming from a file of some sort
* and we need to scale-and-retain
LOCAL m.llAdjustHeight, m.llAdjustWidth
DO CASE
CASE (tnWidth &lt; tnHeight)
* use 100% of the width of the space and scale the height
m.llAdjustHeight = .T.
CASE (tnWidth &gt; tnHeight)
* use 100% of the height of the space and scale the width
m.llAdjustWidth = .T.
CASE (m.tnWidth = m.tnHeight)
DO CASE
CASE THIS.utilityImage.Height &gt; THIS.utilityImage.Width
m.llAdjustWidth = .T.
CASE THIS.utilityImage.Height &lt; THIS.utilityImage.Width
m.llAdjustHeight = .T.
OTHERWISE
* both square, don't do adjustment
ENDCASE
ENDCASE
If m.llAdjustWidth
m.tnWidth = m.tnHeight *  ;
(THIS.utilityImage.Width / THIS.utilityImage.Height)
ENDIF
If m.llAdjustHeight
m.tnHeight = m.tnWidth * ;
(THIS.utilityImage.Height / THIS.utilityImage.Width)
ENDIF
ENDIF
ENDPROC
PROCEDURE AfterReport
LPARAMETERS tlCalledEarly
DODEFAULT(tlCalledEarly)
THIS.resetDataSession()
ENDPROC
PROCEDURE BeforeReport
IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
THIS.oldSendGDIPlusImage = THIS.SendGDIPlusImage
THIS.oldExternalFileLocation =  THIS.ExternalFileLocation
THIS.JPGclsid = NULL &amp;&amp; force reinitialization for each report
&amp;&amp; on possible discovery of an image control mid-way
IF THIS.checkReportForGeneralFields()
THIS.initializeFileCopySettings()
ENDIF
ENDIF
DODEFAULT()
THIS.resetDataSession()

ENDPROC
PROCEDURE checkreportforgeneralfields
LOCAL m.liGeneralFields, m.lcID, m.llOpened

m.liGeneralFields = 0

IF TYPE("THIS.CommandClauses.File") = "C" AND ;
(NOT EMPTY(THIS.CommandClauses.File)) AND ;
(FILE(THIS.CommandClauses.File)) &amp;&amp; NB this is done before setting up dummy CommandClauses

THIS.SetFRXDataSession()

IF USED("FRX")
* this will be true
* if we call in BeforeReport,
* but that seems to cause a problem,
* when we re-assign SendGDIPlusImage
* so we're likely to call earlier,
* in the LoadReport method
SELECT FRX
ELSE
USE (THIS.CommandClauses.File) SHARED NOUPDATE ALIAS FRX IN 0
SELECT FRX
m.llOpened = .T.
ENDIF

COUNT FOR ObjType = FRX_OBJTYP_PICTURE  AND  ;
Offset =  FRX_PICTURE_SOURCE_GENERAL TO ;
m.liGeneralFields

IF m.llOpened
USE IN FRX
ENDIF

THIS.ResetDataSession()
ENDIF

RETURN ( m.liGeneralFields &gt; 0 )



ENDPROC
PROCEDURE contattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.ContAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.ContAttr)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE copyimagefilestoexternalfilelocation_assign
LPARAMETERS m.vNewVal
IF NOT THIS.IsRunning and VARTYPE(m.vNewVal) = "L"
IF NOT (m.vNewVal = THIS.CopyImageFilesToExternalFileLocation)
THIS.CopyImageFilesToExternalFileLocation = m.vNewVal
THIS.adjustXSLTParameter(IIF(m.vNewVal,"1","0"),"copyImageFiles")
IF THIS.CopyImageFilesToExternalFileLocation
THIS.makeExternalFileLocationReachable()
ENDIF
ENDIF
ENDIF

ENDPROC
PROCEDURE datatextattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.dataTextAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.dataTextAttr)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE datatypeattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.dataTypeAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.dataTypeAttr )
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE Destroy
STORE NULL TO ;
THIS.JPGclsid, ;
THIS.FormattingChanges, ;
THIS.UtilityImage

DODEFAULT()


ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS m.nFRXRecno, m.oObjProperties
IF DODEFAULT(m.nFRXRecno,m.oObjProperties)
THIS.setFRXDataSession()
IF USED(THIS.formattingChanges) AND NOT(EOF(THIS.formattingChanges))
SELECT (THIS.formattingChanges)
WITH m.oObjProperties
IF .Reload
REPLACE Reload WITH .T., ;
FR WITH .FillRed, ;
FG WITH .FillGreen, ;
FB WITH .FillBlue, ;
FA WITH .FillAlpha, ;
PR WITH .PenRed, ;
PG WITH .PenGreen, ;
PB WITH .PenBlue, ;
PA WITH .PenAlpha, ;
FNAME WITH .FontName, ;
FSTYLE WITH .FontStyle, ;
FSIZE WITH .FontSize
ENDIF
ENDWITH
SELECT FRX
ENDIF
THIS.resetDataSession()
ENDIF

ENDPROC
PROCEDURE fillalphaattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
AND NOT (m.vNewVal == THIS.fillAlphaAttr)
THIS.fillAlphaAttr = m.vNewVal
THIS.SynchXSLTProcessorUser()
ENDIF





ENDPROC
PROCEDURE fillblueattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.fillBlueAttr)
THIS.fillBlueAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE fillgreenattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.fillGreenAttr)
THIS.fillGreenAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE fillredattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.fillRedAttr)
THIS.fillRedAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE fontnameattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.fontNameAttr)
THIS.fontNameAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE fontsizeattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.fontSizeAttr)
THIS.fontSizeAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE fontstyleattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.fontStyleAttr)
THIS.fontStyleAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE getrawformattinginfo
LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL m.lcInfo

THIS.adjustShapeAspectRatio (@tnWidth, @tnHeight)

m.lcInfo = DODEFAULT(m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType)
IF NOT EMPTY(THIS.ImageFieldtoFile)
m.lcInfo = m.lcInfo + " "+THIS.ImageSrcAttr+"='"+THIS.ImageFieldtoFile+"'"
ENDIF

THIS.setFRXDataSession()
IF USED(THIS.formattingChanges) AND ;
SEEK(RECNO("FRX"),THIS.formattingChanges,"FRXRecno")
SELECT (THIS.formattingChanges)
IF Reload
m.lcInfo = m.lcInfo + " "+THIS.penAlphaAttr+"='"+TRANSFORM(PA)+"'"
m.lcInfo = m.lcInfo + " "+THIS.penRedAttr+"='"+TRANSFORM(PR)+"'"
m.lcInfo = m.lcInfo + " "+THIS.penGreenAttr+"='"+TRANSFORM(PG)+"'"
m.lcInfo = m.lcInfo + " "+THIS.penBlueAttr+"='"+TRANSFORM(PB)+"'"
m.lcInfo = m.lcInfo + " "+THIS.fillAlphaAttr+"='"+TRANSFORM(FA)+"'"
m.lcInfo = m.lcInfo + " "+THIS.fillRedAttr+"='"+TRANSFORM(FR)+"'"
m.lcInfo = m.lcInfo + " "+THIS.fillGreenAttr+"='"+TRANSFORM(FG)+"'"
m.lcInfo = m.lcInfo + " "+THIS.fillBlueAttr+"='"+TRANSFORM(FB)+"'"
m.lcInfo = m.lcInfo + " "+THIS.fontNameAttr+"='"+TRANSFORM(FNAME)+"'"
m.lcInfo = m.lcInfo + " "+THIS.fontSizeAttr+"='"+TRANSFORM(FSIZE)+"'"
m.lcInfo = m.lcInfo + " "+THIS.fontStyleAttr+"='"+TRANSFORM(FSTYLE)+"'"
ENDIF
SELECT FRX
ENDIF

RETURN m.lcInfo
ENDPROC
PROCEDURE getvfprdlcontents
LPARAMETERS m.tcNodeName, m.tlAsString

IF VARTYPE(THIS.CommandClauses) = "O"

ADDPROPERTY(THIS.CommandClauses,;
"externalFileLocation", ;
THIS.externalFileLocation)

ADDPROPERTY(THIS.CommandClauses, ;
"copyImageFilesToExternalFileLocation", ;
THIS.copyImageFilesToExternalFileLocation)

ADDPROPERTY(THIS.CommandClauses, ;
"imageFileBaseName", ;
THIS.imageFileBaseName)
ENDIF

RETURN DODEFAULT(m.tcNodeName, m.tlAsString)
ENDPROC
PROCEDURE heightattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.HeightAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.HeightAttr)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE idattribute_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.IdAttribute
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.IdAttribute)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE idrefattribute_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.IdRefAttribute
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.IdRefAttribute)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE imagefilebasename_assign
LPARAMETERS m.vNewVal
THIS.ImageFileBaseName = ALLTR(CHRTRAN(JUSTSTEM(TRANSFORM(m.vNewVal)),;
OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_"))
ENDPROC
PROCEDURE imagesrcattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) AND ;
(NOT m.vNewVal == THIS.imageSrcAttr)
THIS.imageSrcAttr = m.vNewVal
THIS.SynchXSLTProcessorUser()
ENDIF

ENDPROC
PROCEDURE Init
IF DODEFAULT()
THIS.AppName = OUTPUTXMLDISPLAY_APPNAME_LOC
ELSE
RETURN .F.
ENDIF

RETURN NOT THIS.HadError
ENDPROC
PROCEDURE initializefilecopysettings
#define CLSID_JPG 	"{557CF401-1A04-11D3-9A73-0000F81EF32E}"


DECLARE INTEGER GdipSaveImageToFile in GDIPLUS.DLL  ;
integer image,string filename,string @ CLSID_clsidEncoder,integer encoderParams

LOCAL m.lcID

IF ISNULL(THIS.Jpgclsid) OR EMPTY(THIS.Jpgclsid)
DECLARE integer CLSIDFromString IN ole32 string,string @
m.lcID = SPACE(20)
CLSIDFromString(STRCONV(CLSID_JPG ,STRCONV_DBCS_UNICODE),@m.lcID)
THIS.Jpgclsid = m.lcID
m.lcID = ""
ENDIF

IF THIS.SendGDIPlusImage &lt; LISTENER_SEND_GDI_IMAGE_HANDLE
THIS.SendGDIPlusImage =   LISTENER_SEND_GDI_IMAGE_HANDLE
ENDIF

THIS.makeExternalFileLocationReachable()

ENDPROC
PROCEDURE initializeformattingchangescursor
DODEFAULT()
IF THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
IF USED(THIS.formattingChanges)
USE IN (THIS.formattingChanges) &amp;&amp; override, faster to re-create
CREATE CURSOR (THIS.FormattingChanges) ;
(FRXRecno i, ;
Reload l, ;
DText M, ;
DType c(1), ;
FA i, ;
FR i, ;
FG i, ;
FB i, ;
PA i, ;
PR i, ;
PG i, ;
PB i, ;
FName v(50), ;
FStyle i, ;
FSize i ;
)
ELSE
CREATE CURSOR (THIS.FormattingChanges) ;
(FRXRecno i, ;
Reload l, ;
FA i, ;
FR i, ;
FG i, ;
FB i, ;
PA i, ;
PR i, ;
PG i, ;
PB i, ;
FName v(50), ;
FStyle i, ;
FSize i ;
)
ENDIF

ENDIF

ENDPROC
PROCEDURE leftattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.LeftAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.LeftAttr)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE pageimageattr_assign
LPARAMETERS vNewVal
LOCAL m.lcVal
m.lcVal = THIS.pageImageAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.pageImageAttr)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE penalphaattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.penAlphaAttr)
THIS.penAlphaAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE penblueattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.penBlueAttr)
THIS.penBlueAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE pengreenattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.penGreenAttr)
THIS.penGreenAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE penredattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
AND NOT (m.vNewVal == THIS.penRedAttr)
THIS.penRedAttr = m.vNewVal
THIS.synchXsltProcessorUser()
ENDIF

ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecNo,m.nLeft,m.nTop,m.nWidth,m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage

LOCAL m.llCopyImage, m.lcFile, m.liDefaultBehavior

IF m.GDIPlusImage &gt; 0 AND ;
(ISNULL(THIS.Jpgclsid) OR EMPTY(THIS.Jpgclsid))
* we didn't have any general fields but we do have
* an image control, referenced as an expression,
* they have explicitly turned on SendGDIPlusImage, and
* this is the first time we're hitting an image control:
THIS.initializeFileCopySettings()
ENDIF

THIS.SetFRXDataSession()
GO m.nFRXRecNo IN FRX

IF THIS.CopyImageFilesToExternalFileLocation
IF (FRX.ObjType = FRX_OBJTYP_PICTURE) AND ;
FRX.Offset # FRX_PICTURE_SOURCE_GENERAL AND ;
FILE(m.cContentsToBeRendered)
* use FILE() function here,
* need to find if it is
* built into an app
m.llCopyImage = .T.
ENDIF
ENDIF

IF (FRX.ObjType = FRX_OBJTYP_PICTURE) AND ;
FRX.General = FRX_PICTUREMODE_SCALE_KEEP_SHAPE AND ;
FRX.Offset # FRX_PICTURE_SOURCE_GENERAL AND ;
FILE(m.cContentsToBeRendered)
* NB: doing this *only* when necessary for re-scaling.
* see above for why FILE() function -- this will work
* with the image object.
THIS.utilityImage = LOADPICTURE(m.cContentsToBeRendered)
ENDIF

THIS.SetCurrentDataSession()

DO CASE

CASE m.llCopyImage

m.lcFile = FORCEPATH(m.cContentsToBeRendered, ;
FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))

IF EMPTY(SYS(2000,m.lcFile))

* used to be:
* COPY FILE (cContentsToBeRendered) TO (lcFile)
* to handle files built into an app

STRTOFILE(FILETOSTR(m.cContentsToBeRendered),m.lcFile)

ENDIF

IF EMPTY(SYS(2000,m.lcFile))
THIS.ImageFieldToFile = ""
ELSE
THIS.ImageFieldToFile = JUSTFNAME(m.lcFile)
ENDIF

CASE THIS.SendGDIPlusImage &gt; LISTENER_SEND_GDI_IMAGE_NONE  AND ;
m.GDIPlusImage &gt; 0  AND ;
GdipSaveImageToFile(m.GDIPlusImage,;
STRCONV(FORCEPATH(THIS.ImageFileBaseName + "_"+ ;
TRANSFORM(THIS.ImageFieldInstance+1)+".jpg",;
FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))+CHR(0), ;
STRCONV_DBCS_UNICODE) ,THIS.JPGCLSID,0) = 0

THIS.ImageFieldInstance = THIS.ImageFieldInstance + 1

THIS.ImageFieldToFile = THIS.ImageFileBaseName +"_"+ ;
TRANSFORM(THIS.ImageFieldInstance)+".jpg"

OTHERWISE

THIS.ImageFieldToFile = ""

ENDCASE

m.liDefaultBehavior = DODEFAULT(m.nFRXRecNo, @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight, ;
@m.nObjectContinuationType, @m.cContentsToBeRendered, @m.GDIPlusImage)

THIS.ImageFieldToFile = ""
THIS.UtilityImage = NULL

THIS.resetDataSession()

RETURN m.liDefaultBehavior
ENDPROC
PROCEDURE resetdocument
THIS.ResetToDefault("ImageFieldInstance")
THIS.ResetToDefault("ImageFieldToFile")
THIS.ResetToDefault("UtilityImage")
DODEFAULT()


ENDPROC
PROCEDURE setdomformattinginfo
LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType

THIS.adjustShapeAspectRatio (@m.tnWidth, @m.tnHeight)

DODEFAULT( m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType)

IF NOT EMPTY(THIS.ImageFieldtoFile)
m.toNode.SetAttribute(THIS.ImageSrcAttr,THIS.ImageFieldtoFile )
ENDIF

THIS.setFRXDataSession()
IF USED(THIS.formattingChanges) AND ;
SEEK(RECNO("FRX"),THIS.formattingChanges,"FRXRecno")
SELECT (THIS.formattingChanges)
IF Reload
WITH m.toNode
.setAttribute(THIS.penAlphaAttr,PA)
.setAttribute(THIS.penRedAttr,PR)
.setAttribute(THIS.penGreenAttr,PG)
.setAttribute(THIS.penBlueAttr,PB)
.setAttribute(THIS.fillAlphaAttr,FA)
.setAttribute(THIS.fillRedAttr,FR)
.setAttribute(THIS.fillGreenAttr,FG)
.setAttribute(THIS.fillBlueAttr,FB)
.setAttribute(THIS.fontNameAttr,FNAME)
.setAttribute(THIS.fontSizeAttr,FSIZE)
.setAttribute(THIS.fontStyleAttr,FSTYLE)
ENDWITH
ENDIF
SELECT FRX
ENDIF

ENDPROC
PROCEDURE topattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.TopAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.TopAttr)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
PROCEDURE UnloadReport
DODEFAULT()
IF NOT (THIS.noPageEject OR ;
((TYPE("THIS.CommandClauses.NoPageEject") = "L") AND ;
THIS.CommandClauses.NoPageEject))
IF NOT ISNULL(THIS.OldExternalFileLocation)
* even if empty
THIS.ExternalFileLocation = THIS.OldExternalFileLocation
THIS.OldExternalFileLocation = NULL
ENDIF
IF NOT (THIS.OldSendGDIPlusImage = THIS.SendGDIPlusImage)
THIS.SendGDIPlusImage = THIS.OldSendGDIPlusImage
ENDIF
ENDIF
THIS.resetDataSession()


ENDPROC
PROCEDURE widthattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.WidthAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.WidthAttr)
THIS.SynchXSLTProcessorUser()
ENDIF
ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>jpgclsid Provides the GUID used when accessing GDI+ to request a file to be saved as JPG type.
oldsendgdiplusimage Saves the user's preference for GDIPlus image handle receipt if the Listener has to temporary change this setting to generate image files from non-filebased images.
oldexternalfilelocation Saves the user's old externalFileLocation information during a report run, if the Listener has to temporarily change it to generate  image files from non-filebased images.
imagefieldinstance Keeps count of image instances for use in generating unique filenames for disk versions of non-filebased images in the report.
imagefieldtofile Holds generated filename for image being rendered to disk from a non-filebased image.
imagesrcattr Supplies the name of the XML attribute used to show filename copied, or generated for non-filebased images, at runtime.
imagefilebasename Assigns an optional  prefix to be added to generated image file names when image files are saved to disk during the rendering of general fields in a report run
copyimagefilestoexternalfilelocation Indicates whether file-based images should be copied to a  common location from their original locations on your disk, for reference  as image sources in the XML output.
utilityimage Utility image object for handling aspect ratio of scale-and-retain filebased images.
fillalphaattr Supplies the name of the XML attribute used to show the Fill-Alpha  value provided to a field control layout object by EvaluateContents processing.
fillredattr Supplies the name of the XML attribute used to show the Fill-Red value provided to a field control layout object by EvaluateContents processing.
fillgreenattr Supplies the name of the XML attribute used to show the Fill-Green value provided to a field control layout object by EvaluateContents processing.
fillblueattr Supplies the name of the XML attribute used to show the Fill-Blue value provided to a field control layout object by EvaluateContents processing.
penalphaattr Supplies the name of the XML attribute used to show the Pen-Alpha value provided to a field control layout object by EvaluateContents processing.
penredattr Supplies the name of the XML attribute used to show the Pen-Red value provided to a field control layout object by EvaluateContents processing.
pengreenattr Supplies the name of the XML attribute used to show the Pen-Green value provided to a field control layout object by EvaluateContents processing.
penblueattr Supplies the name of the XML attribute used to show the Pen-Blue value provided to a field control layout object by EvaluateContents processing.
fontnameattr Supplies the name of the XML attribute used to show the Font-Name value provided to a field control layout object by EvaluateContents processing.
fontstyleattr Supplies the name of the XML attribute used to show the Font-Style value provided to a field control layout object by EvaluateContents processing.
fontsizeattr Supplies the name of the XML attribute used to show the Font-Size value provided to a field control layout object by EvaluateContents processing.
*checkreportforgeneralfields Performs startup chores necessary to save out copies of general fields on disk when a report is rendered.
*imagesrcattr_assign 
*imagefilebasename_assign 
*copyimagefilestoexternalfilelocation_assign 
*initializefilecopysettings Provides required environment settings for non-filebased images to be copied to files at runtime.
*adjustshapeaspectratio Adjust the height and width for the rendered contents of a Picture layout control to give accurate aspect ratio for the current file.
*fillalphaattr_assign 
*fillredattr_assign 
*fillgreenattr_assign 
*fillblueattr_assign 
*penalphaattr_assign 
*penredattr_assign 
*pengreenattr_assign 
*penblueattr_assign 
*fontnameattr_assign 
*fontstyleattr_assign 
*fontsizeattr_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Tunes XML settings suitably for presentation output needs, and adds image-file-publishing capabilities.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>xmldisplaylistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_14110GV5X</uniqueid>
		<timestamp>894986900</timestamp>
		<class>utilityreportlistener</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>reportlistener</baseclass>
		<objname>debuglistener</objname>
		<parent/>
		<properties>Height = 23
Width = 23
FRXDataSession = -1
includeloadandunload = .T.
targetalias = ("")
_memberdata =      461&lt;VFPData&gt;&lt;memberdata name="verbose" type="property" display="verbose" favorites="True" /&gt;&lt;memberdata name="dodebug" type="method" display="doDebug" favorites="True" /&gt;&lt;memberdata name="dodebugcommandclauses" type="method" display="doDebugCommandClauses" favorites="False" /&gt;&lt;memberdata name="targetalias" type="property" display="targetAlias" /&gt;&lt;memberdata name="includeloadandunload" type="property" display="includeLoadAndUnload" favorites="True" /&gt;&lt;/VFPData&gt;
Name = "debuglistener"
</properties>
		<protected>targetalias
dodebugcommandclauses
</protected>
		<methods>PROCEDURE AddProperty
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE AdjustObjectSize
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
DODEFAULT(m.p1, m.p2)
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE AfterBand
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT(m.p1, m.p2)
ENDPROC
PROCEDURE AfterReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

LOCAL m.lcProgram
m.lcProgram = PROGRAM()
THIS.DoDebug(m.lcProgram, PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " current CommandClauses")

IF NOT (THIS.IncludeLoadAndUnload OR THIS.CommandClauses.NoPageEject)
THIS.CloseTargetFile()
IF NOT THIS.QuietMode
MODI COMM (THIS.TargetFileName) NOWAIT
ENDIF
ENDIF

DODEFAULT()

ENDPROC
PROCEDURE BeforeBand
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT(m.p1, m.p2)
IF THIS.Verbose
THIS.TargetAlias = ""
IF m.p1 = FRX_OBJCOD_DETAIL
THIS.SetFRXDataSession()
GO m.p2 IN FRX
IF NOT EMPTY(FRX.Expr)
THIS.TargetAlias = UPPER(EVALUATE(FRX.Expr))
ENDIF
THIS.resetDataSession()
ENDIF
ENDIF
ENDPROC
PROCEDURE BeforeReport
LPARAMETERS m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

LOCAL m.lcProgram
m.lcProgram = PROGRAM()

DODEFAULT()

IF THIS.Verbose

THIS.setCurrentDataSession()

ENDIF


IF THIS.TargetHandle = -1
THIS.OpenTargetFile()
ENDIF

THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " received CommandClauses")


IF THIS.verbose
THIS.resetDataSession()
ENDIF


ENDPROC
PROCEDURE CancelReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT()

ENDPROC
PROCEDURE ClearStatus
LPARAMETERS m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT()

ENDPROC
PROCEDURE dodebug
LPARAMETERS m.p0, m.pcount, m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

IF THIS.TargetHandle &gt; 0

LOCAL m.liIndex, m.loObj, m.lvParam, m.liObjIndex, m.liMembers, laMembers[1]

FWRITE( THIS.TargetHandle, m.p0 )

FOR m.liIndex = 1 TO m.pcount

m.lvParam = EVAL("p"+TRANS(liIndex))

IF THIS.Verbose AND VARTYPE(m.lvParam) = "O"

m.liMembers = AMEMBERS(laMembers, m.lvParam) &amp;&amp; ,0,"G"

FOR m.liIndex = 1 TO m.liMembers

IF TYPE("lvParam."+laMembers[m.liIndex]) # "U"
FWRITE(THIS.TargetHandle, ;
",Obj."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("lvParam."+laMembers[m.liIndex])) )
ENDIF

ENDFOR

ELSE

FWRITE(THIS.TargetHandle, ","+TRANSF(m.lvParam))

ENDIF

ENDFOR

FPUTS(THIS.TargetHandle, "")

IF THIS.Verbose
THIS.setCurrentDataSession()

FWRITE(THIS.TargetHandle, ;
"Listener.PageNo=" + IIF(THIS.sharedPageNo=0,;
TRANSFORM(THIS.PageNo),  ;
TRANSFORM(THIS.sharedPageNo))+ ", " + ;
"_PAGENO="+TRANSFORM(_PAGENO))

IF (NOT EMPTY(THIS.DrivingAlias)) AND USED(THIS.DrivingAlias)
FWRITE(THIS.TargetHandle, ", " + THIS.DrivingAlias + " recno=" + TRANSFORM(RECNO(THIS.Drivingalias)))
ENDIF

IF NOT EMPTY(THIS.TargetAlias)

FWRITE(THIS.TargetHandle, ", TargetAlias=" + THIS.TargetAlias + ", targetRecno=" + TRANSFORM(RECNO(THIS.TargetAlias)))

ENDIF

FPUTS(THIS.TargetHandle, "")
THIS.resetDataSession()
ENDIF

FFLUSH(THIS.targetHandle)

ENDIF




ENDPROC
PROCEDURE dodebugcommandclauses
LPARAMETERS m.tvCommand, m.tcHeader

IF VARTYPE(m.tvCommand) = "O" AND THIS.TargetHandle &gt; 0
LOCAL m.liIndex, laMembers[1], m.liMembers

FPUTS( THIS.TargetHandle, REPL("-",30) )
FPUTS( THIS.TargetHandle, "MEMBERS:" )
m.liMembers = AMEMBERS(laMembers, THIS) &amp;&amp; ,0,"G"

FOR m.liIndex = 1 TO m.liMembers

IF TYPE("THIS."+laMembers[m.liIndex]) # "U"

FPUTS(THIS.TargetHandle, "."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("THIS."+laMembers[m.liIndex])) )
ENDIF

ENDFOR

FPUTS( THIS.TargetHandle, REPL("-",30) )
FPUTS( THIS.TargetHandle, tcHeader )

m.liMembers = AMEMBERS(laMembers, m.tvCommand)
IF m.liMembers = 0
FPUTS(THIS.TargetHandle, "... NO MEMBERS")
ELSE

FOR m.liIndex = 1 TO m.liMembers

FPUTS(THIS.TargetHandle, "."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("tvCommand."+laMembers[m.liIndex])) )

ENDFOR

ENDIF
FPUTS( THIS.TargetHandle, REPL("-",30) )
FFLUSH(THIS.targetHandle)

ENDIF
ENDPROC
PROCEDURE DoStatus
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT(m.p1)

ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
DODEFAULT(m.p1, m.p2)
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE IncludePageInOutput
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
RETURN DODEFAULT(m.p1)

ENDPROC
PROCEDURE Init
IF DODEFAULT()
THIS.AppName = OUTPUTCLASS_APPNAME_LOC
RETURN NOT THIS.hadError
ELSE
RETURN .F.
ENDIF


ENDPROC
PROCEDURE LoadReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

DODEFAULT()

IF THIS.IncludeLoadandUnload

IF THIS.TargetHandle = -1
THIS.OpenTargetFile()
ENDIF

THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
THIS.DoDebugCommandClauses(THIS.CommandClauses,PROGRAM()+ " received CommandClauses")

ENDIF

ENDPROC
PROCEDURE OnPreviewClose
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE opentargetfile
IF WEXIST(JUSTSTEM(THIS.targetFileName))
* because of the MODI FILE NOWAIT,
* generate a new filename:
THIS.targetFileName = SYS(2015)
ENDIF
DODEFAULT()
ENDPROC
PROCEDURE OutputPage
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)


ENDPROC
PROCEDURE ReadExpression
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE ReadMethod
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE Render
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
IF DODEFAULT( m.p1, @m.p2, @m.p3, @m.p4, @m.p5, @m.p6, @m.p7,@m.p8) #  OUTPUTFX_BASERENDER_NORENDER
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
ENDIF

ENDPROC
PROCEDURE ResetToDefault
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE SaveAsClass
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE SupportsListenerType
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE UnloadReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

IF THIS.includeLoadAndUnload
LOCAL lcProgram
lcProgram = PROGRAM()
THIS.DoDebug(lcProgram, PCOUNT(),;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " current CommandClauses")
ENDIF

IF THIS.TargetHandle &gt; 0 AND (NOT THIS.CommandClauses.NoPageEject)
THIS.CloseTargetFile()
IF NOT THIS.QuietMode
MODI FILE (THIS.Targetfilename) NOWAIT
ENDIF
ENDIF

DODEFAULT()

ENDPROC
PROCEDURE UpdateStatus
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT()

ENDPROC
PROCEDURE verbose_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.Verbose = m.vNewVal
ENDIF

ENDPROC
PROCEDURE WriteExpression
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE WriteMethod
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>includeloadandunload Indicates whether the debug information should include values from the LoadReport and UnloadReport events.
verbose Specifies whether the DebugListener should include extended information about parameter values of object type, as well as page, alias, and recno() information for each event or method.
targetalias Holds the target alias during the processing of a detail band.
*dodebug Provides debug information for a ReportListener event or method.
*dodebugcommandclauses Provides debug information for the CommandClauses object and ReportListener member properties.
*verbose_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides debugging output to help developers understand what happens during an object-assisted report run.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>debuglistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_13E0OB2YR</uniqueid>
		<timestamp>914842098</timestamp>
		<class>utilityreportlistener</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>reportlistener</baseclass>
		<objname>xmllistener</objname>
		<parent/>
		<properties>Height = 23
Width = 23
FRXDataSession = -1
xmlmode = 2
includebreaksindata = 0
pagenodes = (NULL)
currentband = (NULL)
currentdocument = (NULL)
currentpage = (NULL)
columnnodes = (NULL)
currentcolumn = (NULL)
idattribute = ("id")
idrefattribute = ("idref")
xsltprocessorrdl = (NULL)
xsltprocessoruser = (NULL)
datanodes = (NULL)
nopageeject = .F.
topattr = ("t")
leftattr = ("l")
heightattr = ("h")
widthattr = ("w")
contattr = ("c")
xsltparameters = (NULL)
includepage = .T.
includedatatypeattributes = .F.
datatypeattr = ("DTYPE")
datatextattr = ("DTEXT")
formattingchanges = (.NULL.)
evaluatecontentsvalues = (.NULL.)
pageimageattr = ("PLINK")
applyrdltransform = .F.
successorgfxnorender = (.NULL.)
targetfileext = ("XML")
_memberdata =     5491&lt;VFPData&gt;&lt;memberdata name="applyusertransform" type="property" display="applyUserTransform" favorites="True"/&gt;&lt;memberdata name="applyusertransformtooutput" type="method" display="applyUserTransformToOutput"/&gt;&lt;memberdata name="applyxslt" type="method" display="applyXslt" favorites="True"/&gt;&lt;memberdata name="columnnodes" type="property" display="columnNodes"/&gt;&lt;memberdata name="contattr" type="property" display="contAttr" favorites="True"/&gt;&lt;memberdata name="currentband" type="property" display="currentBand"/&gt;&lt;memberdata name="currentcolumn" type="property" display="currentColumn"/&gt;&lt;memberdata name="includepage" type="property" display="includePage"/&gt;&lt;memberdata name="currentdocument" type="property" display="currentDocument" favorites="True"/&gt;&lt;memberdata name="currentpage" type="property" display="currentPage"/&gt;&lt;memberdata name="datanodes" type="property" display="dataNodes"/&gt;&lt;memberdata name="getdefaultuserxslt" type="method" display="getDefaultUserXslt"/&gt;&lt;memberdata name="preparefrxcopy" type="method" display="prepareFrxCopy"/&gt;&lt;memberdata name="removefrxcopy" type="method" display="removeFrxCopy"/&gt;&lt;memberdata name="getpathedimageinfo" type="method" display="getPathedImageInfo"/&gt;&lt;memberdata name="getrawformattinginfo" type="method" display="getRawFormattingInfo"/&gt;&lt;memberdata name="getvfprdlcontents" type="method" display="getVFPRdlContents"/&gt;&lt;memberdata name="getfrxlayoutobjectfieldlist" type="method" display="getFrxLayoutObjectFieldlist"/&gt;&lt;memberdata name="heightattr" type="property" display="heightAttr" favorites="True"/&gt;&lt;memberdata name="idattribute" type="property" display="idAttribute" favorites="True"/&gt;&lt;memberdata name="idrefattribute" type="property" display="idrefAttribute" favorites="True"/&gt;&lt;memberdata name="includebandswithnoobjects" type="property" display="includeBandsWithNoObjects" favorites="True"/&gt;&lt;memberdata name="includebreaksindata" type="property" display="includeBreaksInData" favorites="True"/&gt;&lt;memberdata name="includedatasourcesinvfprdl" type="property" display="includeDataSourcesInVfpRdl" favorites="True"/&gt;&lt;memberdata name="includeformattinginlayoutobjects" type="property" display="includeFormattingInLayoutObjects" favorites="True"/&gt;&lt;memberdata name="insertxmlconfigrecords" type="method" display="insertXmlConfigRecords"/&gt;&lt;memberdata name="leftattr" type="property" display="leftAttr" favorites="True"/&gt;&lt;memberdata name="loadprocessorobject" type="method" display="loadProcessorObject"/&gt;&lt;memberdata name="nopageeject" type="property" display="noPageEject" favorites="True"/&gt;&lt;memberdata name="pagenodes" type="property" display="pageNodes"/&gt;&lt;memberdata name="resetdocument" type="method" display="resetDocument" favorites="True"/&gt;&lt;memberdata name="resetreport" display="resetReport" type="method"/&gt;&lt;memberdata name="setdomformattinginfo" type="method" display="setDOMFormattingInfo"/&gt;&lt;memberdata name="setfrxdatasession" type="method" display="setFRXDataSession"/&gt;&lt;memberdata name="synchxsltprocessoruser" type="method" display="synchXsltProcessorUser"/&gt;&lt;memberdata name="topattr" type="property" display="topAttr" favorites="True"/&gt;&lt;memberdata name="verifyattributenames" type="method" display="verifyAttributeNames"/&gt;&lt;memberdata name="verifyncname" type="method" display="verifyNCName" favorites="True"/&gt;&lt;memberdata name="verifynodenames" type="method" display="verifyNodeNames"/&gt;&lt;memberdata name="widthattr" type="property" display="widthAttr" favorites="True"/&gt;&lt;memberdata name="writeraw" type="method" display="writeRaw"/&gt;&lt;memberdata name="xmlmode" type="property" display="xmlMode" favorites="True"/&gt;&lt;memberdata name="xmlrawconv" type="method" display="xmlRawConv"/&gt;&lt;memberdata name="xmlrawnode" type="method" display="xmlRawNode"/&gt;&lt;memberdata name="xmlrawtag" type="method" display="xmlRawTag"/&gt;&lt;memberdata name="xsltparameters" type="property" display="xsltParameters" favorites="True"/&gt;&lt;memberdata name="xsltprocessorrdl" type="property" display="xsltProcessorRdl" favorites="True"/&gt;&lt;memberdata name="xsltprocessoruser" type="property" display="xsltProcessorUser" favorites="True"/&gt;
&lt;memberdata name="adjustxsltparameter" type="method" display="adjustXSLTParameter" favorites="True"/&gt;
&lt;memberdata name="getrunnodecontents" display="getRunNodeContents" type="method"/&gt;&lt;memberdata name="addrunnode" display="addRunNode" type="method"/&gt;&lt;memberdata name="includedatatypeattributes" display="includeDataTypeAttributes" type="property" favorites="True"/&gt;&lt;memberdata name="datatypeattr" type="property" display="dataTypeAttr" favorites="True"/&gt;&lt;memberdata name="datatextattr" type="property" display="dataTextAttr" favorites="True"/&gt;&lt;memberdata 
name="formattingchanges" type="property" display="formattingChanges" /&gt; &lt;memberdata name="initializeformattingchangescursor" type="method" display="initializeFormattingChangesCursor"/&gt;&lt;memberdata name="evaluatecontentsvalues" display="evaluateContentsValues" type="property"/&gt;&lt;memberdata name="formatdatavalue" display="formatDataValue" type="method"/&gt;&lt;memberdata name="pageimageattr" type="property" display="pageImageAttr" favorites="True"/&gt;
&lt;memberdata name="evaluatestringtoboolean" display="evaluateStringToBoolean" type="property"/&gt;&lt;memberdata name="applyrdltransform" display="applyRDLTransform" type="property"/&gt;
&lt;memberdata name="successorgfxnorender" display="successorGFXNoRender" type="property"/&gt;&lt;memberdata name="fixmsxmlobjectfordtds" display="fixMSXMLObjectForDTDs" type="method"/&gt;&lt;memberdata name="frxcharsetsinuse" display="frxCharsetsInUse" type="method"/&gt;
&lt;/VFPData&gt;
runcollectorresetlevel = 1
Name = "xmllistener"
</properties>
		<protected>pagenodes
currentband
currentpage
columnnodes
currentcolumn
datanodes
includepage
evaluatecontentsvalues
applyrdltransform
successorgfxnorender
xmlrawtag
xmlrawnode
xmlrawconv
writeraw
resetreport
verifynodenames
verifyattributenames
loadprocessorobject
getrawformattinginfo
getvfprdlcontents
getpathedimageinfo
applyusertransformtooutput
getdefaultuserxslt
setdomformattinginfo
synchxsltprocessoruser
insertxmlconfigrecords
getfrxlayoutobjectfieldlist
preparefrxcopy
removefrxcopy
getrunnodecontents
addrunnode
initializeformattingchangescursor
formatdatavalue
evaluatestringtoboolean
fixmsxmlobjectfordtds
frxcharsetsinuse
verifytargetfile
</protected>
		<methods>PROCEDURE addrunnode
LPARAMETERS m.oXML, m.tvValueExpr, m.tcPropertyName

LOCAL m.oNode, m.vValue
m.oNode = m.oXML.createElement("property")
m.oNode.setAttribute("id",m.tcPropertyName)
m.vValue = THIS.evaluateUserExpression(m.tvValueExpr)
IF TYPE("m.vValue.XML") = "C" &amp;&amp; xmlnode
m.oNode.appendChild(m.vValue)
ELSE
m.oNode.Text = TRANSFORM(m.vValue)
ENDIF
m.vValue = NULL
m.oXML.DocumentElement.appendChild(m.oNode)
m.oNode = NULL


ENDPROC
PROCEDURE adjustxsltparameter
LPARAMETERS m.tvValue, m.tsKey, m.tlRemoveOnly

LOCAL m.liIndex, m.liSession

IF ISNULL(THIS.XSLTParameters) AND NOT m.tlRemoveOnly
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
THIS.XSLTParameters = CREATEOBJECT("Collection")
SET DATASESSION TO (m.liSession)
ENDIF

IF NOT ISNULL(THIS.XSLTParameters)
WITH THIS.XSLTParameters
FOR m.liIndex = 1 TO .COUNT
IF .GETKEY(m.liIndex) == m.tsKey
.REMOVE(m.liIndex)
EXIT
ENDIF
NEXT
IF NOT (m.tlRemoveOnly)
.ADD(m.tvValue,m.tsKey)
ENDIF
ENDWITH
ENDIF

ENDPROC
PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo

DODEFAULT(m.nBandObjCode, m.nFRXRecNo)


IF THIS.InvokeOnCurrentPass() AND ;
THIS.Targethandle &gt; -1

LOCAL m.lcBand, m.loNode, m.lcID, m.lcIDRef, ;
m.llFormatBreakBand, m.loObjects, m.llOmitBand


THIS.SetFRXDataSession()
m.lcBand =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+FRX_OBJTYP_BAND+ ;
OUTPUTXML_OBJTYPE_BANDOFFSET+nBandObjCode,;
"Nodes","FrxNodes"),;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)

GO m.nFRXRecNo IN FRX
IF NOT THIS.IncludeBandsWithNoObjects
m.loObjects = THIS.FRXCursor.GetObjectsInBand(FRX.UniqueID,.F.,THIS.FRXDataSession)
IF loObjects.Count = 0
m.llOmitBand = .T.
ENDIF
m.loObjects = NULL
ENDIF

THIS.SetCurrentDataSession()

m.llFormatBreakBand = INLIST(m.nBandObjCode,;
FRX_OBJCOD_PAGEHEADER, ;
FRX_OBJCOD_PAGEFOOTER, ;
FRX_OBJCOD_COLHEADER, ;
FRX_OBJCOD_COLFOOTER)

* first evaluate THIS.IncludeBreaksInData
DO CASE
CASE m.llOmitBand = .T.
* nothing
CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_INDATA OR ;
NOT m.llFormatBreakBand

#IF OUTPUTXML = OUTPUTXML_RAW

IF EMPTY(NVL(THIS.CurrentBand,""))
* see continuation discussion in Render.
* our fix there may have left us with
* no band here
* do nothing
ELSE

THIS.CurrentBand = NVL(THIS.CurrentBand,"") + ;
THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef )

IF NOT (ISNULL(THIS.CurrentBand) OR EMPTY(THIS.CurrentBand))
THIS.WriteRaw(THIS.CurrentBand)
THIS.CurrentBand = ""
ENDIF

ENDIF

#ELIF OUTPUTXML = OUTPUTXML_DOTNET

#ELSE
* nothing to do here when using the DOM
THIS.CurrentBand = NULL
#ENDIF

CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
* build the collection which will be inserted into the
* data before finishing.
* but the band output at this point is .F.
#IF OUTPUTXML = OUTPUTXML_RAW
IF INLIST( m.nBandObjCode, ;
FRX_OBJCOD_PAGEHEADER, ;
FRX_OBJCOD_PAGEFOOTER)
THIS.CurrentPage = NVL(THIS.CurrentPage,"")
THIS.CurrentPage = THIS.CurrentPage +  ;
THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef )
THIS.PageNodes = THIS.PageNodes + THIS.CurrentPage
THIS.CurrentPage = NULL
ELSE
THIS.CurrentColumn = NVL(THIS.CurrentColumn,"")
THIS.CurrentColumn = THIS.CurrentColumn + ;
THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef )
THIS.ColumnNodes = THIS.ColumnNodes + THIS.CurrentColumn
THIS.CurrentColumn = NULL
ENDIF

#ELIF OUTPUTXML = OUTPUTXML_DOTNET

#ELSE

* we leave THIS.CurrentBand alone in this case,
* to use after the band has finished.
IF INLIST( nBandObjCode, ;
FRX_OBJCOD_PAGEHEADER, ;
FRX_OBJCOD_PAGEFOOTER)
THIS.CurrentPage = NULL
ELSE
THIS.CurrentColumn = NULL
ENDIF

#ENDIF
CASE INLIST( m.nBandObjCode, ;
FRX_OBJCOD_COLHEADER, ;
FRX_OBJCOD_COLFOOTER)   &amp;&amp; XMLBREAKS_NONE and column band

THIS.CurrentColumn = NULL
OTHERWISE  &amp;&amp; XMLBREAKS_NONE and page band

THIS.CurrentPage = NULL

ENDCASE

THIS.resetDataSession()

ENDIF


IF INLIST(m.nBandObjCode,FRX_OBJCOD_PAGEFOOTER, FRX_OBJCOD_TITLE)
THIS.includePage = .F.
ENDIF

ENDPROC
PROCEDURE AfterReport
LPARAMETERS tlCalledEarly

THIS.SetFRXDataSession()

IF THIS.TargetHandle &gt; -1 AND NOT (THIS.HadError )

THIS.fillRunCollector()

#IF OUTPUTXML = OUTPUTXML_RAW

LOCAL m.lcNode
IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY

IF  NOT EMPTY(NVL(THIS.CurrentBand,""))
m.lcNode = SUBSTR(THIS.CurrentBand,2,AT(" ", THIS.CurrentBand)-2)
THIS.CurrentBand = THIS.CurrentBand + THIS.XMLRawTag(m.lcNode)
* write a closing tag
THIS.WriteRaw(THIS.CurrentBand)
ENDIF

IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
IF NOT ISNULL(THIS.PageNodes)
lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_PAGES,;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
THIS.WriteRaw(THIS.PageNodes)
THIS.WriteRaw(THIS.XMLRawTag(m.lcNode))
ENDIF
IF NOT ISNULL(THIS.ColumnNodes)
m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_COLS,;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
THIS.WriteRaw(THIS.ColumnNodes)
THIS.WriteRaw(THIS.XMLRawTag(m.lcNode))
ENDIF
ENDIF

m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_DATA,;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)

THIS.WriteRaw( THIS.XMLRawTag(m.lcNode))
ENDIF

m.lcNode = THIS.getRunNodeContents(.T.)

IF NOT (ISNULL(lcNode) OR EMPTY(lcNode))
THIS.WriteRaw(lcNode)
ENDIF

m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
"Nodes","ObjType"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
THIS.WriteRaw( THIS.XMLRawTag(m.lcNode))

* check to see if continuation...
IF NOT OUTPUTXML_CONTINUATION
THIS.WriteRaw( THIS.XMLRawTag(THIS.CurrentDocument))
ENDIF

#ELIF OUTPUTXML = OUTPUTXML_DOTNET
* XMLTextWriter work
#ELSE
LOCAL m.loNode
* domwork here
IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
* currently all this is done on entry, but
* if not:
* append the pages collection
* into the report data node --
* that's where we should be right now
* THIS.DataNodes.AppendChild(THIS.PageNodes)
** IF NOT ISNULL(THIS.ColumnNodes)
* THIS.DataNodes.AppendChild(THIS.ColumnNodes)
** ENDIF
ENDIF

m.loNode = THIS.getRunNodeContents()

IF NOT ISNULL(m.loNode)
THIS.DataNodes.ParentNode.AppendChild(m.loNode)
ENDIF

IF NOT OUTPUTXML_CONTINUATION
THIS.CurrentDocument.Save(THIS.TargetFileName)
ENDIF

m.loNode = NULL

#ENDIF

ENDIF

IF OUTPUTXML_CONTINUATION
IF THIS.runCollectorResetLevel = OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT
THIS.resetRunCollector()
ENDIF
THIS.ResetReport()
ELSE
IF THIS.runCollectorResetLevel &gt; OUTPUTFX_RUNCOLLECTOR_RESET_NEVER
THIS.resetRunCollector()
ENDIF
THIS.ResetDocument()
IF (NOT tlCalledEarly) AND ;
(THIS.applyUserTransform OR ;
THIS.applyRDLTransform)
THIS.ApplyUserTransformToOutput()
IF (NOT THIS.HadError)
* we suppressed this message earlier when closing the target file,
* which is just an intermediary format in this case:
IF THIS.DoMessage( OUTPUTCLASS_SUCCESS_LOC + ;
IIF(SYS(2024)="Y",CHR(13)+OUTPUTCLASS_REPORT_INCOMPLETE_LOC,""),;
MB_ICONINFORMATION + MB_YESNO ) = IDYES
_CLIPTEXT = THIS.TargetFileName
ENDIF
ENDIF
ENDIF
ENDIF

THIS.resetDataSession()

IF (NOT tlCalledEarly)
DODEFAULT()
ENDIF


ENDPROC
PROCEDURE applyrdltransform_access
RETURN (THIS.XMLMode = OUTPUTXML_RDL_ONLY AND ;
(NOT ISNULL(THIS.xsltProcessorRdl )))

ENDPROC
PROCEDURE applyusertransform_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
THIS.applyUserTransform = m.vNewVal
IF THIS.applyUserTransform AND ;
(ISNULL(THIS.XSLTProcessorUser))
THIS.GetDefaultUserXSLT()
ENDIF
ENDIF

ENDPROC
PROCEDURE applyusertransformtooutput
DO CASE
CASE (THIS.applyUserTransform AND NOT ;
(ISNULL(THIS.XSLTProcessorUser))) OR ;
THIS.applyRDLTransform

LOCAL m.lvProcessor

* THIS.SaveTargetFileName is real
* THIS.TargetFileName is TMP
IF THIS.xmlMode = OUTPUTXML_RDL_ONLY
m.lvProcessor = THIS.XSLTProcessorRDL
ELSE
m.lvProcessor = THIS.XSLTProcessorUser
ENDIF
IF NOT EMPTY(SYS(2000,THIS.SaveTargetFileName))
ERASE (THIS.SaveTargetFileName) NORECYCLE
ENDIF
*&amp;* Sedna change to ensure better encoding behavior
*&amp;* See notes in .ApplyXSLT method
STRTOFILE(THIS.ApplyXSLT(THIS.TargetFileName,m.lvProcessor, THIS.XSLTParameters), ;
THIS.SaveTargetFileName)
ERASE (THIS.TargetFileName) NORECYCLE
THIS.TargetFileName = THIS.SaveTargetFileName
RETURN .T.
CASE THIS.applyUserTransform &amp;&amp; no processor but public property is still set
IF NOT EMPTY(SYS(2000,THIS.SaveTargetFileName))
ERASE (THIS.SaveTargetFileName) NORECYCLE
ENDIF
COPY FILE (THIS.TargetFileName) TO (THIS.SaveTargetFileName)
ERASE (THIS.TargetFileName) NORECYCLE
THIS.TargetFileName = THIS.SaveTargetFileName
RETURN .F.
OTHERWISE
RETURN .F.
ENDCASE



ENDPROC
PROCEDURE applyxslt
LPARAMETERS m.tvSource, m.tvProcessor, m.tvParamCollection, m.tvFRXAlias

LOCAL m.loSource, m.loProcessor, m.lcReturn, m.llSuccess, m.liParam, m.liSession, m.llCharsetsInUse

m.lcReturn = ""

STORE NULL TO m.loSource, m.loProcessor

IF VARTYPE(m.tvSource) = "C"

* first param can be filename, string, or object
* if filename or string, test existance
* and try to load as a dom object
*   m.liSession = SET("DATASESSION")
*   THIS.resetDataSession()
m.llCharsetsInUse = THIS.frxCharsetsInUse(m.tvFRXAlias)
m.loSource = CREATEOBJECT(OUTPUTXML_DOMDOCUMENTOBJECT)
THIS.fixMSXMLObjectForDTDs(m.loSource)
DO CASE
CASE FILE(m.tvSource) AND NOT m.llCharsetsInUse
m.loSource.Load(m.tvSource)
CASE FILE(m.tvSource)
*&amp;* m.loSource.Load(m.tvSource)
*&amp;* would introduce problems with the (multi) charset-handling
*&amp;* in FRX by engine
*&amp;* see notes below
m.loSource.LoadXML(FILETOSTR(m.tvSource))
OTHERWISE
m.loSource.LoadXML(m.tvSource)
ENDCASE
*   SET DATASESSION TO (m.liSession)

IF NOT ISNULL(m.loSource) AND ;
LEN(m.loSource.XML) &gt; 0 AND ;
EMPTY(m.loSource.parseError.reason)
m.llSuccess = .T.
ELSE
m.loSource = NULL
*      IF NOT ISNULL(m.loSource)
*         THIS.LastErrorMessage = loSource.parseError.reason
*      ENDIF
ENDIF
ELSE
* if object, test nodetypestring availability
* and then for document/tree shape.
IF VARTYPE(m.tvSource) = "O"
TRY
IF INLIST("|"+UPPER(m.tvSource.nodeTypeString)+"|", ;
"|DOCUMENT|","|ELEMENT|") &amp;&amp; quick and dirty test for tree shape
m.loSource = m.tvSource
m.llSuccess = .T.
ENDIF
ENDTRY
ENDIF

ENDIF

IF m.llSuccess

* for failed transformations, return source XML
m.lcReturn = m.loSource.XML

* as above
* second param can be filename or object

* if filename, as above
*  if object, test for appropriate interface
* figure out if it's a processor factory
* or an instance (either dom or stylesheet)
*  and error out if we can't figure it out
m.llSuccess = .F.
IF VARTYPE(m.tvProcessor) = "C"
m.loProcessor = THIS.LoadProcessorObject(m.tvProcessor)
IF NOT ISNULL(m.loProcessor)
m.loProcessor = m.loProcessor.createProcessor()
ENDIF
ELSE
IF VARTYPE(m.tvProcessor) = "O"
TRY
IF VARTYPE(m.tvProcessor.styleSheet) = "O"
m.loProcessor = m.tvProcessor
* if the object was a processor object
* get a stylesheet instance
m.loProcessor = m.loProcessor.createProcessor()
ENDIF
CATCH
* just want to swallow the errors here because
* of the primitive tests being used
ENDTRY
ENDIF
ENDIF

IF NOT ISNULL(m.loProcessor)
m.llSuccess = .T.
ENDIF
ENDIF

IF m.llSuccess


WITH m.loProcessor
IF VARTYPE(m.tvParamCollection) = "O" AND ;
UPPER(m.tvParamCollection.BaseClass) == "COLLECTION" AND ;
m.tvParamCollection.Count &gt; 0

FOR m.liParam = 1 TO m.tvParamCollection.Count
.AddParameter(m.tvParamCollection.GetKey(m.liParam), ;
m.tvParamCollection.Item(m.liParam))
ENDFOR
ENDIF
* always override for current external file location info, if we have one:
IF NOT EMPTY(THIS.externalFileLocation)
.AddParameter("externalFileLocation", THIS.externalFileLocation)
ENDIF
.input = m.loSource
.transform()
m.lcReturn = .output
ENDWITH

ENDIF

STORE NULL TO m.loSource, m.loProcessor

*&amp;* Sedna change to
*&amp;* ensure UTF-8 File contents per documented
*&amp;* behavior of this class.  xsl:output encoding is ignored
*&amp;* by the msxml processor transform anyway when outputting
*&amp;* to a string (see http://msdn2.microsoft.com/en-us/library/ms753765.aspx)
*&amp;* and as a result we are outputting a file with no encoding
*&amp;* specified after the transform.  So we should ensure that it
*&amp;* is in the default XML encoding when none is specified,
*&amp;* which is UTF-8. But Fox has changed the UTF-16 return value
*&amp;* from the MSXML processor objects to DBCS.  We need to fix
*&amp;* that at the time we send to disk for other applications to
*&amp;* read, can't do it before this point.  We can't do it
*&amp;* in cases where the user has marked explicit fontcharsets in
*&amp;* the FRX, since this information is passed along in VFP-RDL XML
*&amp;* and could be treated differently by different output mechanisms/XSLT.
*&amp;* We will preserve original behavior in that case.

IF m.llCharsetsInUse
RETURN m.lcReturn
ELSE
RETURN (STRCONV(m.lcReturn,STRCONV_DBCS_UTF8))
ENDIF
ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo, m.tlContinuedBand

DODEFAULT(m.nBandObjCode, m.nFRXRecNo)

IF INLIST(m.nBandObjCode,FRX_OBJCOD_PAGEHEADER, FRX_OBJCOD_TITLE,FRX_OBJCOD_SUMMARY)
THIS.includePage =  THIS.IncludePageInOutput(_PAGENO)
*(THIS.PageNo &gt;= THIS.CommandClauses.RangeFrom) AND ;
*    ((THIS.CommandClauses.RangeTo = -1) OR (THIS.PageNo &lt;= THIS.CommandClauses.RangeTo))
* possibly to be adapted later:
* regardless of whether IncludePageInOutput() is used
* or the manual evaluation above (commented) is used,
* _PAGENO will work for continued reports only if NORESET is not used.
* THIS.PageNo/THIS.SharedPageNo will not work whether NORESET is used or not,
* for continued reports,
* unless you maintain a private offset.  RANGE is
* sensitive to the current REPORT FORM command, not the full
* NOPAGEEJECT (chained) run

ENDIF


IF THIS.InvokeOnCurrentPass() AND ;
THIS.Targethandle &gt; -1

LOCAL m.lcBand, m.loNode, m.lcID, m.lcIDRef, ;
m.llFormatBreakBand, m.lcInterruptedBand,;
m.llOmitBand, m.loObjects

THIS.SetFRXDataSession()

GO m.nFRXRecNo IN FRX

IF NOT THIS.IncludeBandsWithNoObjects
m.loObjects = THIS.FRXCursor.GetObjectsInBand(FRX.UniqueID,.F.,THIS.FRXDataSession)
IF m.loObjects.Count = 0
m.llOmitBand = .T.
ENDIF
m.loObjects = NULL
ENDIF

m.lcBand =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND+ ;
OUTPUTXML_OBJTYPE_BANDOFFSET+nBandObjCode,;
"Nodes","FrxNodes"),;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
THIS.SetCurrentDataSession()

m.llFormatBreakBand = INLIST(nBandObjCode,;
FRX_OBJCOD_PAGEHEADER, ;
FRX_OBJCOD_PAGEFOOTER, ;
FRX_OBJCOD_COLHEADER, ;
FRX_OBJCOD_COLFOOTER)


IF m.llFormatBreakBand

m.lcIDRef =  TRANSFORM(m.nFRXRecNo) &amp;&amp; TRANSFORM(IIF(EMPTY(FRX.UniqueID),"",FRX.UniqueID))
m.lcID = TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo))

ELSE

m.lcID =  TRANSFORM(m.nFRXRecNo) &amp;&amp; TRANSFORM(IIF(EMPTY(FRX.UniqueID),"",FRX.UniqueID) )
IF m.tlContinuedBand
m.lcID = m.lcID + "+"
ENDIF
m.lcIDRef = TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo))

ENDIF

* first evaluate THIS.IncludeBreaksInData
DO CASE
CASE m.llOmitBand
* do nothing -- TBD checked later.
CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_INDATA OR ;
NOT m.llFormatBreakBand

#IF OUTPUTXML = OUTPUTXML_RAW
IF NOT (ISNULL(THIS.CurrentBand) OR EMPTY(THIS.CurrentBand))
* a data band has spanned
* formatting breaks (pages or columns)
* and we haven't otherwise caught it.
* This should not happen.
m.lcInterruptedBand = SUBSTR(ALLTR(THIS.CurrentBand),2,AT(" ", THIS.CurrentBand)-2)
* write a closing tag
THIS.WriteRaw(THIS.CurrentBand + THIS.XMLRawTag(m.lcInterruptedBand))
ENDIF


THIS.CurrentBand =  THIS.XMLRawTag( m.lcBand,.T., m.lcID, m.lcIDRef )


#ELIF OUTPUTXML = OUTPUTXML_DOTNET

#ELSE

m.loNode = THIS.CurrentDocument.CreateElement(m.lcBand)
m.loNode.SetAttribute(THIS.idAttribute,m.lcID)
m.loNode.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
THIS.DataNodes.AppendChild(m.loNode)
THIS.CurrentBand = m.loNode
m.loNull = NULL
#ENDIF

CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
* build the collection which will be inserted into the
* data before finishing.
* but the band output at this point is .F.
#IF OUTPUTXML = OUTPUTXML_RAW
IF INLIST( m.nBandObjCode, ;
FRX_OBJCOD_PAGEHEADER, ;
FRX_OBJCOD_PAGEFOOTER)
THIS.CurrentPage = NVL(THIS.CurrentPage,"")
THIS.CurrentPage = THIS.CurrentPage + ;
THIS.XMLRawTag( m.lcBand, .T.,m.lcID, m.lcIDRef )
ELSE
THIS.CurrentColumn = NVL(THIS.CurrentColumn,"")
THIS.CurrentColumn = THIS.CurrentColumn + ;
THIS.XMLRawTag( m.lcBand, .T., m.lcID, m.lcIDRef )
ENDIF


#ELIF OUTPUTXML = OUTPUTXML_DOTNET

#ELSE

* we leave THIS.CurrentBand alone in this case,
* to use after the band has finished.
IF INLIST( m.nBandObjCode, ;
FRX_OBJCOD_PAGEHEADER, ;
FRX_OBJCOD_PAGEFOOTER)
THIS.CurrentPage = THIS.CurrentDocument.CreateElement(m.lcBand)
THIS.CurrentPage.SetAttribute(THIS.idAttribute,m.lcID)
THIS.CurrentPage.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
THIS.PageNodes.AppendChild(THIS.CurrentPage)
ELSE
THIS.CurrentColumn = THIS.CurrentDocument.CreateElement(m.lcBand)
THIS.CurrentColumn.SetAttribute(THIS.idAttribute,m.lcID)
THIS.CurrentColumn.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
THIS.ColumnNodes.AppendChild(THIS.CurrentColumn)
ENDIF

#ENDIF
CASE INLIST( m.nBandObjCode, ;
FRX_OBJCOD_COLHEADER, ;
FRX_OBJCOD_COLFOOTER)   &amp;&amp; XMLBREAKS_NONE and column band

THIS.CurrentColumn = "X"

OTHERWISE  &amp;&amp; XMLBREAKS_NONE and page band

THIS.CurrentPage = "X"

ENDCASE

THIS.resetDataSession()

ENDIF



ENDPROC
PROCEDURE BeforeReport
DODEFAULT()

IF (NOT THIS.HadError)
THIS.SetFRXDataSession()
IF THIS.isSuccessor
* need a private norender object
* to handle potential rendering tests
* specific to this output type
THIS.successorGFXNoRender = ;
THIS.checkCollectionForSpecifiedMember(;
THIS.gfxNoRenderClass,;
THIS.gfxNoRenderClassLib,.T.,.T.)
ENDIF
IF USED("FRX")
LOCAL m.liSelect, m.lcDocument, m.lcReport, ;
m.lcRDL, m.lcPage, m.lcCol, m.lcData, m.loNode, m.loParent
m.liSelect = SELECT(0)
SELECT FRX

IF THIS.TargetHandle = -1 AND ;
(THIS.applyUserTransform OR ;
THIS.applyRDLTransform)
THIS.verifyTargetFile()
IF EMPTY(JUSTEXT(THIS.TargetFileName))
THIS.TargetFileName = FORCEEXT(THIS.TargetFileName,THIS.TargetFileExt)
ENDIF
THIS.AddProperty("SaveTargetFileName",THIS.TargetFileName)
THIS.TargetFileName = FORCEEXT(THIS.TargetFileName,"TMP")
ENDIF

IF (THIS.TargetHandle &gt; -1 OR THIS.OpenTargetFile())
IF NOT USED("Nodes")
IF  UPPER(FULLPATH(THIS.ConfigurationTable)) == ;
UPPER(FULLPATH(FORCEEXT(OUTPUTCLASS_INTERNALDBF,"DBF")))
USE (THIS.ConfigurationTable) AGAIN IN 0  ;
NOUPDATE ALIAS Nodes SHARED
ELSE
USE (THIS.ConfigurationTable) AGAIN IN 0  ;
ALIAS Nodes SHARED
THIS.VerifyNodeNames()
THIs.VerifyAttributeNames()
ENDIF
ENDIF

* create helper object
* create band and object cursors
* we may want to evaluate raw mode
* as well as THIS.XMLMode to see if these are needed:
IF (NOT (THIS.IncludeBandsWithNoObjects AND  ;
THIS.XMLMode = OUTPUTXML_DATA_ONLY) ) &amp;&amp; OR OUTPUTXML_PERFORMLOCALECONVERSION
THIS.LoadFRXCursor = .T.
IF ISNULL(THIS.FRXCursor) OR ;
(NOT THIS.FRXCursor.CreateObjectCursor("FRX", "OBJECTS", .F., .T. ,THIS.FRXDataSession)) &amp;&amp; force the load and make sure
&amp;&amp; we have access to runtime
&amp;&amp; version of the cursor
THIS.IncludeBandsWithNoObjects = .T.
ELSE
SELECT Bands
IF TAGNO("UniqueID") = 0
INDEX ON UniqueID TAG UniqueID
ENDIF
SET ORDER TO 0
SELECT Objects
IF TAGNO("UniqueID") = 0
INDEX ON UniqueID TAG UniqueID
ENDIF
SET ORDER TO 0
ENDIF
ENDIF

THIS.IsRunning = .T.
SET ORDER TO 0 IN FRX
m.lcDocument =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+ ;
OUTPUTXML_OBJCODE_DOC,;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
m.lcReport =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
"Nodes","ObjType"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)

IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY
m.lcData =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
OUTPUTXML_OBJCODE_DATA, ;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
ENDIF
IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY
m.lcRDL = IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
OUTPUTXML_OBJCODE_RDL, ;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
ENDIF
IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
m.lcPage =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
OUTPUTXML_OBJCODE_PAGES, ;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)
*        GO (THIS.frxHeaderRecno) IN FRX
*        IF FRX.VPos &gt; 1
m.lcCol = IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+;
OUTPUTXML_OBJCODE_COLS,;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)

*       ENDIF
ENDIF
#IF OUTPUTXML = OUTPUTXML_RAW
IF EMPTY(THIS.CurrentDocument) OR ISNULL(THIS.CurrentDocument)
THIS.CurrentDocument = m.lcDocument
THIS.WriteRaw( ;
THIS.XMLRawTag( THIS.CurrentDocument,.T.) )
ENDIF
THIS.WriteRaw( ;
THIS.XMLRawTag( m.lcReport,.T.) )
* could add FRXname as ID here
IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY
* write RDL here
THIS.WriteRaw( ;
THIS.XMLRawTag( m.lcRDL,.T.,THIS.xmlRawConv( THIS.CommandClauses.FILE)) )
THIS.WriteRaw( STRCONV(THIS.GetVFPRDLContents(m.lcRDL, .T.),STRCONV_DBCS_UTF8)  )
THIS.WriteRaw( ;
THIS.XMLRawTag( m.lcRDL) )
ENDIF
IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY
THIS.WriteRaw( ;
THIS.XMLRawTag( m.lcData,.T.) )

IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
THIS.PageNodes =  THIS.XMLRawTag( m.lcPage,.T.)
*                 IF NOT EMPTY(lcCol)
THIS.ColumnNodes = THIS.XMLRawTag(m.lcCol,.T.)
*                 ENDIF
ENDIF
ENDIF

#ELIF OUTPUTXML = OUTPUTXML_DOTNET
* XMLTextWriter work
#ELSE
IF VARTYPE(THIS.CurrentDocument) # "O"
LOCAL m.liSession
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
THIS.CurrentDocument = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
SET DATASESSION TO (m.liSession)
* COMPROP(THIS.CurrentDocument,"UTF8",1)
THIS.CurrentDocument.DocumentElement = THIS.CurrentDocument.CreateElement(m.lcDocument)
ENDIF
loNode = THIS.CurrentDocument.CreateElement(m.lcReport)
* setattribute id using FRXName here
* idref?
THIS.CurrentDocument.DocumentElement.AppendChild(m.loNode)
m.loParent = loNode
IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY
m.loNode = THIS.CurrentDocument.CreateElement(m.lcRDL)
m.loNode.SetAttribute(THIS.idAttribute,THIS.CommandClauses.FILE)
m.loNode.AppendChild(THIS.GetVFPRDLContents(m.lcRDL))
m.loParent.AppendChild(m.loNode)
ENDIF
IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY
m.loNode = THIS.CurrentDocument.CreateElement(m.lcData)
* possibly add DE stuff here
m.loParent.AppendChild(m.loNode)
THIS.DataNodes = m.loNode
IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
THIS.PageNodes = THIS.CurrentDocument.CreateElement(m.lcPage)
THIS.DataNodes.AppendChild(THIS.PageNodes)
THIS.ColumnNodes = THIS.CurrentDocument.CreateElement(m.lcCol)
THIS.DataNodes.AppendChild(THIS.ColumnNodes)
ENDIF
ENDIF
#ENDIF
IF THIS.XMLMode = OUTPUTXML_RDL_ONLY
THIS.AfterReport(.T.)
ENDIF
ENDIF
*&amp;* Sedna
IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
THIS.initializeFormattingChangesCursor()
SELECT FRX
IF USED(THIS.formattingChanges)
SELECT FRX
SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND ;
ObjType = FRX_OBJTYP_FIELD AND NOT DELETED() &amp;&amp; fields only
INSERT INTO (THIS.FormattingChanges) ;
(FRXRecno) VALUES (RECNO("FRX"))
ENDSCAN
SELECT (THIS.FormattingChanges)
INDEX ON FRXRecno TAG FRXRecno
SELECT FRX
ENDIF
ENDIF
STORE NULL TO m.loNode, m.loParent
SELECT (m.liSelect)
ELSE
THIS.DoMessage(OUTPUTXML_FRXMISSING_LOC,MB_ICONSTOP )
THIS.lastErrorMessage = OUTPUTXML_FRXMISSING_LOC
ENDIF
THIS.resetDataSession()
ENDIF

RETURN
ENDPROC
PROCEDURE closetargetfile
LOCAL m.llResetQuietMode
m.llResetQuietMode =  ;
((NOT THIS.HadError) AND (NOT THIS.QuietMode) AND  ;
(THIS.applyUserTransform OR THIS.applyRDLTransform ))
IF m.llResetQuietMode
THIS.QuietMode = .T.
ENDIF
DODEFAULT()
IF m.llResetQuietMode
THIS.QuietMode = .F.
ENDIF
ENDPROC
PROCEDURE contattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.contAttr = m.vNewVal
ENDIF



ENDPROC
PROCEDURE createconfigtable
LPARAMETERS m.tcDBF, m.tlOverWrite
* table is being created from scratch,
* may be in a VCX in an unknown environment
* (definitely not in REPORTOUTPUT.APP!)

DODEFAULT(m.tcDBF, m.tlOverWrite)

IF NOT THIS.HadError
LOCAL m.liSelect, m.llSafetyOn
m.llSafetyOn = (SET("SAFETY") = "ON")
SET SAFETY OFF
m.liSelect = SELECT(0)
SELECT 0
USE (m.tcDBF) EXCLU
INDEX ON ObjType+ObjCode+ ;
IIF(ObjType=FRX_OBJTYP_BAND+OUTPUTXML_OBJTYPE_NODES, ;
OUTPUTXML_OBJTYPE_BANDOFFSET,0) ;
TAG FRXNodes
IF m.llSafetyOn
SET SAFETY ON
ENDIF
THIS.InsertXMLConfigRecords()
USE
SELECT (m.liSelect)
ENDIF

ENDPROC
PROCEDURE currentdocument_assign
LPARAMETERS m.vNewVal
* TBD: evaluate for readonly status during the life of the report run
THIS.currentdocument = m.vNewVal

ENDPROC
PROCEDURE datatextattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.dataTextAttr = m.vNewVal
ENDIF



ENDPROC
PROCEDURE datatypeattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.dataTypeAttr = m.vNewVal
ENDIF

ENDPROC
PROCEDURE Destroy

DODEFAULT()
THIS.ResetDocument()
STORE NULL TO ;
THIS.ColumnNodes, ;
THIS.CurrentBand, ;
THIS.CurrentColumn, ;
THIS.CurrentDocument, ;
THIS.CurrentPage, ;
THIS.DataNodes, ;
THIS.pageNodes, ;
THIS.XSLTProcessorRDL, ;
THIS.XSLTProcessorUser, ;
THIS.xsltParameters

ENDPROC
PROCEDURE Error
LPARAMETERS m.nError, m.cMethod, m.nLine

DODEFAULT(m.nError,m.cMethod,m.nLine)
* we could evaluate errors first, but generally,
THIS.CloseTargetFile()
IF THIS.isRunning
THIS.QuietMode = .T.
ENDIF
THIS.CancelReport()


ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS m.nFRXRecno, m.oObjProperties
DODEFAULT(m.nFRXRecno,m.oObjProperties)
* do some work even though we may not be
* adding DTYPE and DTEXT, so that
* subclasses can rely on the right record
* being made available in the formattingChanges alias
* and the "empty values" object always being there
IF THIS.InvokeOnCurrentPass() AND ;
THIS.targetHandle &lt;&gt; -1
THIS.setFRXDataSession()
IF USED(THIS.formattingChanges)
IF ISNULL(THIS.evaluateContentsValues)
* first time
SELECT (THIS.formattingChanges)
SCATTER MEMO BLANK NAME THIS.evaluateContentsValues ;
FIELDS EXCEPT FRXRecno
ENDIF
=SEEK(m.nFRXRecno,THIS.FormattingChanges, "FRXRecno")
IF NOT EOF(THIS.formattingChanges)
SELECT (THIS.formattingChanges)
GATHER NAME THIS.evaluateContentsValues  &amp;&amp; always start off empty
IF THIS.includeDataTypeAttributes
WITH m.oObjProperties
IF EMPTY(.Value)
REPLACE DType WITH "C"
ELSE
REPLACE DType WITH VARTYPE(.Value), ;
DText WITH THIS.formatDataValue(.Value)
ENDIF
ENDWITH
ENDIF
SELECT FRX
ENDIF
ENDIF
THIS.resetDataSession()
ELSE
RETURN .F.
ENDIF

ENDPROC
PROCEDURE evaluatestringtoboolean
LPARAMETERS tcVal
RETURN INLIST(UPPER(m.tcVal),"YES",".T.","TRUE","1")
ENDPROC
PROCEDURE fillruncollector
* getRunNodeContents will allow a Collection,
* a table/alias, or an empty-type object.
* Table/Alias is easiest, and allows you to use
* reset levels of OUTPUTFX_RUNCOLLECTOR_RESET_NEVER or
* OUTPUTFX_RUNCOLLECTOR_RESET_ONCHAIN, because the entry
* keys do not have to be unique.
* However, a Collection or EMPTY object
* allows you to add serialized XML documents as the values
* of a single property if you like. (This is done
* in addRunNode method.) You also don't have to
* place a cursor in the user's data session.
* (The getRunNodeContents method will find the cursor in the FRX data session
* as well, but that wouldn't work very well for
* chained reports; in fact, even CurrentDataSession is
* dicey with chained reports unless you're sure none
* of them has a private data session.)
* For these reasons, although its known document
* properties are all simple values, xmlListener
* chooses to implement
* fillRunCollector using a Collection object, and
* a CASE exists below to load the XML contents properly
* for any consumers that wish to read it as true XML.
* runCollectorResetLevel is readonly at OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT
* to ensure uniqueness of the keys for each report run.

* If you override this method to use an alias, you can
* gather data cumulatively for chained runs however you
* choose, and getRunNodeContents should cope.

* If you augment this method to add to the collection,
* you can add serialized objects
* in the form of XML nodes that have nothing to do with the
* original memberdata contents, and may be completely different
* in schema.  HTMLListener does this for HTTP-EQUIV handling.

IF ISNULL(THIS.runCollector) OR VARTYPE(THIS.runCollector) # "O"
* because we are using OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT,
* this should always be true, and the session issue is
* probably not relevant.  But we will adjust the session
* in case somebody changes this #DEFINEd life-period of
* the runCollector object
LOCAL m.liSession
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
THIS.runCollector = CREATEOBJECT("Collection")
SET DATASESSION TO (m.liSession)
ENDIF

THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias)
LOCAL m.lvValue, m.lcExpr, m.liSelect, m.loXML, m.loXMLTemp
IF USED("FRX")
GO (THIS.frxHeaderRecno) IN FRX
#IF OUTPUTXML = OUTPUTXML_DOM
m.loXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
m.loXMLTemp = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
#ELSE
m.loXML = CREATEOBJECT("Microsoft.XMLDOM")
m.loXMLTemp = CREATEOBJECT("Microsoft.XMLDOM")
#ENDIF
IF NOT m.loXML.LoadXML(FRX.Style)
m.loXML = NULL
ENDIF
ENDIF
m.liSelect = SELECT(0)

SELECT (THIS.memberDataAlias)
SCAN ALL FOR FRXRecno = THIS.frxHeaderRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  ;
AND (NOT (EMPTY(Execute) OR EMPTY(Name) OR EMPTY(ExecWhen) OR DELETED()))
* do not check
* for Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS
* because you can add your own in.
* But it must have *some* namespace.
* IOW, the original metadata record with
* blank namespace is not included in this treatment,
* because its Execute and ExecWhen fields
* are specified to have different scripting behavior.
m.lvValue = ""
m.lcExpr = Execute
DO CASE
CASE VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lvValue = THIS.evaluateUserExpression(m.lcExpr)
CASE VAL(DeClass) = ADVPROP_EDITMODE_TEXT AND ;
NOT ISNULL(m.loXML)
m.lvValue = ;
m.loXML.SelectSingleNode("/VFPData/reportdata" + ;
"[@name='" + Name + "' and @execwhen='" + ExecWhen + "']/@execute")
IF (NOT ISNULL(m.lvValue)) AND ;
m.loXMLTemp.LoadXML(m.lvValue.Text)
m.lvValue = m.loXMLTemp.DocumentElement
ELSE
m.lvValue = m.lcExpr
* may not really be XML, we still want the information
ENDIF
OTHERWISE
m.lvValue = m.lcExpr
ENDCASE

* The following help ensures uniqueness of key values
* in case people use the same property names in ExecWhen.

IF Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS
m.lcExpr = ExecWhen
ELSE
m.lcExpr = Name+"."+ExecWhen
ENDIF
IF THIS.runCollector.getKey(m.lcExpr) = 0
THIS.runCollector.add(m.lvValue,m.lcExpr)
ENDIF
ENDSCAN
SELECT (liSelect)
STORE NULL  TO m.loXML, m.loXMLTemp
ENDIF

ENDPROC
PROCEDURE fixmsxmlobjectfordtds
LPARAMETERS m.toXML

IF VARTYPE(m.toXML) = "O"
TRY
WITH m.toXML
.validateOnParse = .F.
.resolveExternals = .F.
.setProperty("ProhibitDTD",.F.)
ENDWITH
CATCH WHEN .T. &amp;&amp; Swallow any errors.
*&amp;* This fix primarily benefits
*&amp;* external usees of the ApplyXSLT public method;
*&amp;* it does not affect standard/automatic
*&amp;* usage of ApplyXSLT to VFP-RDL XML files.
*&amp;* It allows people to use the ApplyXSLT method
*&amp;* more flexibly when transforming XML data
*&amp;* between two schemas (standard B2B requirement).
*&amp;* However, the "ProhibitDTD" property
*&amp;* is not supported by the original 2003 msxml4.dll
*&amp;* distribution file.
*&amp;* The property will exist, and
*&amp;* the behavior will be supported, if the user has
*&amp;* applied fixes and updates to MSXML as is usually
*&amp;* the case.
*&amp;* If the msxml4.dll file has been deployed using
*&amp;* an MSM supplied with VFP as part of a distribution
*&amp;* setup to a Vista machine, rather than as part of
*&amp;* normal OS files in pre-Vista environments, this
*&amp;* may *not* be the case.
*&amp;* For information about updates and patches
*&amp;* to msxml4.dll,
*&amp;* see http://www.microsoft.com/downloads/details.aspx?FamilyID=24b7d141-6cdf-4fc4-a91b-6f18fe6921d4&amp;DisplayLang=en#Instructions
*&amp;* Vulnerabilities in Microsoft XML Core Services 4.0 Could Allow Remote Code Execution (927978)
*&amp;* Note that msxml4.dll is a side-by-side installation file and
*&amp;* the update will fail to occur properly if the DLL is currently locked
*&amp;* because an application is, or has been, using it.  This would including
*&amp;* loading VFP.
*&amp;* For instructions regarding "locked" file that may cause installation to fail
*&amp;* and how to get around it, see http://support.microsoft.com/?kbid=927978
*&amp;* To ensure that the updates have been applied, check the current date
*&amp;* of the msxml4.dll file in %windir%/system32 directory.
*&amp;* At this writing (Sedna development timeframe), the date of msxml4.dll is 11/2006.
ENDTRY
ENDIF

ENDPROC
PROCEDURE formatdatavalue
LPARAMETERS m.tVal
IF INLIST(VARTYPE(m.tVal),"D","T")
RETURN TTOC(m.tVal,3)
ELSE
* a subclass could do more here
RETURN TRANSFORM(m.tVal)
ENDIF
ENDPROC
PROCEDURE frxcharsetsinuse
LPARAMETERS tcAlias
LOCAL m.liSession, m.liSelect, m.liTally, m.liRec, m.lcAlias, m.llSwitchSessions

IF VARTYPE(tcAlias) # "C" OR EMPTY(tcAlias) OR UPPER(ALLTRIM(tcAlias)) == "FRX"
m.lcAlias = "FRX"
m.llSwitchSessions = .T.
ELSE
m.lcAlias = ALLTRIM(tcAlias)
ENDIF

m.liTally = 0

IF THIS.FRXDataSession &gt; -1 AND m.llSwitchSessions
m.liSession = SET("DATASESSION")
THIS.setFRXDataSession()
ELSE
m.liSession = -1
ENDIF

IF USED(m.lcAlias)
m.liSelect = SELECT(0)
m.liRec = RECNO(m.lcAlias)
SELECT (m.lcAlias)
COUNT ALL FOR INLIST(ObjType,;
FRX_OBJTYP_LABEL,;
FRX_OBJTYP_FIELD) AND ;
Double AND Resoid # 1 ;
TO m.liTally
*&amp;* RESOID=1 indicates use of default locale, treat this like no charset indication
*&amp;* do not pay attention to header value, just text labels and expressions,
*&amp;* because the header value doesn't propagate to existing controls (even at designtime)
*&amp;* -- it just indicates the default for new objects.
*&amp;* If you adjusted the FRX contents at runtime with new
*&amp;* text controls, you might want to pay attention to the contents
*&amp;* of the header RESOID and DOUBLE values, though -- just as the design-time
*&amp;* components do.
IF m.liRec &gt; RECCOUNT()
GO BOTTOM
SKIP
ELSE
GO m.liRec
ENDIF
SELECT (m.liSelect)
ENDIF

IF m.liSession &gt; -1
SET DATASESSION TO (m.liSession)
ENDIF

RETURN (m.liTally &gt; 0)
ENDPROC
PROCEDURE getdefaultuserxslt
** this is an abstract method for use by subclasses
ENDPROC
PROCEDURE getfrxlayoutobjectfieldlist
LPARAMETERS m.tcAlias
* frx
* PLATFORM,UNIQUEID,TIMESTAMP,OBJTYPE,OBJCODE,NAME,EXPR,VPOS,HPOS,HEIGHT,WIDTH,STYLE,
* PICTURE,ORDER,UNIQUE,COMMENT,ENVIRON,BOXCHAR,FILLCHAR,TAG,TAG2,PENRED,PENGREEN,PENBLUE,
* FILLRED,FILLGREEN,FILLBLUE,PENSIZE,PENPAT,FILLPAT,FONTFACE,FONTSTYLE,FONTSIZE,MODE,RULER,
* RULERLINES,GRID,GRIDV,GRIDH,FLOAT,STRETCH,STRETCHTOP,TOP,BOTTOM,SUPTYPE,SUPREST,NOREPEAT,RESETRPT,PAGEBREAK,COLBREAK,RESETPAGE,GENERAL,SPACING,DOUBLE,SWAPHEADER,SWAPFOOTER,EJECTBEFOR,EJECTAFTER,PLAIN,SUMMARY,ADDALIAS,OFFSET,TOPMARGIN,BOTMARGIN,TOTALTYPE,RESETTOTAL,RESOID,CURPOS,SUPALWAYS,SUPOVFLOW,SUPRPCOL,SUPGROUP,SUPVALCHNG,SUPEXPR,USER
* objects
* UNIQUEID,OBJTYPE,OBJCODE,EXPR,VPOS,HPOS,HEIGHT,WIDTH,OBJNAME,LOCALE_ID,START_BAND_ID,BAND_OFFSET,END_BAND_ID,BANDLABEL,SELECTED,OBJ_PICT,BAND_SEQ
* bands
* UNIQUEID,OBJTYPE,OBJCODE,EXPR,BANDLABEL,START,STOP,HEIGHT,P_START,P_STOP,P_HEIGHT,RESETTOTAL,BAND_SEQ,REL_BAND_ID



RETURN ;
"RECNO() AS FrxRecno, "+m.tcAlias+".PLATFORM, "+m.tcAlias+".NAME,"+m.tcAlias+".EXPR,"+m.tcAlias+".OFFSET,"+m.tcAlias+".VPOS,"+m.tcAlias+".HPOS,"+m.tcAlias+".HEIGHT,"+;
""+m.tcAlias+".OBJTYPE, "+m.tcAlias+".TAG, "+m.tcAlias+".TAG2,"+m.tcAlias+".PENSIZE,"+m.tcAlias+".PENPAT,"+m.tcAlias+".FILLPAT,"+;
""+m.tcAlias+".WIDTH,"+m.tcAlias+".STYLE,"+m.tcAlias+".PICTURE,"+m.tcAlias+".ORDER,"+m.tcAlias+".COMMENT,"+m.tcAlias+".FILLCHAR,"+;
""+m.tcAlias+".PENRED,"+m.tcAlias+".PENGREEN,"+m.tcAlias+".PENBLUE,"+m.tcAlias+".FILLRED,"+m.tcAlias+".FILLGREEN,"+m.tcAlias+".FILLBLUE,"+;
""+m.tcAlias+".FONTFACE, "+m.tcAlias+".FONTSTYLE,"+m.tcAlias+".FONTSIZE,"+m.tcAlias+".MODE,"+m.tcAlias+".FLOAT,"+m.tcAlias+".STRETCH,"+m.tcAlias+".STRETCHTOP,"+;
"BITTEST( "+m.tcAlias+".FONTSTYLE, 0 ) AS FontBold,"+ ;
"BITTEST( "+m.tcAlias+".FONTSTYLE, 1 ) AS FontItalic,"+ ;
"BITTEST( "+m.tcAlias+".FONTSTYLE, 3 ) AS FontUnderline,"+ ;
"BITTEST( "+m.tcAlias+".FONTSTYLE, 7 ) AS FontStrikeThrough,"+ ;
"THIS.GetPathedImageInfo("+m.tcAlias+".ObjType, "+m.tcAlias+".Name, "+m.tcAlias+".Picture, "+m.tcAlias+".Offset) AS UnpathedImg,"+ ;
"THIS.GetPathedImageInfo("+m.tcAlias+".ObjType, "+m.tcAlias+".Name, "+m.tcAlias+".Picture, "+m.tcAlias+".Offset, .T.) AS PathedImg,"+ ;
""+m.tcAlias+".TOP,"+m.tcAlias+".BOTTOM,"+m.tcAlias+".NOREPEAT,"+m.tcAlias+".PAGEBREAK,"+m.tcAlias+".COLBREAK,"+m.tcAlias+".RESETPAGE,"+m.tcAlias+".GENERAL,"+m.tcAlias+".SPACING,"+ ;
""+m.tcAlias+".SWAPHEADER,"+m.tcAlias+".SWAPFOOTER,"+m.tcAlias+".EJECTBEFOR,"+m.tcAlias+".EJECTAFTER,"+m.tcAlias+".TOTALTYPE,"+m.tcAlias+".RESETTOTAL,"+ ;
"IIF("+m.tcAlias+".DOUBLE,"+m.tcAlias+".RESOID,1) AS FONTCHARSET,"+m.tcAlias+".SUPALWAYS,"+m.tcAlias+".SUPOVFLOW,"+m.tcAlias+".SUPRPCOL,"+m.tcAlias+".SUPGROUP,"+m.tcAlias+".SUPVALCHNG,"+m.tcAlias+".SUPEXPR,"+m.tcAlias+".USER,"+ ;
"OBJECTS.UniqueID AS ObjID, OBJECTS.ObjName, Objects.Locale_ID,"+ ;
"OBJECTS.START_BAND_ID,OBJECTS.BAND_OFFSET,OBJECTS.END_BAND_ID,"+ ;
"BANDS.UNIQUEID AS BandID,BANDS.OBJCODE AS BandType,Bands.BANDLABEL,Bands.START,"+;
"Bands.STOP,Bands.BAND_SEQ,Bands.REL_BAND_ID, ("+m.tcAlias+".ObjType=9 AND (NOT "+m.tcAlias+".Plain)) AS BandStretch"
ENDPROC
PROCEDURE getpathedimageinfo
LPARAMETERS m.tObjType, m.tName, m.tPicture, m.tOffset, m.tPathed
LOCAL m.lcReturn, m.lcFile
m.lcReturn = ""
IF m.tObjType =  FRX_OBJTYP_PICTURE
DO CASE
CASE m.tOffset = 0 &amp;&amp; literal filename
m.lcReturn = STRTRAN(m.tPicture,["],[])
IF m.tPathed
m.lcReturn = FULLPATH(m.tPicture,THIS.CommandClauses.File)
ELSE
m.lcReturn = JUSTFNAME(m.tPicture)
ENDIF
CASE m.tOffset = 1 &amp;&amp; general field
m.lcReturn = "["+m.tName+"]"
CASE m.tOffset = 2 AND TYPE(m.tName)= "O" &amp;&amp; imagecontrol
m.lcReturn = "["+m.tName+"]"
CASE m.tOffset = 2 AND TYPE(m.tName) = "C" &amp;&amp; expression
m.lcFile = EVALUATE(m.tName)
IF NOT FILE(m.lcFile)
m.lcFile = EVALUATE(STRTRAN(m.tName,"()","")) &amp;&amp; indirect
ENDIF
IF FILE(m.lcFile)
IF m.tPathed
m.lcReturn = FULLPATH(EVALUATE(m.tName))
ELSE
m.lcReturn = JUSTFNAME(EVALUATE(m.tName))
ENDIF
ELSE
m.lcReturn =  "["+m.tName+"]"
ENDIF
OTHERWISE
m.lcReturn = "["+m.tName+"]"
ENDCASE
ENDIF
m.lcReturn = PADR(CHRTRAN(m.lcReturn,"\","/"), OUTPUTXML_CHARFIELD_LIMIT)

RETURN m.lcReturn


ENDPROC
PROCEDURE getrawformattinginfo
LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL m.lcInfo

m.lcInfo = ""

m.lcInfo = m.lcInfo + " "+THIS.contAttr+"='"+TRANSFORM(m.tnObjectContinuationType)+"'"

IF THIS.IncludeFormattingInLayoutObjects
m.lcInfo = m.lcInfo + " "+THIS.leftAttr+"='"+ TRANSFORM(m.tnLeft)+"'"
m.lcInfo = m.lcInfo + " "+THIS.topAttr+"='"+TRANSFORM(m.tnTop)+"'"
m.lcInfo = m.lcInfo + " "+THIS.widthAttr+"='"+TRANSFORM(m.tnWidth)+"'"
m.lcInfo = m.lcInfo + " "+THIS.heightAttr+"='"+TRANSFORM(m.tnHeight)+"'"
ENDIF

THIS.setFRXDataSession()

m.llPageImages = (NOT EMPTY(THIS.currentPageImageFilename)) ;
AND USED(THIS.memberDataAlias)

IF THIS.includeDataTypeAttributes  OR m.llPageImages
IF USED(THIS.FormattingChanges) AND ;
SEEK(RECNO("FRX"),THIS.FormattingChanges,"FRXRecno")
SELECT (THIS.FormattingChanges)
IF THIS.includeDataTypeAttributes
IF EMPTY(DText)
m.lcInfo = m.lcInfo + " "+THIS.dataTypeAttr+"='"+DType+"'"
ELSE
m.lcInfo = m.lcInfo + " "+THIS.dataTypeAttr+"='"+DType+"'"
m.lcInfo = m.lcInfo + " "+THIS.dataTextAttr+"='"+THIS.xmlRawConv(DText)+"'"
ENDIF
ENDIF
ENDIF
IF m.llPageImages AND SEEK(RECNO("FRX"),THIS.memberDataAlias,"FRXRecno")
SELECT (THIS.memberDataAlias)
LOCATE FOR FRXRecno = RECNO("FRX") AND ;
Type == FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
THIS.evaluateStringToBoolean(Execute)
IF FOUND()
m.lcInfo = m.lcInfo + " " + THIS.pageImageAttr+"='"+ ;
THIS.currentPageImageFilename +"'"
ENDIF
ENDIF
SELECT FRX
ENDIF


RETURN m.lcInfo
ENDPROC
PROCEDURE getrunnodecontents
LPARAMETERS m.tlAsString

LOCAL m.lcItem, m.oXML, m.lvValue, m.liSession

THIS.setFRXDataSession()
m.lcItem =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ OUTPUTXML_OBJCODE_RUN , ;
"Nodes","FrxNodes"), ;
Nodes.ObjValue, ;
OUTPUTXML_GOOFTAG)

* Handles Cursor, Empty object, Collection
* Raw or dom method.

m.lcItem = "&lt;"  + m.lcItem + "/&gt;"

m.liSession = SET("DATASESSION")
THIS.resetDataSession()
#IF OUTPUTXML = OUTPUTXML_DOM
m.oXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
#ELSE
m.oXML = CREATEOBJECT("Microsoft.XMLDOM")
#ENDIF
SET DATASESSION TO (m.liSession)

IF m.oXML.LoadXML(m.lcItem)
THIS.setCurrentDataSession()
DO CASE
CASE ISNULL(THIS.runCollector)
m.oXML = NULL
CASE VARTYPE(THIS.runCollector) = "C"
IF NOT (USED(THIS.runCollector) AND ;
RECCOUNT(THIS.runCollector) &gt; 0)
* try FRX datasession
THIS.setFRXDataSession()
ENDIF
IF (USED(THIS.runCollector) AND ;
RECCOUNT(THIS.runCollector) &gt; 0)
* two fields significant, first evaluates to property value,
* second is property name
LOCAL m.lcField1, m.lcField2, m.liIndex, m.liSelect
m.liSelect = SELECT(0)
SELECT (THIS.runCollector)
FOR m.liIndex = 1 TO FCOUNT()
IF INLIST(TYPE(FIELD(m.liIndex)),"M","C")
IF EMPTY(m.lcField1)
m.lcField1 = FIELD(m.liIndex)
ELSE
m.lcField2 = FIELD(m.liIndex)
EXIT
ENDIF
ENDIF
ENDFOR
IF (EMPTY(m.lcField1))
m.oXML = NULL
ELSE
SCAN ALL FOR NOT DELETED()
THIS.addRunNode(m.oXML,EVAL(m.lcField1),;
IIF(EMPTY(m.lcField2) OR EMPTY(EVAL(m.lcField2)), ;
"P" + TRANSFORM(RECNO()), EVAL(m.lcField2)))
ENDSCAN
ENDIF
ENDIF
SELECT (m.liSelect)
CASE VARTYPE(THIS.runCollector) = "O" AND ;
TYPE("THIS.runCollector.Baseclass") = "U"
* empty object
LOCAL m.liIndex, m.laMembers[1]
IF AMEMBERS(m.laMembers,THIS.runCollector) = 0
m.oXML = NULL
ELSE
FOR m.liIndex = 1 TO ALEN(m.laMembers)
THIS.addRunNode(m.oXML,;
"THIS.runCollector." + m.laMembers[m.liIndex], ;
m.laMembers[m.liIndex])
ENDFOR
ENDIF
CASE VARTYPE(THIS.runCollector) = "O" AND ;
UPPER(THIS.runCollector.BaseClass) == "COLLECTION"
LOCAL m.liIndex
IF THIS.runCollector.Count = 0
m.oXML = NULL
ELSE
FOR m.liIndex = 1 TO THIS.runCollector.Count
THIS.addRunNode(m.oXML,"THIS.runCollector[" + TRANSFORM(m.liIndex) + "]",;
IIF(EMPTY(THIS.runCollector.getKey[m.liIndex]), ;
"P" + TRANSFORM(m.liIndex), ;
THIS.runCollector.getKey[m.liIndex] ))
ENDFOR

ENDIF
OTHERWISE
m.oXML = NULL
ENDCASE

THIS.setFRXDataSession()

DO CASE
CASE ISNULL(m.oXML)
RETURN NULL
CASE m.tlAsString
RETURN m.oXML.DocumentElement.XML
OTHERWISE
RETURN m.oXML.DocumentElement
ENDCASE
ELSE
RETURN NULL
ENDIF

ENDPROC
PROCEDURE getvfprdlcontents
LPARAMETERS m.tcNodeName, m.tlAsString
* NB: no push/pop session here, don't bother
* because we're switching back and forth
* rapidly and not changing anything important
LOCAL m.liSelectCurrent, m.liSelectFRX, m.liSession, ;
m.liFlds, m.liDBFS, m.liIndex1, m.liIndex2, laFlds[1], ;
laDBFS[1], laRels[1], m.lcAlias, m.lcKey, m.llDesc, ;
m.lcFilter, m.lcRel, m.liRels, m.lcSkip, m.lcResult, m.llWholePage
LOCAL m.oXA, m.oXT1, m.oXT2, m.oXT3, m.oXT4, m.oXT5,m.oXT6, ;
m.oXML, m.oNode, m.oCommand
m.liSession = SET("DATASESSION")
THIS.setFRXDataSession()
m.liSelectFRX = SELECT(0)
IF THIS.IncludeDataSourcesInVFPRDL
CREATE CURSOR VFPDataSource (the_alias c(200), rpt_driver l, the_dbf m, the_order m, order_desc l, the_filter m, the_skip m )
CREATE CURSOR flds (the_alias c(200), the_field m, the_type c(1))
CREATE CURSOR rels (the_parent c(200), the_target c(200), the_expr m)
SELECT flds
INDEX ON the_alias TAG the_alias
SELECT rels
INDEX ON the_parent TAG the_alias
SELECT VFPDataSource
SET RELATION TO the_alias INTO flds, the_alias INTO rels
THIS.setCurrentDataSession()
m.liSelectCurrent = SELECT(0)
m.liDBFS = AUSED(laDBFS)
FOR m.liIndex = 1 TO m.liDBFS
THIS.setCurrentDataSession()
m.lcAlias = laDBFs[m.liIndex,1]
SELECT (m.lcAlias)
m.lcDBF = DBF()
m.liFlds = AFIELDS(laFlds)
m.lcKey = SET("ORDER")
m.llDesc =  (" DESC" $ UPPER(m.lcKey))
m.lcFilter = SET("FILTER")
m.lcSkip = SET("SKIP")
IF NOT EMPTY(m.lcKey)
m.lcKey = STRTRAN(UPPER(m.lcKey),"TAG","")
m.liIndex2 = ATC(" OF",m.lcKey)
IF m.liIndex2 &gt; 0
m.lcKey = LEFT(m.lcKey,m.liIndex2)
ENDIF
m.lcKey = ALLTR(m.lcKey)
m.liTag = TAGNO(m.lcKey)
IF m.liTag &gt; 0
m.lcKey = KEY(m.liTag)
ELSE
m.lcKey = ""
ENDIF
ENDIF
m.liRels = 0
STORE "" TO laRels
DO WHILE .T.
m.lcRel = RELATION(m.liRels + 1)
IF EMPTY(m.lcRel)
EXIT
ELSE
m.liRels = m.liRels + 1
DIME laRels[m.liRels,3]
laRels[m.liRels,1] = TARGET(m.liRels)
laRels[m.liRels,2] = m.lcRel
ENDIF
ENDDO
THIS.setFRXDataSession()
INSERT INTO VFPDataSource VALUES (m.lcAlias, (UPPER(m.lcAlias)==UPPER(THIS.Drivingalias)), m.lcDBF, m.lcKey, m.llDesc, m.lcFilter, m.lcSkip)
FOR m.liIndex2 = 1 TO m.liFlds
INSERT INTO flds VALUES (m.lcAlias, laFlds[m.liIndex2,1], laFlds[m.liIndex2,2])
ENDFOR
FOR m.liIndex2 = 1 TO m.liRels
INSERT INTO rels VALUES (m.lcAlias, laRels[m.liIndex2,1], laRels[m.liIndex2,2])
ENDFOR
ENDFOR
THIS.setCurrentDataSession()
SELECT (m.liSelectCurrent)
ENDIF
THIS.setFRXDataSession()
m.lcAlias = THIS.prepareFrxCopy()
m.lcResult = THIS.getFRXLayoutObjectFieldList(m.lcAlias)
SELECT &amp;lcResult ;
FROM (m.lcAlias) ;
LEFT JOIN Bands ON &amp;lcAlias..UniqueID = Bands.UniqueID ;
LEFT JOIN Objects ON &amp;lcAlias..UniqueID = Objects.UniqueID ;
WHERE Platform = FRX_PLATFORM_WINDOWS AND NOT DELETED() ;
INTO CURSOR VFPFRXLayoutObject READWRITE
THIS.removeFRXCopy(m.lcAlias)
SELECT VFPFRXLayoutObject
* get rid of compiled data:
IF TYPE("VFPFRXLayoutObject.Tag") # "U"
REPLACE Tag WITH "" ALL FOR NOT INLIST(ObjType,FRX_OBJTYP_VARIABLE,FRX_OBJTYP_BAND,FRX_OBJTYP_DATAENV ,FRX_OBJTYP_DATAOBJ)
ENDIF
IF TYPE("VFPFRXLayoutObject.Tag2") # "U"
REPLACE Tag2 WITH "" ALL FOR INLIST(ObjType,FRX_OBJTYP_REPORTHEADER,FRX_OBJTYP_DATAENV,FRX_OBJTYP_DATAOBJ)
ENDIF
IF TYPE("VFPFRXLayoutObject.Fontface") # "U"
REPLACE Fontface WITH ""  ALL FOR INLIST(ObjType,FRX_OBJTYP_DATAENV,FRX_OBJTYP_DATAOBJ)
ENDIF
GO TOP IN VFPFRXLayoutObject
m.llWholePage = VFPFRXLayoutObject.Top
SELECT Nodes.ObjValue AS Name, ;
Nodes.ObjType-OUTPUTXML_OBJTYPE_NODES AS Type, ;
Nodes.ObjCode AS Code, ;
Nodes.ObjInfo AS Info ;
FROM Nodes ;
WHERE BETWEEN(ObjType,OUTPUTXML_OBJTYPE_NODES, OUTPUTXML_OBJTYPE_NODES+100) ;
AND NOT DELETED() ;
INTO CURSOR VFPFRXLayoutNode READWRITE
m.liFlds = AMEMBERS(laFlds, THIS,0)
FOR m.liIndex1 = 1 TO m.liFlds
IF ATC("attr",laFlds[m.liIndex1]) &gt; 1
INSERT INTO VFPFRXLayoutNode VALUES ;
(TRANSFORM(EVALUATE("THIS."+laFlds[m.liIndex1])),;
0, ;
OUTPUTXML_OBJCODE_ATTRIBMEMBER,;
laFlds[m.liIndex1]+ " attribute nodename")
ENDIF
ENDFOR
m.oXA=CREATEOBJECT("XMLAdapter")
m.oXA.RespectCursorCP = .T.
m.oXT4 = m.oXA.AddTableSchema("VFPFRXLayoutObject")
m.oXT5 = m.oXA.AddTableSchema("VFPFRXLayoutNode")

IF USED(THIS.memberDataAlias) AND ;
RECCOUNT(THIS.memberDataAlias) &gt; 0
m.oXT6 = m.oXA.AddTableSchema(THIS.memberDataAlias,.F.,;
STRCONV("VFPFRXMemberData",STRCONV_DBCS_UNICODE))
ENDIF
m.oXA.RespectNesting=.T.
IF THIS.IncludeDataSourcesInVFPRDL
m.oXT1=oXA.AddTableSchema("VFPDataSource")
m.oXT2=oXA.AddTableSchema("flds")
m.oXT3=oXA.AddTableSchema("rels")
m.oXT1.Nest(m.oXT2)
m.oXT1.Nest(m.oXT3)
ENDIF

m.oXA.XMLSchemaLocation = ""
m.oXA.ToXML("lcResult")
THIS.resetDataSession()
#IF OUTPUTXML = OUTPUTXML_DOM
m.oXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
#ELSE
m.oXML = CREATEOBJECT("Microsoft.XMLDOM")
#ENDIF
THIS.setFRXDataSession()
m.oXML.LoadXML(m.lcResult)
m.oNode = m.oXML.SelectSingleNode("/./*")
IF NOT ISNULL(THIS.CommandClauses)
m.oCommand = m.oXML.createElement("VFPFRXCommand")
m.liFlds = AMEMBERS(laFlds, THIS.CommandClauses)
FOR m.liIndex1 = 1 TO m.liFlds
m.lcKey = EVAL("THIS.CommandClauses."+laFlds[m.liIndex1])
IF VARTYPE(m.lcKey) = "L"
IF m.lcKey
m.lcKey = "true"
ELSE
m.lcKey = "false"
ENDIF
ENDIF
m.oCommand.SetAttribute(laFlds[m.liIndex1], TRANSFORM(m.lcKey))
ENDFOR
m.oCommand.SetAttribute("OutputType",TRANSFORM(THIS.OutputType))
m.oCommand.SetAttribute("appName",THIS.appName)
m.oCommand.SetAttribute("targetFileName",THIS.targetFileName)
m.oNode.appendChild(m.oCommand)
ENDIF
m.oCommand =  oXML.createElement("VFPFRXPrintJob")
m.oCommand.SetAttribute("pagewidth", THIS.SharedPageWidth)
m.oCommand.SetAttribute("pageheight", THIS.SharedPageHeight)
m.oCommand.SetAttribute("name",THIS.PrintJobName)
m.oCommand.SetAttribute("pagedesign",IIF(llWholePage,"whole","printable"))
TRY
* if PROMPT was used this will probably work
m.oCommand.SetAttribute("printresolution",TRANSFORM(PRTINFO(PRT_YRESOLUTION ,SET("PRINTER",3))))
#IF .F.
* OUTPUTXML_RESOLUTIONFIX
* try to reset based on current printer FRX information
GO (THIS.frxHeaderRecno) IN FRX
SELECT FRX
m.liIndex = IIF(ALINES(laFlds,Picture,.T.) &gt; 0, ASCAN(laFlds,"YRESOLUTION"),0)
IF m.liIndex = 0
m.liIndex = IIF(ALINES(laFlds,Expr,.T.) &gt; 0, ASCAN(laFlds,"YRESOLUTION"),0)
ENDIF
IF m.liIndex &gt; 0
m.liIndex = VAL(ALLTRIM(SUBSTR(laFlds[liIndex],AT("=",laFlds[m.liIndex])+1)))
IF m.liIndex &gt; 0
m.oCommand.SetAttribute("printresolution",TRANSFORM(m.liIndex))
ELSE
m.oCommand.SetAttribute("printresolution","-1")
ENDIF
ENDIF
IF USED("SetPrinter")
USE IN SetPrinter
ENDIF
#ENDIF
CATCH WHEN .T.
* this can happen when there is no printer
m.oCommand.SetAttribute("printresolution","-1")
ENDTRY
m.oNode.appendChild(m.oCommand)
IF THIS.IncludeDataSourcesInVFPRDL
USE IN VFPDataSource
USE IN flds
USE IN rels
ENDIF
USE IN VFPFRXLayoutObject
USE IN VFPFRXLayoutNode
STORE NULL TO ;
m.oXA, m.oXT1, m.oXT2, m.oXT3, m.oXT4, m.oXT5, m.oXT6, m.oXML, m.oCommand
SELECT (m.liSelectFRX)
SET DATASESSION TO (m.liSession)
IF tlAsString
RETURN m.oNode.XML
ELSE
RETURN m.oNode
ENDIF
ENDPROC
PROCEDURE heightattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.heightAttr = m.vNewVal
ENDIF



ENDPROC
PROCEDURE idattribute_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.idattribute = m.vNewVal
ENDIF

ENDPROC
PROCEDURE idrefattribute_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.idrefattribute = m.vNewVal
ENDIF

ENDPROC
PROCEDURE includebandswithnoobjects_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
THIS.IncludeBandsWithNoObjects = m.vNewVal
ENDIF

ENDPROC
PROCEDURE includebreaksindata_assign
LPARAMETERS m.vNewVal
* Readonly during report run

IF VARTYPE(m.vNewVal) = "N" AND ;
INLIST(m.vNewVal, ;
OUTPUTXML_BREAKS_INDATA,;
OUTPUTXML_BREAKS_NONE, ;
OUTPUTXML_BREAKS_COLLECTION) AND ;
NOT THIS.IsRunning
THIS.IncludeBreaksInData = m.vNewVal
ENDIF

ENDPROC
PROCEDURE includedatasourcesinvfprdl_assign
LPARAMETERS m.vNewVal

IF VARTYPE(m.vNewVal) = "L"
THIS.IncludeDataSourcesinVFPRDL = m.vNewVal
ENDIF

ENDPROC
PROCEDURE includedatatypeattributes_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) = "L"
THIS.includeDataTypeAttributes = m.tvNewVal
ENDIF

ENDPROC
PROCEDURE includeformattinginlayoutobjects_assign
LPARAMETERS m.vNewVal
*TBD: evaluate whether
* it's okay to do this during a run?

IF VARTYPE(m.vNewVal) = "L"
THIS.IncludeFormattingInLayoutObjects = m.vNewVal
ENDIF

ENDPROC
PROCEDURE Init
THIS.ReadConfiguration = OUTPUTCLASS_READCONFIG_INIT

IF DODEFAULT()
THIS.AppName = OUTPUTXML_APPNAME_LOC
THIS.ResetDocument()
ELSE
RETURN .F.
ENDIF

IF THIS.applyUserTransform
THIS.GetDefaultUserXSLT()
ENDIF
RETURN NOT THIS.HadError
ENDPROC
PROCEDURE initializeformattingchangescursor
THIS.formattingChanges= "F"+SYS(2015)
IF THIS.includeDataTypeAttributes
CREATE CURSOR (THIS.formattingChanges) ;
(FRXRecno i, ;
DText M, ;
DType C(1))
ENDIF
ENDPROC
PROCEDURE insertxmlconfigrecords
* protected,
* assumes it is being called with config
* table already SELECTed.

DELETE FOR ;
BETWEEN(OBJTYPE,OUTPUTXML_OBJTYPE_NODES, OUTPUTXML_OBJTYPE_NODES + 100)

INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
FRX_OBJCOD_TITLE,'','Title','Title Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
FRX_OBJCOD_PAGEHEADER,'','PH','Page Header Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
FRX_OBJCOD_COLHEADER,'','CH','Column Header Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
FRX_OBJCOD_GROUPHEADER,'','GH','Group Header Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
FRX_OBJCOD_DETAIL,'','D','Detail Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+FRX_OBJTYP_BAND, ;
FRX_OBJCOD_GROUPFOOTER,'','GF','Group Footer Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
FRX_OBJCOD_COLFOOTER,'','CF','Column Footer Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
FRX_OBJCOD_PAGEFOOTER,'','PF','Page Footer Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
FRX_OBJCOD_SUMMARY,'','Summary','Summary Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
FRX_OBJCOD_DETAILHEADER,'','DH','Detail Header Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
FRX_OBJCOD_DETAILFOOTER,'','DF','Detail Footer Band nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER,;
FRX_OBJCOD_REPORTHEADER ,'','VFP-Report','Report root nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_LABEL, ;
FRX_OBJCOD_OTHER,'','T','Text object nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_FIELD, ;
FRX_OBJCOD_OTHER,'','E','Expression object nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_PICTURE,;
FRX_OBJCOD_OTHER,'','P','Picture object nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_RECTANGLE,;
FRX_OBJCOD_RECTANGLE,'','S','Shape object nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_LINE, ;
FRX_OBJCOD_OTHER,'','L','Line object nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_VARIABLE,;
FRX_OBJCOD_OTHER,'','V','Variable nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_FONTRES,;
FRX_OBJCOD_OTHER,'','FontRes','FontResource nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAENV,;
FRX_OBJCOD_OTHER,'','DataEnv','DataEnvironment nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAOBJ,;
FRX_OBJCOD_OTHER,'','DE-Cursor','DE-Cursor nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAOBJ, ;
FRX_OBJCOD_OTHER+1,'','DE-Relation','DE-Relation nodename')
* offset the DE Relation because
* this information isn't in ObjType or ObjCode
* as distinct from DE-Cursor other than in the Name field
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_GROUP, ;
FRX_OBJCOD_OTHER,'','Group','Group selector nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES, ;
OUTPUTXML_OBJCODE_DOC,'','Reports','XML Document root nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES,;
OUTPUTXML_OBJCODE_DATA,'','Data','Report scope data root nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES, ;
OUTPUTXML_OBJCODE_RDL,'','VFP-RDL','RDL layout description root nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES, ;
OUTPUTXML_OBJCODE_PAGES,'','Pages','Pages collection root nodename')
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES, ;
OUTPUTXML_OBJCODE_COLS,'','Columns','Column collection root nodename')
*&amp;* Sedna
INSERT INTO (ALIAS()) VALUES ;
(OUTPUTXML_OBJTYPE_NODES, ;
OUTPUTXML_OBJCODE_RUN,'','Run','Run property set root nodename')

ENDPROC
PROCEDURE invokeoncurrentpass
RETURN (THIS.includePage) AND ;
(NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY ) AND ;
((NOT THIS.TwoPassProcess) OR THIS.CurrentPass = LISTENER_FULLPASS)



ENDPROC
PROCEDURE leftattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.leftAttr = m.vNewVal
ENDIF


ENDPROC
PROCEDURE loadprocessorobject
LPARAMETERS m.tcVal

LOCAL m.loReturn
m.loReturn = NULL

IF VARTYPE(m.tcVal) = "C" AND NOT EMPTY(m.tcVal)
LOCAL m.loProcessor, m.loStylesheet, m.liSession
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
m.loProcessor  = CREATEOBJECT(OUTPUTXML_XSLT_PROCESSOROBJECT)
m.loStyleSheet = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
THIS.fixMSXMLObjectForDTDs(m.loStyleSheet)
SET DATASESSION TO (m.liSession)
IF FILE(m.tcVal)
m.loStyleSheet.Load(m.tcVal)
ELSE
* try to load it as a string
m.loStyleSheet.LoadXML(m.tcVal)
ENDIF
IF LEN(m.loStyleSheet.XML) &gt; 0 AND ;
EMPTY(m.loStyleSheet.parseError.reason)
m.loProcessor.styleSheet = loStyleSheet
m.loReturn = m.loProcessor
*  ELSE
*     THIS.LastErrorMessage = loSStyleSheet.parseError.reason
ENDIF
ENDIF

RETURN loReturn
ENDPROC
PROCEDURE nopageeject_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
THIS.NoPageEject = m.vNewVal
ENDIF

ENDPROC
PROCEDURE opentargetfile
#IF OUTPUTXML = OUTPUTXML_DOM
THIS.VerifyTargetFile()
THIS.TargetHandle = 0
RETURN (NOT THIS.HadError)
#ELSE
RETURN DODEFAULT()
#ENDIF

ENDPROC
PROCEDURE pageimageattr_assign
LPARAMETERS vNewVal

IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.pageImageAttr = m.vNewVal
ENDIF


ENDPROC
PROCEDURE preparefrxcopy
LOCAL m.lcAlias, m.lcFile
m.lcAlias = "FRX"
IF EMPTY(SYS(2000,THIS.CommandClauses.File)) AND ;
USED("FRX")
*&amp;* streamlined in Sedna leveraging new superclass capabilities.
m.lcFile = THIS.prepareFRXSwapCopy(JUSTPATH(THIS.targetFileName),.T.)
m.lcAlias = JUSTSTEM(m.lcFile)
* prepareFRXSwapCopy defines the file name suitably for the
* above JUSTSTEM() evaluation -&gt; alias to work all the time.
SELECT FRX
ENDIF
RETURN m.lcAlias
ENDPROC
PROCEDURE removefrxcopy
LPARAMETERS m.tcAlias
LOCAL m.lcFile
IF m.tcAlias # "FRX"
m.lcFile = DBF(m.tcAlias)
USE IN (m.tcAlias)
* streamlined in Sedna using
* new superclass feature
THIS.removeFRXSwapCopy(m.lcFile)
ENDIF

ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecNo, m.nLeft,m.nTop,m.nWidth,m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage

IF NOT ISNULL(THIS.successorGFXNoRender)
* XML Output and descendents respect norendering properties
* as successors, evaluating them individually since the conditions
* might apply only to some output types
IF THIS.successorGFXNoRender.applyFX(THIS,"RENDER",m.nFRXRecNo, m.nLeft) = ;
OUTPUTFX_BASERENDER_NORENDER
RETURN OUTPUTFX_BASERENDER_NORENDER
ENDIF
ENDIF

IF (DODEFAULT(m.nFRXRecNo, @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight, ;
@m.nObjectContinuationType, @m.cContentsToBeRendered, @m.GDIPlusImage) # ;
OUTPUTFX_BASERENDER_NORENDER) AND ;
THIS.InvokeOnCurrentPass() AND ;
THIS.Targethandle &gt; -1

* also evaluate THIS.IncludeBreaksInData and
* the band for the object in question.

* If the stars align, create the node for the object here.  For now:

LOCAL m.lcNode, m.loNode, m.lcFormattingInfo, m.lcContents,  ;
m.llTextType, m.loBandRef, m.liBandRecno, m.lcID

THIS.SetFRXDataSession()

GO m.nFRXRecNo IN FRX


m.lcContents = m.cContentsToBeRendered
m.llTextType = INLIST(FRX.ObjType,  FRX_OBJTYP_LABEL, FRX_OBJTYP_FIELD)
m.lcID = TRANSFORM(m.nFRXRecNo)
IF INLIST(m.nObjectContinuationType, ;
LISTENER_CONTINUATION_MIDDLE, ;
LISTENER_CONTINUATION_END)
m.lcID = m.lcID + "+"
ENDIF


IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION ;
OR (ISNULL(THIS.CurrentPage) AND ISNULL(THIS.CurrentColumn))
m.lcNode =   IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+FRX.ObjType,"Nodes","ObjType"), ;
Nodes.ObjValue,;
OUTPUTXML_GOOFTAG)

#IF OUTPUTXML = OUTPUTXML_RAW
m.lcFormattingInfo = THIS.GetRawFormattingInfo( m.nLeft, m.nTop, m.nWidth,m.nHeight, m.nObjectContinuationType)
THIS.setFRXDataSession()
IF m.llTextType
* build 1515: render gets unicode
m.lcContents = STRCONV(TRANSFORM(m.lcContents),STRCONV_UNICODE_UTF8)
ELSE
m.lcContents = TRANSFORM(m.lcContents)
ENDIF
DO CASE
CASE NOT ISNULL(THIS.CurrentPage)
THIS.CurrentPage = THIS.CurrentPage +  ;
THIS.XMLRawNode( ;
m.lcNode, ;
m.lcContents, ;
m.lcID,.F.,m.lcFormattingInfo) &amp;&amp; FRX.UniqueID
CASE NOT ISNULL(THIS.CurrentColumn)
THIS.CurrentColumn = THIS.CurrentColumn +  ;
THIS.XMLRawNode( ;
m.lcNode, ;
m.lcContents, ;
m.lcID,.F.,m.lcFormattingInfo)
OTHERWISE
* write directly to the stream
* First, take care of continuation.
IF EMPTY(NVL(THIS.CurrentBand,""))
* first object in a continued band
IF ISNULL(THIS.FRXCursor)
m.liBandRecno = 0
ELSE
m.loBandRef =  THIS.FRXCursor.GetBandFor(FRX.UniqueID, .T.,THIS.FRXDataSession)
SELECT FRX
LOCATE FOR UniqueID == loBandRef.UniqueID
IF EOF()
m.liBandRecno = 0
ELSE
m.liBandRecno = RECNO()
ENDIF
ENDIF
IF m.liBandRecno = 0
THIS.CurrentBand = THIS.XMLRawTag(OUTPUTXML_GOOFTAG, .T.,;
"0",TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo)) )
ELSE
THIS.SetCurrentDataSession()
THIS.BeforeBand(FRX_OBJCOD_DETAIL,m.liBandRecno, .T.)
THIS.SetFRXDataSession()
ENDIF
THIS.CurrentBand = THIS.CurrentBand + ;
THIS.XMLRawNode( ;
m.lcNode, ;
m.lcContents, ;
m.lcID,.F.,m.lcFormattingInfo)
IF EOF()
THIS.WriteRaw(THIS.CurrentBand + ;
THIS.XMLRawTag(OUTPUTXML_GOOFTAG))
THIS.CurrentBand = ""
ENDIF
GO m.nFRXRecNo IN FRX
ELSE
THIS.CurrentBand = THIS.CurrentBand + ;
THIS.XMLRawNode( ;
m.lcNode, ;
m.lcContents, ;
m.lcID,.F., m.lcFormattingInfo)
ENDIF

ENDCASE

#ELIF OUTPUTXML =  OUTPUTXML_DOTNET
* XMLTextWriter work
#ELSE
* if continuation type is of type 2 or 3
* and we're in a text type object
* we have to create a new
* continued band node as if a BeforeBand event has occurred.
THIS.setFRXDataSession()
IF ISNULL(THIS.CurrentBand)
* first object in a continued band
IF ISNULL(THIS.FRXcursor)
m.liBandRecno = 0
ELSE
m.loBandRef =  THIS.FRXCursor.GetBandFor(FRX.UniqueID, .T., THIS.FRXDataSession)
SELECT FRX
LOCATE FOR UniqueID == m.loBandRef.UniqueID
m.liBandRecno = RECNO()
ENDIF
THIS.SetCurrentDataSession()
IF EOF()
THIS.BeforeBand(FRX_OBJCOD_DETAIL,1, .T.)
ELSE
THIS.BeforeBand(FRX_OBJCOD_DETAIL,m.liBandRecno, .T.)
ENDIF
THIS.SetFRXDataSession()
GO m.nFRXRecNo IN FRX
ENDIF
m.loNode = THIS.CurrentDocument.CreateElement(m.lcNode)
m.lcContents = TRANSFORM(m.lcContents)
* build 1515: render gets unicode, and is already regionally transformed
* EXCEPT if it's a filename for an image, in which case it's DBCS
IF m.llTextType
m.loNode.Text = CREATEBINARY(m.lcContents)
ELSE
m.loNode.Text = m.lcContents
ENDIF
m.loNode.SetAttribute(THIS.IdAttribute,m.lcID)
THIS.SetDOMFormattingInfo( m.loNode, m.nLeft, m.nTop, m.nWidth,m.nHeight, m.nObjectContinuationType)
DO CASE
CASE NOT ISNULL(THIS.CurrentPage)
THIS.CurrentPage.AppendChild(m.loNode)
CASE NOT ISNULL(THIS.CurrentColumn)
THIS.CurrentColumn.AppendChild(m.loNode)
OTHERWISE
THIS.CurrentBand.AppendChild(m.loNode)
ENDCASE
m.loNode = NULL
#ENDIF
ELSE
* otherwise object belongs to a formatting header or footer
* and we're not processing them (XMLBREAKS_NONE)
ENDIF

THIS.resetDataSession()

ENDIF

RETURN
ENDPROC
PROCEDURE resetcallevaluatecontents
IF (THIS.CallEvaluateContents # LISTENER_CALLDYNAMICMETHOD_ALWAYS) AND ;
THIS.includeDataTypeAttributes AND ;
(THIS.xmlMode #  OUTPUTXML_RDL_ONLY)
THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
ENDIF
ENDPROC
PROCEDURE resetdocument
* Do *not* reset
* page number/total
THIS.ResetReport()
THIS.CloseTargetFile()
THIS.NoPageEject = .F.
IF THIS.HadError
THIS.ResetToDefault("QuietMode")
ENDIF
THIS.CurrentDocument = NULL




ENDPROC
PROCEDURE resetreport
THIS.IncludePage = .T.
THIS.IsRunning = .F.
THIS.DataNodes = NULL
THIS.PageNodes = NULL
THIS.ColumnNodes = NULL
THIS.CurrentBand = NULL
THIS.CurrentPage = NULL
THIS.CurrentColumn = NULL
THIS.evaluateContentsValues = NULL
THIS.successorGFXNoRender = NULL
THIS.ClearStatus()




ENDPROC
PROCEDURE resetruncollector
THIS.runCollector = NULL
ENDPROC
PROCEDURE runcollectorresetlevel_assign
LPARAMETERS tvNewVal
THIS.runCollectorResetLevel = OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT
ENDPROC
PROCEDURE setdomformattinginfo
LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType

m.toNode.SetAttribute(THIS.ContAttr,TRANSFORM(m.tnObjectContinuationType))
IF THIS.IncludeFormattingInLayoutObjects
m.toNode.SetAttribute(THIS.LeftAttr,TRANSFORM(m.tnLeft))
m.toNode.SetAttribute(THIS.TopAttr,TRANSFORM(m.tnTop))
m.toNode.SetAttribute(THIS.WidthAttr,TRANSFORM(m.tnWidth))
m.toNode.SetAttribute(THIS.HeightAttr,TRANSFORM(m.tnHeight))
ENDIF

LOCAL  m.llPageImages

THIS.setFRXDataSession()

m.llPageImages = (NOT EMPTY(THIS.currentPageImageFilename)) ;
AND USED(THIS.memberDataAlias)


IF THIS.includeDataTypeAttributes OR m.llPageImages

IF USED(THIS.FormattingChanges) AND ;
SEEK(RECNO("FRX"),THIS.FormattingChanges,"FRXRecno")
SELECT (THIS.FormattingChanges)
IF THIS.includeDataTypeAttributes
IF EMPTY(DText)
m.toNode.SetAttribute(THIS.dataTypeAttr,DType)
ELSE
m.toNode.SetAttribute(THIS.dataTypeAttr,DType)
m.toNode.SetAttribute(THIS.dataTextAttr,DText)
ENDIF
ENDIF
ENDIF
IF m.llPageImages AND SEEK(RECNO("FRX"),THIS.memberDataAlias,"FRXRecno")
SELECT (THIS.memberDataAlias)
LOCATE FOR FRXRecno = RECNO("FRX") AND ;
Type == FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
INLIST(UPPER(Execute),"YES",".T.","TRUE","1")
IF FOUND()
m.toNode.SetAttribute(THIS.pageImageAttr,;
THIS.currentPageImageFileName)
ENDIF
ENDIF
SELECT FRX
ENDIF



ENDPROC
PROCEDURE setfrxdatasessionenvironment
DODEFAULT()
SET EXACT ON
SET SYSFORMATS ON
SET CENTURY ON
SET SAFETY OFF
ENDPROC
PROCEDURE setfrxrunstartupconditions
DODEFAULT()
IF TYPE("THIS.CommandClauses.File") # "C"
ADDPROPERTY(THIS.CommandClauses,"File","")
ENDIF
IF TYPE("THIS.CommandClauses.NoPageEject") # "L"
ADDPROPERTY(THIS.CommandClauses,"NoPageEject",.F.)
ENDIF

ENDPROC
PROCEDURE synchxsltprocessoruser
IF THIS.applyUserTransform AND NOT ISNULL(THIS.XSLTProcessorUser)
THIS.XSLTProcessorUser = NULL
THIS.applyUserTransform = .T. &amp;&amp; kickstart
ENDIF
ENDPROC
PROCEDURE targetfileext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND ;
NOT UPPER(ALLTRIM(STRTRAN(m.vNewVal,".",""))) == "TMP"
DODEFAULT(m.vNewVal)
* this class reserves the extension
* TMP for swapping in and out when
* using temporary files and XLSTs transforms
ENDIF
ENDPROC
PROCEDURE topattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.topAttr = m.vNewVal
ENDIF

ENDPROC
PROCEDURE verifyattributenames
* abstract
ENDPROC
PROCEDURE verifyconfigtable
LPARAMETERS m.tcAlias

LOCAL m.llReturn, laRequired[1], m.liIndex, m.liSelect, ;
m.liTag, m.lcTag, m.lcIndex, m.llSafetyOn, m.llFixedOn

m.llReturn = DODEFAULT(m.tcAlias)

IF m.llReturn
* check for required tagnames (used in SEEKs)

m.liSelect = SELECT(0)
SELECT (m.tcAlias)

DIME laRequired[2,2]
laRequired[1,1] = "OBJTYPE"
laRequired[1,2] = "OBJTYPE"
laRequired[2,1] = "FRXNODES"
laRequired[2,2] = NORMALIZE("OBJTYPE+OBJCODE+IIF(OBJTYPE="+ ;
TRANSFORM(FRX_OBJTYP_BAND+OUTPUTXML_OBJTYPE_NODES,"9999999")+"," + ;
TRANSFORM(OUTPUTXML_OBJTYPE_BANDOFFSET,"9999999")+",0)")

FOR m.liIndex = 1 TO ALEN(laRequired,1)
m.liTag = TAGNO(laRequired[m.liIndex,1])
IF m.liTag = 0 OR NOT NORMALIZE(KEY(m.liTag)) == ;
laRequired[m.liIndex,2]
m.llReturn = .F.
ENDIF
ENDFOR

IF NOT m.llReturn
m.llSafetyOn = (SET("SAFETY") = "ON")
SET SAFETY OFF
m.llFixedOn = (SET("FIXED") = "ON")
SET FIXED OFF

TRY
USE (DBF(m.tcAlias)) EXCLU ALIAS (m.tcAlias)
FOR m.liIndex = 1 TO ALEN(laRequired,1)
m.lcTag = laRequired[m.liIndex,1]
m.lcIndex = laRequired[m.liIndex,2]
INDEX ON &amp;lcIndex TAG &amp;lcTag
ENDFOR

m.llReturn = .T.
CATCH
ENDTRY


IF m.llReturn
FOR m.liIndex = 1 TO ALEN(laRequired,1)
m.liTag = TAGNO(laRequired[m.liIndex,1])
IF m.liTag = 0 OR NOT NORMALIZE(KEY(m.liTag)) == ;
laRequired[m.liIndex,2]
m.llReturn = .F.
ENDIF
ENDFOR
ENDIF

USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)

IF m.llSafetyOn
SET SAFETY ON
ENDIF
IF m.llFixedOn
SET FIXED ON
ENDIF

ENDIF

IF NOT m.llReturn
m.lcMessage =  OUTPUTXML_CONFIGTAGMISSING_LOC + CHR(13)
FOR m.liIndex = 1 TO ALEN(laRequired,1)
m.lcMessage = m.lcMessage + ;
CHR(13) + laRequired[m.liIndex,1] + ;
"=" + laRequired[m.liIndex,2]
ENDFOR
THIS.DoMessage(m.lcMessage,MB_ICONSTOP )
THIS.lastErrorMessage = OUTPUTXML_CONFIGTAGMISSING_LOC
ENDIF

IF m.llReturn

* just do one check, this is in case
* a different listener created the config file.
* the XML will run just fine without these records,
* it will just use its gooftag instead of regular
* nodenames if all or any are missing

IF NOT SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
ALIAS(),"ObjType")
TRY
IF IsReadOnly()
USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)
ENDIF
THIS.InsertXMLConfigRecords()
CATCH
ENDTRY

ENDIF

ENDIF

SELECT (m.liSelect)

ENDIF

RETURN m.llReturn


ENDPROC
PROCEDURE verifyncname
LPARAMETERS m.tcName

LOCAL m.llValid, m.liChar, m.lcChar

DO CASE

CASE VARTYPE(m.tcName) # "C" OR EMPTY(m.tcName)
* invalid
CASE LEFT(m.tcName,1) # "_" AND NOT ISALPHA(LEFT(m.tcName,1))
* invalid
CASE LEFT(UPPER(m.tcName),3) = "XML"
* invalid
OTHERWISE
m.llValid = .T.
FOR m.liChar = 2 TO LEN(tcName)
m.lcChar = SUBSTR(m.tcName,m.liChar,1)
IF NOT (ISALPHA(m.lcChar) OR ;
ISDIGIT(m.lcChar) OR ;
INLIST(m.lcChar,".","-","_"))
m.llValid = .F.
EXIT
ENDIF
ENDFOR
ENDCASE

RETURN m.llValid
ENDPROC
PROCEDURE verifynodenames
IF NOT USED("Nodes")
RETURN .F.
ENDIF
IF ISREADONLY("Nodes")
RETURN .T.
ENDIF

LOCAL m.liSelect, m.llSuccess
m.liSelect = SELECT(0)
m.llSuccess = .T.
SELECT Nodes
SCAN FOR BETWEEN(ObjType,OUTPUTXML_OBJTYPE_NODES,OUTPUTXML_OBJTYPE_NODES+99) ;
AND NOT DELETED()
IF NOT THIS.VerifyNCName(ObjValue)
DELETE
m.llSuccess = .F.
ENDIF
ENDSCAN

SELECT (m.liSelect)
RETURN m.llSuccess
ENDPROC
PROCEDURE widthattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
THIS.widthAttr = m.vNewVal
ENDIF

ENDPROC
PROCEDURE writeraw
LPARAMETERS m.tcContents

FWRITE(THIS.TargetHandle, m.tcContents)

ENDPROC
PROCEDURE xmlmode_assign
LPARAMETERS m.vNewVal
* Readonly during report run
IF NOT THIS.IsRunning
IF VARTYPE(m.vNewVal) = "N" AND ;
INLIST(m.vNewVal,;
OUTPUTXML_DATA_ONLY,;
OUTPUTXML_RDL_ONLY, ;
OUTPUTXML_DATA_RDL)
THIS.xmlmode = m.vNewVal
ENDIF
ENDIF

ENDPROC
PROCEDURE xmlrawconv
LPARAMETERS m.tcValue
LOCAL m.lcValue, m.liChar
* must have ampersand as the first STRTRAN()
m.lcValue = STRTRAN(m.tcValue, '&amp;', '&amp;amp;' )
m.lcValue = STRTRAN(m.lcValue, '&lt;', '&amp;lt;' )
m.lcValue = STRTRAN(m.lcValue, '&gt;', '&amp;gt;' )
m.lcValue = STRTRAN(m.lcValue, '"', '&amp;quot;' )
m.lcValue = STRTRAN(m.lcValue, ['], '&amp;apos;' )
m.lcValue = CHRTRAN(m.lcValue, CHR(0)+CHR(4), "  ")
RETURN m.lcValue
* TBD: make any adjustments
* and, if needed, for different element types if needed

ENDPROC
PROCEDURE xmlrawnode
LPARAMETERS m.tcNode,m.tcValue, m.tvID, m.tvIDRef, m.tvFormatting
LOCAL m.lcValue, m.lcNode
IF PARAMETERS() &lt; 2
m.lcValue = ""
ELSE
m.lcValue = THIS.XMLRawConv(m.tcValue)
ENDIF
IF EMPTY(m.lcValue)
m.lcNode = THIS.XMLRawTag(m.tcNode,NULL, m.tvID, m.tvIDRef, m.tvFormatting)
ELSE
m.lcNode = THIS.XMLRawTag(m.tcNode, .T., m.tvID, m.tvIDRef, m.tvFormatting)+m.lcValue+THIS.XMLRawTag(m.tcNode)
ENDIF

RETURN m.lcNode

ENDPROC
PROCEDURE xmlrawtag
LPARAMETERS m.tcNode, m.tlOpen, m.tcID, m.tcIDRef, m.tvFormatting
LOCAL m.lcNode

IF ISNULL(m.tlOpen) OR m.tlOpen
m.lcNode = "&lt;" + m.tcNode
IF NOT EMPTY(m.tcID)
m.lcNode = m.lcNode + " "+THIS.idAttribute+"='"+m.tcID+"'"
ENDIF
IF NOT EMPTY(m.tcIDRef)
m.lcNode = m.lcNode + " "+THIS.idRefAttribute+"='"+m.tcIDRef+"'"
ENDIF
IF NOT EMPTY(m.tvFormatting)
m.lcNode = m.lcNode + " " + m.tvFormatting
ENDIF
IF ISNULL(m.tlOpen)
m.lcNode = m.lcNode +  "/"
ENDIF
m.lcNode = m.lcNode + "&gt;"
ELSE
m.lcNode = "&lt;/"+ m.tcNode + "&gt;"
ENDIF

RETURN m.lcNode
ENDPROC
PROCEDURE xsltparameters_assign
LPARAMETERS m.vNewVal
DO CASE
CASE VARTYPE(m.vNewVal) = "X"
THIS.XSLTParameters= NULL
CASE VARTYPE(m.vNewVal) = "O"
TRY
IF UPPER(m.vNewVal.BaseClass) == "COLLECTION"
THIS.XSLTParameters = m.vNewVal
ENDIF
CATCH
ENDTRY
OTHERWISE
THIS.XSLTParameters= NULL
ENDCASE






ENDPROC
PROCEDURE xsltprocessorrdl_assign
LPARAMETERS m.vNewVal
DO CASE
CASE VARTYPE(m.vNewVal) = "X"
THIS.XSLTProcessorRDL = NULL
CASE VARTYPE(m.vNewVal) = "O"
TRY
IF VARTYPE(m.vNewVal.stylesheet) = "O"
THIS.XSLTProcessorRDL = m.vNewVal
ENDIF
CATCH
ENDTRY
CASE VARTYPE(m.vNewVal) = "C"
LOCAL m.loProcessor
m.loProcessor = THIS.LoadProcessorObject(m.vNewVal)
IF NOT ISNULL(m.loProcessor)
THIS.XSLTProcessorRDL = m.loProcessor
ENDIF
ENDCASE



ENDPROC
PROCEDURE xsltprocessoruser_assign
LPARAMETERS m.vNewVal
DO CASE
CASE VARTYPE(m.vNewVal) = "X"
THIS.XSLTProcessorUser = NULL
CASE VARTYPE(m.vNewVal) = "O"
TRY
IF VARTYPE(m.vNewVal.stylesheet) = "O"
THIS.XSLTProcessorUser = m.vNewVal
ENDIF
CATCH
ENDTRY
CASE VARTYPE(m.vNewVal) = "C"
LOCAL m.loProcessor
m.loProcessor = THIS.LoadProcessorObject(m.vNewVal)
IF NOT ISNULL(m.loProcessor)
THIS.XSLTProcessorUser = m.loProcessor
ENDIF
ENDCASE



ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>xmlmode 0 = data only, 1 = RDL only, 2 = data and RDL
includebreaksindata 0 = provide page band nodes positioned along with other bands in the datastream, wherever they happen to occur, 1 = no pagebreak info, no page header and footer info, 2 = collection of pages with page headers and footers data
pagenodes Holds page-level output during a report run.
currentband Holds information about the band for which output is currently being generated during a report run.
currentdocument Holds information about the XML document for which output is currently being generated during a report run.
currentpage Holds information about the page for which output is currently being generated during a report run.
columnnodes Holds column-level output during a report run.
currentcolumn Holds information about the column for which output is currently being generated during a report run.
idattribute Supplies the name of the XML attribute used to provide the FRX record number for a layout object or page number of a formatting band (column or page) object.
idrefattribute Supplies the name of the XML attribute used to provide the current page for a layout object or FRX record number of a formatting band (column or page) object.
xsltprocessorrdl Holds an RDL-specific processor object, reserved for future use.
xsltprocessoruser Holds a user-definable processor object which, if filled and available at the end of a run, can be used automatically by XML Listener to transform the raw XML document to requirements.
datanodes Holds non-formatting output (title, detail, group, and summary band objects) during a report run.
includeformattinginlayoutobjects Indicates whether formatting information such as positioning attributes should be included in the report XML.
includebandswithnoobjects Indicates whether band-level information for bands with no contents should be included in the XML.
nopageeject Indicates whether the XML Listener should consider the current report run to be continued.  Can be used without NOPAGEEJECT on the REPORT FORM command.
topattr Supplies the name of the XML attribute used to show topmost position for a layout object.
leftattr Supplies the name of the XML attribute used to show leftmost position for a layout object.
heightattr Supplies the name of the XML attribute used to show height for a layout object.
widthattr Supplies the name of the XML attribute used to show width for a layout object.
contattr Supplies the name of the attribute used to show continuation type for a layout object that can span bands or pages.
includedatasourcesinvfprdl Indicates whether information about the source tables, relations, indexes, etc should be included in the VFPRDL metadata section of the report XML.
applyusertransform Indicates whether XMLListener should automatically apply an XSLT transform at the conclusion of a report run.
xsltparameters Holds an optional parameter collection passed to the ApplyXSLT method when XMLListener automatically  applies a user XSLT transformation at the conclusion of a report run.
includepage Evaluates whether the current page is part of the output page set and should be included in the XML document result.
includedatatypeattributes Indicates whether Data Type and Text information available in EvaluateContents should be included in the XML nodes generated for Field controls.
datatypeattr Supplies the name of the XML attribute used to show the datatype of the evaluated expression for a field control layout object.
datatextattr Supplies the name of the XML attribute used to show the TRANSFORM'd value of the evaluated expression for a field control layout object.
formattingchanges Reference in which classes can store information about actions taken to apply dynamic changes to layout controls' formatting attributes, for later use during Render event.
evaluatecontentsvalues An EMPTY object reference to hold changed formatting values during Rendering.
pageimageattr Supplies the name of the XML attribute used to show the filename for an associated generated page image file.
applyrdltransform Indicates whether an RDL-Only transformation is available and should be applied to XML output after an RDL-Only report run.
successorgfxnorender Private gfxNoRender object instance used for rendering checks specific to this output target when this reportListener is a Successor.
*xmlrawtag Used to formulate the contents of an XML tag when XML Listener is writing the XML document as raw data to a file.
*xmlrawnode Used to formulate the contents of an XML element  node when XML Listener is writing the XML document as raw data to a file.
*xmlrawconv Used to convert any control characters to entity references when XML Listener is writing raw XML data to a file.
*writeraw Used to write raw XML data to a file.
*includebreaksindata_assign 
*xmlmode_assign 
*resetreport Resets information for a report-level node during the production of an XML document that may span multiple reports.
*applyxslt Provides generic facilities for applying XSLT to XML.
*currentdocument_assign 
*idattribute_assign 
*idrefattribute_assign 
*xsltprocessorrdl_assign 
*xsltprocessoruser_assign 
*resetdocument Resets the XML document after a report run.
*verifyncname Generic method to validate strings as XML-standard NCNames.
*includeformattinginlayoutobjects_assign 
*includebandswithnoobjects_assign 
*verifynodenames Method called during XML Listener's augmented version of VerifyConfigTable to check all node values in the configuration table for XML validity.
*verifyattributenames Hook method called during XML Listener's augmented version of VerifyConfigTable, allowing subclasses to verify attribute names should they decide to store them in the configuration table similar to node names.
*nopageeject_assign 
*loadprocessorobject Provides a generic means to load an XSLT processor object from a string representing an XSLT document or a filename.
*getrawformattinginfo Formulates the appropriate formatting attributes for an element when XMLListener is streaming XML to a file.
*topattr_assign 
*leftattr_assign 
*heightattr_assign 
*widthattr_assign 
*contattr_assign 
*getvfprdlcontents Translates report definition layout metadata, from the FRX and the current report run, into an XML format useful to other applications.
*includedatasourcesinvfprdl_assign 
*getpathedimageinfo Supplies a fully-pathed filename for an image file included in the report, using the original relative-path information stored in the FRX.
*applyusertransformtooutput Applies a user-specified XSLT to XML output at the conclusion of a report run.
*applyusertransform_assign 
*getdefaultuserxslt Provides a hook for subclasses to supply their preferred XSLT document for use when XMLListener automatically applies XSLT at the end of a report run.
*setdomformattinginfo Formulates the appropriate formatting attributes for an element when XMLListener is using the DOM to create XML.
*synchxsltprocessoruser Can be called in the assign of any Attribute-setting property to synchronize the XSLT associated with the class witht he new attribute values.
*insertxmlconfigrecords Adds a record to the configuration table describing a default XML node when XML Listener is creating or editing a shared configuration table.
*xsltparameters_assign 
*getfrxlayoutobjectfieldlist Provides fields list to the getVFPRdlContents method, in a suitable comma-delimited format for inclusion as a macro in SQL SELECT statement from FRX cursor and related Bands and Objects cursors.
*preparefrxcopy Prepares FRX alias or copy for use in creating VFP-RDL contents.
*removefrxcopy Removes FRX copy used in preparing VFP-RDL.
*adjustxsltparameter Adds, changes, or removes a parameter in the XSLT Parameter Collection, creating the collection if necessary. Params: tvValue, tsKey, tlRemoveOnly.
*getrunnodecontents Translates information dynamically generated and provided in the runCollector member into an XML format useful to other applications.
*addrunnode Adds a node to the Run portion of the XML document, looking for value results in both FRX and Report Run (Current) Data sessions.
*includedatatypeattributes_assign 
*datatypeattr_assign 
*datatextattr_assign 
*initializeformattingchangescursor Evaluates requirements for a cursor to hold information gathered for Field layout controls during this report run and creates it if necessary.
*formatdatavalue Provides opportunity to re-format data value delivered in EvaluateContents appropriately for text/TRANSFORM'd version.
*pageimageattr_assign 
*evaluatestringtoboolean Casts a string to .T. or .F..
*applyrdltransform_access 
*fixmsxmlobjectfordtds Adjust MSXML document objects to load XML with embedded DTDs properly.
*frxcharsetsinuse Determine whether the FRX for a report run has layout elements with explicit charset instructions.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides XML output from a report run.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>xmllistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_19G1CFR95</uniqueid>
		<timestamp>914864803</timestamp>
		<class>xmldisplaylistener</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>reportlistener</baseclass>
		<objname>htmllistener</objname>
		<parent/>
		<properties>ListenerType = 2
FRXDataSession = -1
cssclassattr = ("css")
anchorattr = ("anchor")
titleattr = ("title")
linkattr = ("hlink")
cssclassoverrideattr = ("CSS")
oldpageimagetype = -1
oldtextareasetting = -1
applyusertransform = .T.
targetfileext = ("HTM")
_memberdata =     1855&lt;VFPData&gt; &lt;memberdata name="imagefieldinstance" type="property" display="imageFieldInstance" favorites="False" /&gt; &lt;memberdata name="imagefieldtofile" type="property" display="imageFieldToFile" favorites="False" /&gt; &lt;memberdata name="imagefilebasename" type="property" display="imageFileBaseName" favorites="True" /&gt; &lt;memberdata name="imagesrcattr" type="property" display="imageSrcAttr" favorites="True" /&gt; &lt;memberdata name="jpgclsid" type="property" display="JPGclsid" favorites="False" /&gt; &lt;memberdata name="oldexternalfilelocation" type="property" display="oldExternalFileLocation" favorites="False" /&gt; &lt;memberdata name="oldsendgdiplusimage" type="property" display="oldSendGDIPlusImage" favorites="False" /&gt; &lt;memberdata name="checkreportforgeneralfields" type="method" display="checkReportForGeneralFields" favorites="False" /&gt;&lt;memberdata name="getdefaultuserxsltasstring" type="method" display="getDefaultUserXsltAsString" favorites="False" /&gt;&lt;memberdata name="initializefilecopysettings" type="method" display="initializeFileCopySettings" favorites="False"/&gt;&lt;memberdata name="titleattr" display="titleAttr" type="property" favorites="True"/&gt;&lt;memberdata name="linkattr" display="linkAttr" type="property" favorites="True"/&gt;&lt;memberdata name="cssclassattr" display="cssClassAttr" type="property" favorites="True"/&gt;&lt;memberdata name="cssclassoverrideattr" display="cssClassOverrideAttr" type="property" favorites="True"/&gt;&lt;memberdata name="anchorattr" display="anchorAttr" type="property" favorites="True"/&gt;&lt;memberdata name="oldpageimagetype" display="oldPageImageType" type="property"/&gt;&lt;memberdata name="oldtextareasetting" display="oldTextAreaSetting" type="property"/&gt;&lt;memberdata name="urlstringencode" type="method" favorites="True" display="urlStringEncode"/&gt;&lt;memberdata name="pathencode" type="method" favorites="True" display="pathEncode"/&gt;&lt;/VFPData&gt;
Name = "htmllistener"
</properties>
		<protected>oldpageimagetype
oldtextareasetting
getdefaultuserxsltasstring
</protected>
		<methods>PROCEDURE AfterReport
LPARAMETERS tlCalledEarly
DODEFAULT(tlCalledEarly)
IF THIS.oldPageImageType &lt;&gt; -1
THIS.pageImageType = THIS.oldPageImageType
ENDIF
THIS.resetDataSession()
ENDPROC
PROCEDURE anchorattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
AND NOT (m.vNewVal == THIS.anchorAttr)
THIS.anchorAttr = m.vNewVal
THIS.SynchXSLTProcessorUser()
ENDIF





ENDPROC
PROCEDURE applyusertransformtooutput
DODEFAULT()
IF THIS.oldTextAreaSetting &lt;&gt; -1
THIS.adjustXSLTParameter( THIS.oldTextAreaSetting,"useTextAreaForStretchingText")
THIS.oldTextAreaSetting = -1
ENDIF

ENDPROC
PROCEDURE BeforeReport
DODEFAULT()

THIS.oldPageImageType = -1

IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
LOCAL llSetting, liSelect
THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias)
m.liSelect = SELECT(0)
SELECT (THIS.memberDataAlias)
LOCATE FOR Type == FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
THIS.evaluateStringToBoolean(Execute)
IF FOUND() AND THIS.pageImageType = 0
THIS.oldPageImageType = 0
THIS.pageImageType =  OUTPUTHTML_DEFAULT_PAGEIMAGE_TYPE
IF THIS.ListenerType = LISTENER_TYPE_DEF
THIS.ListenerType = LISTENER_TYPE_PAGED
ENDIF
IF THIS.supportsPageImages()
THIS.makeExternalFileLocationReachable()
ELSE
IF NOT THIS.IsSuccessor
THIS.pageImageType =  0
ENDIF
ENDIF
ENDIF
IF NOT THIS.CommandClauses.NoPageEject
* we can only make this adjustment once per chain,
* since it can only be applied once per chain.
* Last one wins.
LOCATE FOR Type == FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen == FRX_BLDR_ADVPROP_HTML_TEXTAREAS_OFF
IF FOUND()
llSetting = THIS.evaluateStringToBoolean(Execute)
IF VARTYPE(THIS.xsltParameters) = "O" AND ;
THIS.xsltParameters.GetKey("useTextAreaForStretchingText") &gt; 0
THIS.oldTextAreaSetting = THIS.xsltParameters["useTextAreaForStretchingText"]
ELSE
THIS.oldTextAreaSetting = 1
ENDIF
THIS.adjustXSLTParameter( ;
IIF(llSetting,0,1),"useTextAreaForStretchingText")
ENDIF
ENDIF
ENDIF
ENDIF
THIS.resetDataSession()
ENDPROC
PROCEDURE cssclassattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
AND NOT (m.vNewVal == THIS.cssClassAttr)
THIS.cssClassAttr = m.vNewVal
THIS.SynchXSLTProcessorUser()
ENDIF






ENDPROC
PROCEDURE cssclassoverrideattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
AND NOT (m.vNewVal == THIS.cssClassOverrideAttr)
THIS.cssClassOverrideAttr = m.vNewVal
THIS.SynchXSLTProcessorUser()
ENDIF






ENDPROC
PROCEDURE fillruncollector
DODEFAULT()
IF NOT ISNULL(THIS.runCollector)
* should have been taken care of by superclass
THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias)
LOCAL m.lvValue, m.lcExpr, m.liSelect, m.loXML, m.loXMLTemp, m.loNode
IF USED("FRX")
GO (THIS.frxHeaderRecno) IN FRX
#IF OUTPUTXML = OUTPUTXML_DOM
m.loXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
m.loXMLTemp = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
#ELSE
m.loXML = CREATEOBJECT("Microsoft.XMLDOM")
m.loXMLTemp = CREATEOBJECT("Microsoft.XMLDOM")
#ENDIF
IF NOT m.loXML.LoadXML(FRX.Style)
m.loXML = NULL
ENDIF
ENDIF
IF NOT ISNULL(m.loXML)
m.liSelect = SELECT(0)
SELECT (THIS.memberDataAlias)
LOCATE FOR FRXRecno = THIS.frxHeaderRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  ;
AND Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS ;
AND ExecWhen == FRX_BLDR_ADVPROP_HTML_HTTPEQUIV ;
AND VAL(DeClass) = ADVPROP_EDITMODE_TEXT ;
AND NOT EMPTY(Execute)
IF FOUND()
m.lvValue = ;
m.loXML.SelectSingleNode("/VFPData/reportdata" + ;
"[@name='" + Name + "' and @execwhen='" + ;
FRX_BLDR_ADVPROP_HTML_HTTPEQUIV + "']/@execute")
IF (NOT ISNULL(m.lvValue)) AND ;
m.loXMLTemp.LoadXML(m.lvValue.Text)
m.loXML = m.loXMLTemp.SelectNodes("//meta")
FOR EACH m.loNode IN m.loXML
m.lcExpr = m.loNode.getAttribute("name")
m.lvValue = m.loNode.getAttribute("content")
IF NOT (ISNULL(m.lcExpr) OR ISNULL(m.lvValue) OR ;
EMPTY(m.lcExpr) OR EMPTY(m.lvValue))
IF VAL(m.loNode.getAttribute("type")) = ADVPROP_EDITMODE_GETEXPR
m.lvValue = THIS.evaluateUserExpression(m.lvValue)
ENDIF
IF THIS.runCollector.getKey(FRX_BLDR_ADVPROP_HTML_HTTPEQUIV+"." + m.lcExpr) = 0
THIS.runCollector.add(m.lvValue,FRX_BLDR_ADVPROP_HTML_HTTPEQUIV+"." + m.lcExpr)
ENDIF
ENDIF
NEXT
ENDIF
ENDIF
STORE NULL  TO m.loXML, m.loXMLTemp, m.loNode
SELECT (liSelect)
ENDIF
ENDIF
ENDIF

ENDPROC
PROCEDURE getdefaultuserxslt
LOCAL m.lcResult
m.lcResult = THIS.getDefaultUserXSLTAsString()

* document properties, general
m.lcResult = STRTRAN(m.lcResult,"@id='description'","@id='"+FRX_BLDR_ADVPROP_DESCRIPTION+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='author'","@id='"+FRX_BLDR_ADVPROP_AUTHOR+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='keywords'","@id='"+FRX_BLDR_ADVPROP_KEYWORDS+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='title'","@id='"+FRX_BLDR_ADVPROP_TITLE+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='copyright'","@id='"+FRX_BLDR_ADVPROP_COPYRIGHT+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='date'","@id='"+FRX_BLDR_ADVPROP_DATE+"'")

* document properties, HTML-specific
m.lcResult = STRTRAN(m.lcResult,"@id='css_sheet'","@id='"+FRX_BLDR_ADVPROP_HTML_CSS_FILE +"'")
m.lcResult = STRTRAN(m.lcResult,"@id='http-equiv'","@id='"+FRX_BLDR_ADVPROP_HTML_HTTPEQUIV  +"'")

* base VFP-RDL XML characteristics set
m.lcResult = STRTRAN(m.lcResult,"@h","@"+ THIS.HeightAttr)
m.lcResult = STRTRAN(m.lcResult,"@w","@"+ THIS.WidthAttr)
m.lcResult = STRTRAN(m.lcResult,"@l","@"+ THIS.LeftAttr)
m.lcResult = STRTRAN(m.lcResult,"@t","@"+ THIS.TopAttr)
m.lcResult = STRTRAN(m.lcResult,"@c","@"+ THIS.ContAttr)
m.lcResult = STRTRAN(m.lcResult,"@idref","@"+ THIS.IdRefAttribute)
m.lcResult = STRTRAN(m.lcResult,"@id","@"+THIS.IdAttribute)
m.lcResult = STRTRAN(m.lcResult,"@img","@"+THIS.imageSrcAttr )

* dynamic data and page-image extension set implemented in XMLListener
m.lcResult = STRTRAN(m.lcResult,"@DTEXT","@"+THIS.dataTextAttr  )
m.lcResult = STRTRAN(m.lcResult,"@DTYPE","@"+THIS.dataTypeAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PLINK","@"+THIS.pageImageAttr  )

* dynamic formatting extension set implemented in XMLDisplayListener
m.lcResult = STRTRAN(m.lcResult,"@PA","@"+THIS.penAlphaAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PR","@"+THIS.penRedAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PG","@"+THIS.penGreenAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PB","@"+THIS.penBlueAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FA","@"+THIS.fillAlphaAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FR","@"+THIS.fillRedAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FG","@"+THIS.fillGreenAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FB","@"+THIS.fillBlueAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FNAME","@"+THIS.fontNameAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FSIZE","@"+THIS.fontSizeAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FSTYLE","@"+THIS.fontStyleAttr  )

* dynamic HTML extension set implemented in this class
m.lcResult = STRTRAN(m.lcResult,"@title","@"+THIS.titleAttr )
m.lcResult = STRTRAN(m.lcResult,"@alt","@"+THIS.titleAttr )
m.lcResult = STRTRAN(m.lcResult,"@css","@"+THIS.cssClassAttr )
m.lcResult = STRTRAN(m.lcResult,"@CSS","@"+THIS.cssClassOverrideAttr )
m.lcResult = STRTRAN(m.lcResult,"@anchor","@"+THIS.anchorAttr )
m.lcResult = STRTRAN(m.lcResult,"@hlink","@"+THIS.linkAttr )

THIS.XSLTProcessorUser = m.lcResult



ENDPROC
PROCEDURE getdefaultuserxsltasstring
LOCAL m.lcResult
SET TEXTMERGE TO MEMVAR m.lcResult NOSHOW
SET TEXTMERGE ON
TEXT
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="no" doctype-public="-//W3C//DTD HTML 4.0//EN" doctype-system="http://www.w3.org/TR/REC-html40/strict.dtd"/&gt;

&lt;xsl:param name="externalFileLocation"/&gt;
&lt;!--select="'./whatever/'" or 'http://something/myimages/' or "'./'" or... --&gt;
&lt;xsl:param name="copyImageFiles" select="0"/&gt;
&lt;xsl:param name="generalFieldDPI" select="96"/&gt;
&lt;xsl:param name="fillPatternShade" select="180*3"/&gt;
&lt;xsl:param name="fillPatternOffset" select="128"/&gt;
&lt;xsl:param name="numberPrecision" select="5"/&gt;
&lt;xsl:param name="fieldAlphaOpacityOffset" select="75"/&gt;
&lt;xsl:param name="fieldAlphaOpacityShade" select="180*3"/&gt;
&lt;xsl:param name="useTextAreaForStretchingText" select="1"/&gt;
&lt;xsl:param name="hideScrollbarsForTextAreas" select="0"/&gt;
&lt;xsl:param name="PageTitlePrefix_LOC" select="''"/&gt;
&lt;!--    &lt;xsl:param name="unpagedModeIncludesOnePageHeader" select="0"/&gt; --&gt;
&lt;xsl:param name="unpagedModeIncludesTitle" select="1"/&gt;
&lt;xsl:param name="noBody" select="0"/&gt;
&lt;xsl:param name="useDynamicTextAttributes" select="1"/&gt;
&lt;xsl:param name="anchorAttrName" select="1"/&gt;
&lt;!-- id is theoretically better if you wanted to write
script against this element, or in case name is
deprecated in a future version of the standard,
but a value of 1 forces name to be used instead.
Current-newer browsers will be okay with this, and older
browsers might prefer it. --&gt;
&lt;xsl:variable name="FRUs" select="10000"/&gt;
&lt;xsl:variable name="printDPI" select="960"/&gt;
&lt;xsl:variable name="FRUsInPixelsat96DPI" select="104.167"/&gt;
&lt;xsl:variable name="imagePixelRatio" select="$generalFieldDPI div $printDPI"/&gt;
&lt;xsl:variable name="zeros" select="substring('0000000000000000000000000',1,$numberPrecision)"/&gt;
&lt;xsl:variable name="thisPageHeight"&gt;
&lt;xsl:value-of select="number(/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@pageheight  div $printDPI)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="lineNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=6]/name"/&gt;
&lt;xsl:variable name="labelNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=5]/name"/&gt;
&lt;xsl:variable name="fieldNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=8]/name"/&gt;
&lt;xsl:variable name="shapeNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=7]/name"/&gt;
&lt;xsl:variable name="pictureNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=17]/name"/&gt;
&lt;xsl:variable name="detailNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=4]/name"/&gt;
&lt;xsl:variable name="detailHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=9]/name"/&gt;
&lt;xsl:variable name="detailFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=10]/name"/&gt;
&lt;xsl:variable name="pageHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=1]/name"/&gt;
&lt;xsl:variable name="pageFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=7]/name"/&gt;
&lt;xsl:variable name="columnHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=2]/name"/&gt;
&lt;xsl:variable name="columnFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=6]/name"/&gt;
&lt;xsl:variable name="groupHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=3]/name"/&gt;
&lt;xsl:variable name="groupFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=5]/name"/&gt;
&lt;xsl:variable name="titleNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=0]/name"/&gt;
&lt;xsl:variable name="summaryNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=8]/name"/&gt;
&lt;xsl:variable name="anchorAttr"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="$anchorAttrName=1"&gt;name&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;id&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;


&lt;xsl:key name="Layout" match="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[platform='WINDOWS']" use="concat(frxrecno,../../@id)"/&gt;


&lt;xsl:template match="/"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="number($noBody)=1"&gt;
&lt;div&gt;
&lt;meta http-equiv="Content-Type"  content="text/html; charset=UTF-8"/&gt;
&lt;xsl:call-template name="renderStyles"/&gt;
&lt;xsl:call-template name="body"/&gt;
&lt;/div&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:apply-templates select="/" mode="full"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="/" mode="full"&gt;
&lt;html&gt;
&lt;xsl:if test="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=1 and (fontcharset=177 or fontcharset=178)]"&gt;
&lt;xsl:attribute name="dir"&gt;rtl&lt;/xsl:attribute&gt;
&lt;/xsl:if&gt;
&lt;head&gt;
&lt;meta  http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;
&lt;xsl:comment&gt;
the above repeated-explicit declaration is necessary because
some versions of MSXML xslt processing don't include the
charset as required by the XSLT standard when method="html".
Explicitly including the META creates a doubled meta content-type tag,
but we do need the encoding to be specified properly and the doubled tag is okay.
&lt;/xsl:comment&gt;
&lt;meta name="description"
content="{/Reports/VFP-Report[1]/Run/property[@id='description']/.}"/&gt;
&lt;meta name="author"
content="{/Reports/VFP-Report[1]/Run/property[@id='author']/.}"/&gt;
&lt;meta name="copyright"
content="{/Reports/VFP-Report[1]/Run/property[@id='copyright']/.}"/&gt;
&lt;meta name="date"
content="{/Reports/VFP-Report[1]/Run/property[@id='date']/.}"/&gt;
&lt;xsl:if test="/Reports/VFP-Report/Run/property[@id='keywords']"&gt;
&lt;meta name="keywords"&gt;
&lt;xsl:attribute name="content"&gt;
&lt;xsl:for-each select="/Reports/VFP-Report/Run/property[@id='keywords']"&gt;
&lt;xsl:value-of select="."/&gt;&lt;xsl:if test="not(position()=last())"&gt;,&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:attribute&gt;
&lt;/meta&gt;
&lt;/xsl:if&gt;
&lt;xsl:if test="/Reports/VFP-Report/Run/property[@id='http-equiv']"&gt;
&lt;xsl:for-each select="/Reports/VFP-Report/Run/property[@id='http-equiv']//meta"&gt;
&lt;xsl:variable name="thisMeta" select="concat(ancestor-or-self::*[@id='http-equiv']/@id ,'.',@name)"/&gt;
&lt;!-- the extra Run nodes being looked up are potentially evaluated, not original values of the property,
so we can account for expressions --&gt;
&lt;meta  http-equiv="{@name}" content="{/Reports/VFP-Report/Run/property[@id=$thisMeta]}"/&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:if&gt;

&lt;title&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="/Reports/VFP-Report[1]/Run/property[@id='title']"&gt;
&lt;xsl:value-of select="/Reports/VFP-Report[1]/Run/property[@id='title']/."/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;!-- default/VFP 9.0 RTM handling --&gt;
&lt;xsl:value-of select="$PageTitlePrefix_LOC"/&gt;
&lt;xsl:if test="string-length(/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@name) = 0"&gt;
&lt;xsl:value-of select="/Reports/VFP-Report[1]/VFP-RDL/@id"/&gt;
&lt;/xsl:if&gt;
&lt;xsl:value-of select="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@name"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/title&gt;
&lt;xsl:call-template name="renderStyles"/&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;xsl:call-template name="body"/&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="renderStyles"&gt;
&lt;xsl:call-template name="DocumentStyles"/&gt;
&lt;xsl:for-each select="/Reports/VFP-Report"&gt;
&lt;xsl:call-template name="Styles"&gt;
&lt;xsl:with-param name="thisReport" select="position()"/&gt;
&lt;xsl:with-param name="thisReportID" select="./VFP-RDL/@id"/&gt;
&lt;/xsl:call-template&gt;
&lt;!--        &lt;xsl:call-template name="Script"/&gt; avoid security problems: no script, not even a lone comment indicating TBD --&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="body"&gt;
&lt;xsl:for-each select="/Reports/VFP-Report"&gt;
&lt;xsl:variable name="thisReport" select="position()"/&gt;
&lt;xsl:variable name="thisReportID" select="./VFP-RDL/@id"/&gt;
&lt;xsl:variable name="thisReportRangeFrom" select="number(./VFP-RDL/VFPDataSet/VFPFRXCommand/@RANGEFROM)"/&gt;
&lt;xsl:variable name="separateTitlePage" select="./Data/*[name()=$titleNodeName] and ./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='0' and pagebreak='true']"/&gt;
&lt;xsl:variable name="separateSummaryPage" select="./Data/*[name()=$summaryNodeName] and ./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='8' and pagebreak='true' and ejectbefor='false']"/&gt;
&lt;xsl:variable name="reportPages" select="count(./Data/*[(name()=$pageHeaderNodeName) or (name()=$titleNodeName and $separateTitlePage=true()) or  (name()=$summaryNodeName and $separateSummaryPage=true())])"/&gt;
&lt;div&gt;
&lt;xsl:if test="number($noBody)=1"&gt;
&lt;xsl:attribute name="style"&gt;
position=relative;height=&lt;xsl:value-of select="$reportPages * $thisPageHeight"/&gt;in;
&lt;/xsl:attribute&gt;
&lt;/xsl:if&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="./Data/*[name() = $pageHeaderNodeName]"&gt;
&lt;xsl:if test="$separateTitlePage"&gt;
&lt;xsl:apply-templates select="./Data/*[name()=$titleNodeName]" mode="titlesummarypage"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;xsl:apply-templates select="./Data/*[name()=$pageHeaderNodeName]" mode="page"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisReportRangeFrom" select="$thisReportRangeFrom"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;xsl:if test="$separateSummaryPage"&gt;
&lt;xsl:apply-templates select="./Data/*[name()=$summaryNodeName]" mode="titlesummarypage"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;!-- unpaginated--&gt;
&lt;xsl:variable name="thisPageHeaderHeight" select="/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header'][1]/height  div $FRUs"/&gt;
&lt;xsl:variable name="thisReportPageHeight" select="number($thisPageHeight - ( $thisPageHeaderHeight +  (/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Footer'][1]/height div $FRUs)) )"/&gt;
&lt;xsl:if test="./Data/Pages/*[name() = $pageHeaderNodeName]"&gt; &lt;!-- $unpagedModeIncludesOnePageHeader=1" --&gt;
&lt;!-- show the contents of the first page header --&gt;
&lt;xsl:apply-templates mode="formattingBand" select="./Data/Pages/*[@idref = /Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header']/frxrecno][1]"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisReportPageHeight" select="$thisReportPageHeight"/&gt;
&lt;xsl:with-param name="thisPageHeight" select="$thisPageHeight"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;

&lt;!-- the @id criteria below leaves out the Pages and Columns collections, if any --&gt;
&lt;!-- we could add in an initial page header but then we'd have to do the additional work to handle any title, etc; all the height offsets will change --&gt;
&lt;xsl:apply-templates select="./Data/*[@idref and ($unpagedModeIncludesTitle=1 or not(name() = $titleNodeName))]" mode="unpagedBand"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisPageHeight" select="$thisPageHeight"/&gt;
&lt;xsl:with-param name="thisReportPageHeight" select="$thisReportPageHeight"/&gt;
&lt;xsl:with-param name="thisPageHeaderHeight" select="$thisPageHeaderHeight"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/div&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="/Reports/VFP-Report/Data/*" mode="titlesummarypage"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:param name="thisReportRangeFrom" select="1"/&gt;
&lt;xsl:variable name="thisBand" select="@id"/&gt;
&lt;div&gt;
&lt;xsl:attribute name="style"&gt; width:100%;top:&lt;xsl:value-of select="$thisPageHeight * (number( ./@idref) -$thisReportRangeFrom)"/&gt;in; position:absolute; &lt;/xsl:attribute&gt;
&lt;xsl:apply-templates select="." mode="band"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;xsl:if test="/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[frxrecno=$thisBand and ejectafter='true']"&gt;
&lt;!-- page footer for this summary page --&gt;
&lt;xsl:apply-templates select="/Reports/VFP-Report[$thisReport]/Data/*[name()=$pageFooterNodeName][position()=last()]" mode="band"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="/Reports/VFP-Report/Data/*" mode="page"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:param name="thisReportRangeFrom" select="1"/&gt;
&lt;xsl:variable name="thisPage" select="@id"/&gt;
&lt;div&gt;
&lt;xsl:attribute name="style"&gt; width:100%;top:&lt;xsl:value-of select="$thisPageHeight * ($thisPage -$thisReportRangeFrom)"/&gt;in;position:absolute; &lt;/xsl:attribute&gt;
&lt;xsl:apply-templates select="." mode="band"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;xsl:if test="$thisPage = 1 and /Reports/VFP-Report[$thisReport]/Data/*[name()=$titleNodeName] and /Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='0' and pagebreak='false']"&gt;
&lt;xsl:apply-templates select="/Reports/VFP-Report[$thisReport]/Data/*[name()=$titleNodeName]" mode="band"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;xsl:apply-templates select="/Reports/VFP-Report/Data/*[( (@id=$thisPage and contains(concat('|',$pageFooterNodeName,'|',$columnHeaderNodeName,'|',$columnFooterNodeName,'|'),concat('|',name(),'|'))) or (@idref=$thisPage and contains(concat('|',$detailHeaderNodeName,'|',$detailFooterNodeName,'|',$detailNodeName,'|',$groupHeaderNodeName,'|',$groupFooterNodeName,'|',$summaryNodeName,'|'),concat('|',name(),'|'))) )]" mode="band"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="/Reports/VFP-Report/Data/Pages/*" mode="formattingBand"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:param name="thisPageHeight"/&gt;
&lt;xsl:param name="thisReportPageHeight"/&gt;
&lt;xsl:variable name="thisPage" select="@id"/&gt;
&lt;xsl:variable name="thisPageRenderOffset" select="(($thisPage - 1) * $thisReportPageHeight)  + sum((/Reports/VFP-Report[position() &amp;lt; $thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header']/height) ) "/&gt;
&lt;xsl:for-each select="./*"&gt;
&lt;xsl:variable name="thisID" select="translate(@id,'+','')"/&gt;
&lt;xsl:call-template name="Render"&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;xsl:with-param name="thisZ" select="position()"/&gt;
&lt;xsl:with-param name="thisPage" select="../@idref"/&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="topOffset" select="number($thisPageRenderOffset) * $printDPI"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="/Reports/VFP-Report/Data/*" mode="unpagedBand"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:param name="thisPageHeight"/&gt;
&lt;xsl:param name="thisReportPageHeight"/&gt;
&lt;xsl:param name="thisPageHeaderHeight"/&gt;
&lt;xsl:variable name="thisPage" select="@idref"/&gt;
&lt;xsl:variable name="thisPageRenderOffset"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="../Pages/*[name() = $pageHeaderNodeName]"&gt; &lt;!-- $unpagedModeIncludesOnePageHeader=1" --&gt;
&lt;xsl:value-of select="(($thisPage - 1) * $thisReportPageHeight) + (sum(/Reports/VFP-Report[position() &amp;lt; $thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header'][1]/height)div $FRUs)  + $thisPageHeaderHeight "/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select="(($thisPage - 1) * $thisReportPageHeight) -($thisPageHeaderHeight*$thisPage)  "/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;
&lt;xsl:call-template name="addAnchor"/&gt;
&lt;xsl:for-each select="./*"&gt;
&lt;xsl:variable name="thisID" select="translate(@id,'+','')"/&gt;
&lt;xsl:call-template name="Render"&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;xsl:with-param name="thisZ" select="position()"/&gt;
&lt;xsl:with-param name="thisPage" select="../@idref"/&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="topOffset" select="number($thisPageRenderOffset) * $printDPI"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/Reports/VFP-Report/Data/*" mode="band"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:call-template name="addAnchor"/&gt;
&lt;xsl:for-each select="./*"&gt;
&lt;xsl:variable name="thisID" select="translate(@id,'+','')"/&gt;
&lt;!--        &lt;xsl:if test="key('Layout',concat($thisID, $thisReportID))/vpos &amp;gt; key('Layout',preceding-sibling::*/concat(@id,$thisReportID))/vpos"&gt;&lt;div style="position=absolute;"/&gt;&lt;/xsl:if&gt;  --&gt;
&lt;xsl:call-template name="Render"&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;xsl:with-param name="thisZ" select="position()"/&gt;
&lt;xsl:with-param name="thisPage" select="../@idref"/&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="Render"&gt;
&lt;xsl:param name="thisID"/&gt;
&lt;xsl:param name="thisZ"/&gt;
&lt;xsl:param name="thisPage"/&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisReportID" select="1"/&gt;
&lt;xsl:param name="topOffset" select="0"/&gt;
&lt;xsl:call-template name="addAnchor"/&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="name()=$lineNodeName and key('Layout',concat($thisID, $thisReportID))/height &amp;lt;  key('Layout',concat($thisID, $thisReportID))/width"&gt;
&lt;hr&gt;
&lt;xsl:call-template name="addClassAttribute"&gt;
&lt;xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="addTitleAttribute"/&gt;
&lt;xsl:call-template name="addStyleAttribute"&gt;
&lt;xsl:with-param name="topOffset" select="$topOffset"/&gt;
&lt;xsl:with-param name="thisZ" select="$thisZ"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;xsl:with-param name="styleType" select="'HR'"/&gt;
&lt;/xsl:call-template&gt;
&lt;/hr&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="name()=$lineNodeName"&gt;
&lt;!-- vertical line --&gt;
&lt;span&gt;
&lt;xsl:call-template name="addClassAttribute"&gt;
&lt;xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="addTitleAttribute"/&gt;
&lt;xsl:call-template name="addStyleAttribute"&gt;
&lt;xsl:with-param name="topOffset" select="$topOffset"/&gt;
&lt;xsl:with-param name="thisZ" select="$thisZ"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;xsl:with-param name="styleType" select="'VR'"/&gt;
&lt;/xsl:call-template&gt;
&lt;/span&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="$useTextAreaForStretchingText=1 and string-length(@hlink) = 0  and name()=$fieldNodeName and key('Layout',concat($thisID, $thisReportID))[stretch='true']"&gt;
&lt;textarea readonly="readonly" rows="0" cols="0"&gt;
&lt;xsl:call-template name="addClassAttribute"&gt;
&lt;xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="addTitleAttribute"/&gt;
&lt;xsl:call-template name="addStyleAttribute"&gt;
&lt;xsl:with-param name="topOffset" select="$topOffset"/&gt;
&lt;xsl:with-param name="thisZ" select="$thisZ"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;xsl:with-param name="styleType" select="'TextArea'"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:value-of select="."/&gt;
&lt;/textarea&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;div&gt;
&lt;xsl:call-template name="addClassAttribute"&gt;
&lt;xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="addTitleAttribute"/&gt;
&lt;xsl:call-template name="addStyleAttribute"&gt;
&lt;xsl:with-param name="topOffset" select="$topOffset"/&gt;
&lt;xsl:with-param name="thisZ" select="$thisZ"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;xsl:with-param name="styleType" select="'Div'"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="name()=$shapeNodeName or name()=$lineNodeName"&gt;
&lt;!-- nothing --&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="name()=$pictureNodeName and string-length(@hlink) &amp;gt; 0"&gt;
&lt;a href="{@hlink}"&gt;
&lt;xsl:call-template name="renderPicture"&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;/xsl:call-template&gt;
&lt;/a&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="name()=$pictureNodeName and string-length(@PLINK) &amp;gt; 0"&gt;
&lt;a href="{translate(@PLINK,'\','/')}"  target="blank"&gt;
&lt;xsl:call-template name="renderPicture"&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;/xsl:call-template&gt;
&lt;/a&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="name()=$pictureNodeName"&gt;
&lt;xsl:call-template name="renderPicture"&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;xsl:with-param name="thisID" select="$thisID"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="string-length(@hlink) &amp;gt; 0"&gt;
&lt;a href="{@hlink}"&gt;
&lt;xsl:call-template name="replaceText"/&gt;
&lt;/a&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="string-length(@PLINK) &amp;gt; 0"&gt;
&lt;a href="{translate(@PLINK,'\','/')}" target="blank"&gt;
&lt;xsl:call-template name="replaceText"/&gt;
&lt;/a&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:call-template name="replaceText"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/div&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;!-- /xsl:if --&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="getCSSName"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisItem" select="0"/&gt;
&lt;xsl:param name="firstPass" select="1"/&gt;
&lt;xsl:variable name="subst" select="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$thisItem]/@css"/&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="number($firstPass)=1 or string-length($subst) = 0"&gt;&lt;xsl:value-of select="concat('.FRX',$thisReport,'_',$thisItem)"/&gt;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;.&lt;xsl:value-of select="$subst"/&gt;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="VFPFRXLayoutObject" mode="imagestyles"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="firstPass" select="1"/&gt;
&lt;xsl:call-template name="getCSSName"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisItem" select="frxrecno"/&gt;
&lt;xsl:with-param name="firstPass" select="$firstPass"/&gt;
&lt;/xsl:call-template&gt;{
position: absolute;overflow: hidden;width: &lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="width div $FRUs"/&gt;&lt;/xsl:call-template&gt;in;height: &lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="height div $FRUs"/&gt;&lt;/xsl:call-template&gt;in;
}
&lt;!-- &lt;xsl:if test="offset=0"&gt;
left: &lt;xsl:value-of select="hpos div $FRUs"/&gt;in;
&lt;/xsl:if&gt;
&lt;xsl:if test="offset=2"&gt;
left: &lt;xsl:value-of select="hpos div $FRUs"/&gt;in;
&lt;/xsl:if&gt; --&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="VFPFRXLayoutObject" mode="shapestyles"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="firstPass" select="1"/&gt;
&lt;xsl:call-template name="getCSSName"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisItem" select="frxrecno"/&gt;
&lt;xsl:with-param name="firstPass" select="$firstPass"/&gt;
&lt;/xsl:call-template&gt;{
position: absolute ;font-size:1pt; border: &lt;xsl:value-of select="pensize"/&gt;px &lt;xsl:call-template name="pattern"/&gt;&lt;xsl:call-template name="pencolor"/&gt;;&lt;xsl:if test="(mode=0 and not(fillpat=0)) or (mode=1 and fillpat=1)"&gt;background-color:&lt;xsl:call-template name="fillcolor"/&gt;;&lt;/xsl:if&gt;width: &lt;xsl:call-template name="setPrecision"&gt; &lt;xsl:with-param name="theNumber" select="width div $FRUs"/&gt;&lt;/xsl:call-template&gt;in;left: &lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="hpos div $FRUs"/&gt;&lt;/xsl:call-template&gt;in;
}
&lt;!--    &lt;xsl:if test="stretch='true'"&gt;
overflow: auto;
&lt;/xsl:if&gt; --&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="VFPFRXLayoutObject" mode="textstyles"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="firstPass" select="1"/&gt;
&lt;xsl:call-template name="getCSSName"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisItem" select="frxrecno"/&gt;
&lt;xsl:with-param name="firstPass" select="$firstPass"/&gt;
&lt;/xsl:call-template&gt;{
&lt;xsl:call-template name="getTextAlignment"/&gt;vertical-align: top; font-family: "&lt;xsl:value-of select="fontface"/&gt;"; font-size: &lt;xsl:value-of select="fontsize"/&gt;pt; border: 0px none; padding: 0px; margin: 0px;&lt;xsl:call-template name="getFontAttributes"/&gt;color:&lt;xsl:call-template name="pencolor"/&gt;;&lt;xsl:choose&gt;
&lt;xsl:when test="mode mod 2 = 1"&gt;background-color:transparent;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;background-color: &lt;xsl:call-template name="fillcolor"/&gt;;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;&lt;xsl:choose&gt;
&lt;xsl:when test="stretch='true' and objtype=8 and $useTextAreaForStretchingText=1 and $hideScrollbarsForTextAreas=1"&gt; overflow:hidden;margin-top:4px;&lt;/xsl:when&gt;
&lt;xsl:when test="stretch='true' and objtype=8 and $useTextAreaForStretchingText=1"&gt; overflow: auto;margin-top:4px;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;overflow:hidden;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt; position: absolute;
}
&lt;!-- tbd, make vertical-align more dynamic --&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="VFPFRXLayoutObject" mode="linestyles"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="firstPass" select="1"/&gt;
&lt;xsl:call-template name="getCSSName"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="thisItem" select="frxrecno"/&gt;
&lt;xsl:with-param name="firstPass" select="$firstPass"/&gt;
&lt;/xsl:call-template&gt;{
position:absolute;font-size:1pt;border: &lt;xsl:value-of select="pensize"/&gt;px &lt;xsl:call-template name="pattern"/&gt;&lt;xsl:call-template name="pencolor"/&gt;;left: &lt;xsl:value-of select="hpos div $FRUs"/&gt;in;
&lt;xsl:choose&gt;
&lt;xsl:when test="height &amp;lt; width"&gt; width: &lt;xsl:value-of select="width div $FRUs"/&gt;in;
height: &lt;xsl:value-of select="floor(height div $FRUsInPixelsat96DPI)"/&gt;px; margin: 0px;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;  height: &lt;xsl:value-of select="height div $FRUs"/&gt;in;
width: &lt;xsl:value-of select="floor(width div $FRUsInPixelsat96DPI)"/&gt;px;  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
}
&lt;/xsl:template&gt;
&lt;xsl:template name="pattern"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="penpat=0"&gt; none &lt;/xsl:when&gt;
&lt;xsl:when test="penpat=1"&gt; dotted &lt;/xsl:when&gt;
&lt;xsl:when test="penpat=2"&gt; dashed &lt;/xsl:when&gt;
&lt;xsl:otherwise&gt; solid &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="pencolor"&gt;#&lt;xsl:call-template name="getHexColorValue"&gt;
&lt;xsl:with-param name="theNumber" select="penred"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="getHexColorValue"&gt;
&lt;xsl:with-param name="theNumber" select="pengreen"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="getHexColorValue"&gt;
&lt;xsl:with-param name="theNumber" select="penblue"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="fillcolor"&gt;#&lt;xsl:call-template name="getHexColorValue"&gt;
&lt;xsl:with-param name="theNumber" select="fillred"/&gt;
&lt;xsl:with-param name="fill" select="1"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="getHexColorValue"&gt;
&lt;xsl:with-param name="theNumber" select="fillgreen"/&gt;
&lt;xsl:with-param name="fill" select="1"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="getHexColorValue"&gt;
&lt;xsl:with-param name="theNumber" select="fillblue"/&gt;
&lt;xsl:with-param name="fill" select="1"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="getFontAttributes"&gt;
&lt;xsl:param name="theStyles" select="0"/&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="fontbold='true'"&gt;font-weight: bold;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;font-weight: normal;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;xsl:if test="fontstrikethrough='true' or fontunderline='true'"&gt;text-decoration: &lt;xsl:if test="fontstrikethrough='true'"&gt;line-through &lt;/xsl:if&gt;
&lt;xsl:if test="fontunderline='true'"&gt;underline&lt;/xsl:if&gt;;&lt;/xsl:if&gt;
&lt;xsl:if test="fontitalic='true'"&gt;font-style: italic;&lt;/xsl:if&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="getHexColorValue"&gt;
&lt;xsl:param name="theNumber" select="-1"/&gt;
&lt;xsl:param name="fill" select="0"/&gt;
&lt;xsl:variable name="useNumber"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="$fill=1 and fillpat &amp;gt; 1 and ((fillred+fillblue+fillgreen) &amp;lt; $fillPatternShade)"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="($fillPatternOffset + $theNumber) &amp;gt; 254"&gt;255&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select="$fillPatternOffset + $theNumber"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select="$theNumber"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="$useNumber=-1 and $fill=1"&gt;FF&lt;/xsl:when&gt;
&lt;xsl:when test="$useNumber=-1"&gt;00&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:call-template name="getHexForNumber"&gt;
&lt;xsl:with-param name="theNumber" select="floor($useNumber div 16)"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="getHexForNumber"&gt;
&lt;xsl:with-param name="theNumber" select="round($useNumber mod 16)"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="setPrecision"&gt;
&lt;xsl:param name="theNumber" select="-1"/&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="$numberPrecision = -1 or not(contains(string($theNumber),'.'))"&gt;
&lt;xsl:value-of select="$theNumber"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="$numberPrecision &amp;gt; 0"&gt;
&lt;!--        &lt;xsl:value-of select="concat(string(floor($theNumber)),'.',substring(substring-after(string($theNumber),'.'),1,$numberPrecision))"/&gt;  --&gt;
&lt;xsl:value-of select="format-number($theNumber,concat('##0.',$zeros))"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="$numberPrecision=0"&gt;
&lt;xsl:value-of select="round($theNumber)"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;!-- shouldn't happen--&gt;
&lt;xsl:value-of select="$theNumber"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="getHexForNumber"&gt;
&lt;xsl:param name="theNumber" select="-1"/&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="$theNumber=-1"&gt;00&lt;/xsl:when&gt;
&lt;xsl:when test="$theNumber &amp;lt; 10"&gt;
&lt;xsl:value-of select="$theNumber"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="$theNumber = 10"&gt;A&lt;/xsl:when&gt;
&lt;xsl:when test="$theNumber = 11"&gt;B&lt;/xsl:when&gt;
&lt;xsl:when test="$theNumber = 12"&gt;C&lt;/xsl:when&gt;
&lt;xsl:when test="$theNumber = 13"&gt;D&lt;/xsl:when&gt;
&lt;xsl:when test="$theNumber = 14"&gt;E&lt;/xsl:when&gt;
&lt;xsl:when test="$theNumber = 15"&gt;F&lt;/xsl:when&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="getTextAlignment"&gt;text-align:&lt;xsl:choose&gt;
&lt;xsl:when test="objtype=5"&gt;&lt;!-- picture field empty for left (default), @I for centered and @J right --&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="string-length(picture) = 0"&gt;left;&lt;/xsl:when&gt;
&lt;xsl:when test="contains(picture,'@J')"&gt;right;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;center;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="offset=0"&gt;left;&lt;/xsl:when&gt;
&lt;xsl:when test="offset=1"&gt;right;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;center;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;!-- don't include direction at all if you want context --&gt;
&lt;xsl:if test="mode &amp;lt; 4"&gt;direction:&lt;xsl:choose&gt;
&lt;xsl:when test="mode &amp;gt; 1"&gt;rtl;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;ltr;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:if&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="ExternalStyleSheets"&gt;
&lt;xsl:param name="thisReportNode" select="/Reports/VFP-Report[1]"/&gt;
&lt;xsl:param name="thisReportID" select="'this report'"/&gt;
&lt;xsl:if test="count($thisReportNode/Run/property[@id='css_sheet']) &amp;gt; 0"&gt;
&lt;xsl:comment&gt;
External stylesheet(s) for &lt;xsl:value-of select="$thisReportID"/&gt;
&lt;/xsl:comment&gt;
&lt;xsl:for-each select="$thisReportNode/Run/property[@id='css_sheet']"&gt;
&lt;link type="text/css" href="{./text()}" rel="stylesheet"/&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:if&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="DocumentStyles"&gt;
&lt;xsl:comment&gt;Global document styles, if any&lt;/xsl:comment&gt;
&lt;style type="text/css"&gt;
&lt;xsl:comment&gt;&lt;xsl:if test="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=1 and (fontcharset=177 or fontcharset=178)]"&gt;
&lt;xsl:if test="number($noBody)!=1"&gt;html{direction:rtl;}
body{direction:rtl;}&lt;/xsl:if&gt;
div{direction:rtl;}
span{direction:rtl;}
&lt;/xsl:if&gt;
&lt;/xsl:comment&gt;
&lt;/style&gt;

&lt;/xsl:template&gt;
&lt;xsl:template name="Styles"&gt;
&lt;xsl:param name="thisReport" select="1"/&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:comment&gt;
Styles for report # &lt;xsl:value-of select="$thisReport"/&gt;  in this run,
&lt;xsl:value-of select="$thisReportID"/&gt;
&lt;/xsl:comment&gt;

&lt;style type="text/css"&gt;

&lt;xsl:comment&gt;

&lt;xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=6]" mode="linestyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;/xsl:apply-templates&gt;

&lt;xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=6]"&gt;
&lt;xsl:variable name="frxrecno" select="frxrecno"/&gt;
&lt;xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css"&gt;
&lt;xsl:apply-templates select="." mode="linestyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="firstPass" select="0"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;

&lt;xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=7]" mode="shapestyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;/xsl:apply-templates&gt;

&lt;xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=7]"&gt;
&lt;xsl:variable name="frxrecno" select="frxrecno"/&gt;
&lt;xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css"&gt;
&lt;xsl:apply-templates select="." mode="shapestyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="firstPass" select="0"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;

&lt;xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[contains('|5|8|',concat('|',./objtype,'|'))]" mode="textstyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;/xsl:apply-templates&gt;

&lt;xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[contains('|5|8|',concat('|',./objtype,'|'))]"&gt;
&lt;xsl:variable name="frxrecno" select="frxrecno"/&gt;
&lt;xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css"&gt;
&lt;xsl:apply-templates select="." mode="textstyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="firstPass" select="0"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;

&lt;xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=17]" mode="imagestyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;/xsl:apply-templates&gt;

&lt;xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=17]"&gt;
&lt;xsl:variable name="frxrecno" select="frxrecno"/&gt;
&lt;xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css"&gt;
&lt;xsl:apply-templates select="." mode="imagestyles"&gt;
&lt;xsl:with-param name="thisReport" select="$thisReport"/&gt;
&lt;xsl:with-param name="firstPass" select="0"/&gt;
&lt;/xsl:apply-templates&gt;
&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;


&lt;/xsl:comment&gt;

&lt;/style&gt;

&lt;xsl:call-template name="ExternalStyleSheets"&gt;
&lt;xsl:with-param name="thisReportNode" select="/Reports/VFP-Report[$thisReport]"/&gt;
&lt;xsl:with-param name="thisReportID" select="$thisReportID"/&gt;
&lt;/xsl:call-template&gt;

&lt;/xsl:template&gt;
&lt;xsl:template name="replaceText"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="$useTextAreaForStretchingText=1"&gt;
&lt;xsl:value-of select="."/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:call-template name="replaceWhiteSpace"&gt;
&lt;xsl:with-param name="string" select="."/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="renderPicture"&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:param name="thisID"/&gt;
&lt;img&gt;
&lt;xsl:attribute name="alt"&gt;&lt;xsl:choose&gt;&lt;xsl:when test="@alt"&gt;&lt;xsl:value-of select="@alt"/&gt;&lt;/xsl:when&gt;&lt;xsl:otherwise&gt;&lt;xsl:value-of select="key('Layout',concat($thisID, $thisReportID))/unpathedimg"/&gt;&lt;/xsl:otherwise&gt;&lt;/xsl:choose&gt;&lt;/xsl:attribute&gt;
&lt;xsl:variable name="srcImage"&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="@img and $externalFileLocation"&gt;
&lt;xsl:value-of select="translate(concat($externalFileLocation,@img),'\','/')"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="@img and not(contains(./@img,':'))"&gt;
&lt;xsl:value-of select="translate(@img,'\','/')"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="@img"&gt;
&lt;xsl:value-of select="concat('file://',translate(@img,'\','/'))"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="$copyImageFiles = '1'"&gt;
&lt;xsl:value-of select="translate(concat($externalFileLocation,key('Layout',concat($thisID, $thisReportID))/unpathedimg),'\','/')"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="string-length(./text()) &amp;gt; 0 and not(contains(./text(),':')) "&gt;
&lt;xsl:value-of select="translate(./text(),'\','/')"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="string-length(./text()) &amp;gt; 0"&gt;
&lt;xsl:value-of select="concat('file://',translate(./text(),'\','/'))"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select="concat('file://',translate(key('Layout',concat($thisID, $thisReportID))/pathedimg,'\','/'))"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;
&lt;xsl:attribute name="src"&gt;&lt;xsl:value-of select="$srcImage"/&gt;&lt;/xsl:attribute&gt;
&lt;xsl:attribute name="style"&gt;&lt;xsl:variable name="imgGeneral" select="key('Layout',concat($thisID, $thisReportID))"/&gt;&lt;xsl:choose&gt;&lt;xsl:when test="$imgGeneral/general='0' "&gt;&lt;!-- clip top, right, bottom, left --&gt;
clip: rect(0in,&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@w div $printDPI"/&gt;&lt;/xsl:call-template&gt;in,&lt;xsl:value-of select="@h div $printDPI"/&gt;in,0in);
&lt;/xsl:when&gt;&lt;xsl:when test="$imgGeneral/general='1'"&gt;&lt;!-- scale and retain --&gt;&lt;xsl:choose&gt;&lt;xsl:when test="@h &amp;gt; @w"&gt;
width:100%;
&lt;/xsl:when&gt;&lt;xsl:otherwise&gt;
height:100%;
&lt;/xsl:otherwise&gt;&lt;/xsl:choose&gt;&lt;/xsl:when&gt;&lt;xsl:otherwise&gt;&lt;!-- stretch to fill frame --&gt;
height: &lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@h div $printDPI"/&gt;&lt;/xsl:call-template&gt;in;
width: &lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@w div $printDPI"/&gt;&lt;/xsl:call-template&gt;in;
&lt;/xsl:otherwise&gt;&lt;/xsl:choose&gt;&lt;/xsl:attribute&gt;
&lt;/img&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="addClassAttribute"&gt;
&lt;xsl:param name="item" select="."/&gt;
&lt;xsl:param name="default" select="''"/&gt;
&lt;xsl:attribute name="class"&gt;&lt;xsl:choose&gt;
&lt;xsl:when test="string-length($item/@CSS) &amp;gt; 0"&gt;
&lt;xsl:value-of select="$item/@CSS"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:when test="string-length($item/@css) = 0"&gt;
&lt;xsl:value-of select="$default"/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select="$item/@css"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;&lt;/xsl:attribute&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="addTitleAttribute"&gt;
&lt;xsl:param name="item" select="."/&gt;
&lt;xsl:if test="string-length($item/@title) &amp;gt; 0"&gt;
&lt;xsl:attribute name="title"&gt;&lt;xsl:value-of select="$item/@title"/&gt;&lt;/xsl:attribute&gt;
&lt;/xsl:if&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="addAnchor"&gt;
&lt;xsl:param name="item" select="."/&gt;
&lt;xsl:if test="string-length($item/@anchor) &amp;gt; 0"&gt;
&lt;a&gt;
&lt;xsl:attribute name="{$anchorAttr}"&gt;&lt;xsl:value-of select="$item/@anchor"/&gt;&lt;/xsl:attribute&gt;
&lt;xsl:text disable-output-escaping="yes"&gt;&amp;amp;nbsp;&lt;/xsl:text&gt;
&lt;/a&gt;
&lt;/xsl:if&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="addStyleAttribute"&gt;
&lt;xsl:param name="topOffset" select="0"/&gt;
&lt;xsl:param name="thisZ" select="1"/&gt;
&lt;xsl:param name="thisReportID"/&gt;
&lt;xsl:param name="thisID"/&gt;
&lt;xsl:param name="styleType" select="'Div'"/&gt;
&lt;!-- do NOT mess around with the white space in here, even though it
looks ugly the way it is!! --&gt;
&lt;xsl:attribute name="style"&gt;z-Index:&lt;xsl:value-of select="$thisZ"/&gt;;left:&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@l div $printDPI"/&gt;&lt;/xsl:call-template&gt;in;
top:&lt;xsl:choose&gt;
&lt;xsl:when test="styleType='TextArea'"&gt;&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="((@t  + $topOffset) div $printDPI) - .1"/&gt;&lt;/xsl:call-template&gt;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="(@t +$topOffset) div $printDPI"/&gt;&lt;/xsl:call-template&gt;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;in;&lt;xsl:choose&gt;
&lt;xsl:when test="$styleType='VR'"&gt;width:0in;&lt;/xsl:when&gt;
&lt;xsl:when test="$styleType='TextArea'"&gt;width:&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@w div $printDPI"/&gt;&lt;/xsl:call-template&gt;in;&lt;/xsl:when&gt;
&lt;xsl:when test="$styleType='Div'"&gt;width:&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@w div $printDPI"/&gt;&lt;/xsl:call-template&gt;in;height:&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@h div $printDPI"/&gt;&lt;/xsl:call-template&gt;in;&lt;/xsl:when&gt;&lt;/xsl:choose&gt;&lt;xsl:if test="not($styleType='Div')"&gt;height:&lt;xsl:call-template name="setPrecision"&gt;&lt;xsl:with-param name="theNumber" select="@h div $printDPI"/&gt;&lt;/xsl:call-template&gt;in;&lt;/xsl:if&gt;
&lt;xsl:if test="$useDynamicTextAttributes=1 and key('Layout',concat($thisID,$thisReportID))[objtype=5 or objtype=8]"&gt;
&lt;xsl:call-template name="addDynamicTextStyleAttributes"/&gt;
&lt;/xsl:if&gt;
&lt;/xsl:attribute&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="addDynamicTextStyleAttributes"&gt;
&lt;!-- dynamic values for font, omit these attributes if they don't appear on each object--&gt;
&lt;xsl:if test="@FNAME"&gt;
font-family:'&lt;xsl:value-of select="@FNAME"/&gt;';font-size:&lt;xsl:value-of select="@FSIZE"/&gt;pt;
&lt;xsl:if test="((@FSTYLE div 128) mod 2 = 1) or ( (@FSTYLE div 4) mod 2 = 1)"&gt;text-decoration:&lt;xsl:if test="((@FSTYLE div 128) mod 2 = 1)"&gt;line-through&lt;/xsl:if&gt;&lt;xsl:if test="( (@FSTYLE div 8) mod 2 = 1)"&gt;underline&lt;/xsl:if&gt;;&lt;/xsl:if&gt;
font-weight:&lt;xsl:choose&gt;&lt;xsl:when test="@FSTYLE mod 2 = 1"&gt;bold&lt;/xsl:when&gt;&lt;xsl:otherwise&gt;normal&lt;/xsl:otherwise&gt;&lt;/xsl:choose&gt;;
font-style:&lt;xsl:choose&gt;&lt;xsl:when test="(@FSTYLE div 2) mod 2 =1"&gt;italic&lt;/xsl:when&gt;&lt;xsl:otherwise&gt;normal&lt;/xsl:otherwise&gt;&lt;/xsl:choose&gt;;
background-color:&lt;xsl:call-template name="getAlphaColor"&gt;
&lt;xsl:with-param name="alpha" select="@FA"/&gt;
&lt;xsl:with-param name="r" select="@FR"/&gt;
&lt;xsl:with-param name="g" select="@FG"/&gt;
&lt;xsl:with-param name="b" select="@FB"/&gt;
&lt;/xsl:call-template&gt;;color:&lt;xsl:call-template name="getAlphaColor"/&gt;;
&lt;/xsl:if&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="getAlphaColor"&gt;
&lt;xsl:param name="alpha" select="@PA"/&gt;
&lt;xsl:param name="r" select="@PR"/&gt;
&lt;xsl:param name="g" select="@PG"/&gt;
&lt;xsl:param name="b" select="@PB"/&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="$alpha=0"&gt;transparent&lt;/xsl:when&gt;
&lt;xsl:when test="$alpha=255 or ($r+$g+$b &amp;gt; $fieldAlphaOpacityShade)"&gt;&lt;xsl:value-of select="concat('rgb(',$r,',',$g,',',$b,')')"/&gt;&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;&lt;xsl:value-of select="concat('rgb(',$r+$fieldAlphaOpacityOffset,',',$g+$fieldAlphaOpacityOffset,',',$b+$fieldAlphaOpacityOffset,')')"/&gt;&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;


&lt;/xsl:template&gt;

&lt;xsl:template name="replaceWhiteSpace"&gt;
&lt;xsl:param name="string" select="."/&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test="contains($string,'&amp;#xA;')"&gt;
&lt;xsl:call-template name="replaceWhiteSpace"&gt;
&lt;xsl:with-param name="string" select="substring-before($string, '&amp;#xA;')"/&gt;
&lt;/xsl:call-template&gt;
&lt;br/&gt;
&lt;xsl:call-template name="replaceWhiteSpace"&gt;
&lt;xsl:with-param name="string" select="substring-after($string, '&amp;#xA;')"/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select="$string"/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="Script"&gt;
&lt;script language="JavaScript"&gt;
&lt;xsl:comment&gt;
//TBD
&lt;/xsl:comment&gt;
&lt;/script&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="*|@*" mode="debug"&gt;
&lt;xsl:copy-of select="."/&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;


ENDTEXT
SET TEXTMERGE OFF
SET TEXTMERGE TO

RETURN m.lcResult
ENDPROC
PROCEDURE getrawformattinginfo
LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL m.lcInfo, m.lcVal, m.liRecno
m.lcInfo = DODEFAULT(m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType)
THIS.setFRXDataSession()
m.liRecno = RECNO("FRX")
IF USED(THIS.MemberDataAlias) AND ;
SEEK(m.liRecno,THIS.MemberDataAlias,"FRXRecno")
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSOVERRIDE
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
SELECT (THIS.MemberDataAlias)
IF NOT EMPTY(m.lcVal)
m.lcInfo = m.lcInfo + " "+THIS.cssClassOverrideAttr+"='"+m.lcVal+"'"
ELSE
* try again with other css class attribute
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSEXTEND
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.lcInfo = m.lcInfo + " "+THIS.cssClassAttr+"='"+m.lcVal+"'"
ENDIF
ENDIF
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMHREF
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.lcInfo = m.lcInfo + " "+ ;
THIS.linkAttr +"='"+ ;
THIS.pathEncode(m.lcVal, .T.)+"'"
ENDIF
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMTITLE
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.lcInfo = m.lcInfo + " "+THIS.titleAttr +"='"+m.lcVal+"'"
ENDIF
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMANCHOR
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.lcInfo = m.lcInfo + " "+ ;
THIS.anchorAttr +"='"+ ;
THIS.pathEncode(m.lcVal, .T.)+"'"
ENDIF
SELECT FRX
ENDIF

RETURN m.lcInfo
ENDPROC
PROCEDURE Init
IF DODEFAULT()
THIS.AppName = OUTPUTHTML_APPNAME_LOC
ELSE
RETURN .F.
ENDIF

RETURN NOT THIS.HadError
ENDPROC
PROCEDURE linkattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
AND NOT (m.vNewVal == THIS.linkAttr)
THIS.linkAttr = m.vNewVal
THIS.SynchXSLTProcessorUser()
ENDIF





ENDPROC
PROCEDURE pathencode
LPARAMETERS m.tcVal, m.tlXMLEncode
LOCAL m.lcVal, m.lcTempVal, m.laVals[1], m.liIndex, m.liSeparators
m.lcVal = ALLTRIM(CHRTRAN(m.tcVal,"\","/"))
* default XSLT would take care of the above anyway, but
* no harm in doing it here
DO CASE
CASE LEN(m.lcVal) = 0
* nothing
CASE AT("/",m.lcVal) &gt; 0
m.lcTempVal = ""
m.liSeparators = ALINES(m.laVals,m.lcVal,0,"/")
FOR m.liIndex = 1 TO m.liSeparators
IF ":" $ m.laVals[m.liIndex]
m.lcTempVal = m.lcTempVal + m.laVals[m.liIndex]
ELSE
m.lcTempVal = m.lcTempVal + ;
THIS.urlStringEncode(m.laVals[m.liIndex])
ENDIF
IF m.liIndex &lt; m.liSeparators
m.lcTempVal = m.lcTempVal + "/"
ENDIF
ENDFOR
IF RIGHT(m.lcVal,1) = "/"
m.lcTempVal = m.lcTempVal + "/"
ENDIF
m.lcVal = m.lcTempVal
OTHERWISE
m.lcVal = THIS.urlStringEncode(m.lcVal)
ENDCASE

#IF OUTPUTXML = OUTPUTXML_RAW
IF m.tlXMLEncode
* the result is going to an XML document
m.lcVal = THIS.xmlRawConv(m.lcVal)
ENDIF
#ENDIF

RETURN m.lcVal

ENDPROC
PROCEDURE setdomformattinginfo
LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL  m.lcVal, m.liRecno
DODEFAULT( m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType)
THIS.setFRXDataSession()
m.liRecno = RECNO("FRX")
IF USED(THIS.MemberDataAlias) AND ;
SEEK(m.liRecno,THIS.MemberDataAlias,"FRXRecno")
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSOVERRIDE
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
SELECT (THIS.MemberDataAlias)
IF NOT EMPTY(m.lcVal)
m.toNode.SetAttribute(THIS.cssClassOverrideAttr,m.lcVal )
ELSE
* try again with other css class attribute
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSEXTEND
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.toNode.SetAttribute(THIS.cssClassAttr,m.lcVal )
ENDIF
ENDIF
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMHREF
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.toNode.SetAttribute(THIS.linkAttr,THIS.pathEncode(m.lcVal))
ENDIF
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMTITLE
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.toNode.SetAttribute(THIS.titleAttr,m.lcVal )
ENDIF
SELECT (THIS.MemberDataAlias)
m.lcVal = ""
LOCATE FOR FRXRecno = m.liRecno AND ;
Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMANCHOR
IF FOUND()
IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR
m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
ELSE
m.lcVal = Execute
ENDIF
ENDIF
IF NOT EMPTY(m.lcVal)
m.toNode.SetAttribute(THIS.anchorAttr,THIS.pathEncode(m.lcVal) )
ENDIF
SELECT FRX
ENDIF


ENDPROC
PROCEDURE titleattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
AND NOT (m.vNewVal == THIS.titleAttr )
THIS.titleAttr  = m.vNewVal
THIS.SynchXSLTProcessorUser()
ENDIF





ENDPROC
PROCEDURE urlstringencode
LPARAMETER m.tcValue, m.tlEncodeURLControlChars, m.tlEncodeSpace
* Thanks to Rick Strahl and West Wind for help and advice!
IF VARTYPE(m.tcValue) # "C"
RETURN ""
ENDIF
LOCAL m.lcResult, m.lcChar, m.ii, m.lcOKChars

m.lcResult=""
m.lcOKChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

IF NOT m.tlEncodeURLControlChars
* by default, we also exempt chars that might
* indicate an anchor or a query string element
m.lcOKChars = m.lcOKChars + ".?=&amp;#"
ENDIF

FOR m.ii=1 TO LEN(m.tcValue)
m.lcChar = SUBSTR(m.tcValue,m.ii,1)
IF ATC(m.lcChar,m.lcOKChars) &gt; 0
m.lcResult=m.lcResult + m.lcChar
LOOP
ENDIF
IF m.lcChar=" " AND NOT m.tlEncodeSpace
m.lcResult = m.lcResult + "+"
LOOP
ENDIF
m.lcResult = m.lcResult + "%" + RIGHT(TRANSFORM(ASC(m.lcChar),"@0"),2)
ENDFOR

RETURN m.lcResult



ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>cssclassattr Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, supplementing FRX design instructions.
anchorattr Supplies the name of the XML attribute used to supply HTML anchor instructions to the node representing an FRX layout control or band.
titleattr Supplies the name of the XML attribute used to supply alternate text or tooltip information to a node representing an FRX layout control.
linkattr Supplies the name of the XML attribute used to supply HTML link information to the node representing a layout control containing an image or non-TEXTAREA text.
cssclassoverrideattr Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, overriding FRX design instructions.
oldpageimagetype Saves the user's preferred PageImageType settings during a run, if the Listener adjusts it to match HTML Page Link memberdata contents it finds in this report.
oldtextareasetting Saves the user's pre-report XSLTParameters useTextAreaForStretchingText value, if the Listener adjusts the value to match memberdata settings it finds in the current report.
*getdefaultuserxsltasstring Supplies default User XSLT document o the getDefaultUserXslt method as a string.
*cssclassattr_assign 
*anchorattr_assign 
*titleattr_assign 
*linkattr_assign 
*cssclassoverrideattr_assign 
*urlstringencode Encode string for purposes of using it as part of a link in an HTML page.
*pathencode Encodes sections of a URL path re-creates the URL from the elements, and optionally re-encodes suitable for including in well-formed XML.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Applies custom specifications, tuned to HTML production, to its parent class' XML generation process.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>htmllistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_13T0OHG0F</uniqueid>
		<timestamp>914899996</timestamp>
		<class>fxlistener</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>reportlistener</baseclass>
		<objname>utilityreportlistener</objname>
		<parent/>
		<properties>FRXDataSession = -1
readconfiguration = (0)
targetfileext = ("TXT")
targetfilename = (FORCEPATH(SYS(2015),SYS(2023)))
targethandle = -1
configurationobjtype = 1000
configurationtable = ("")
externalfilelocation = ("")
pageimagetype = 0
pageimageextension = ("")
currentpageimagefilename = ("")
_memberdata =     2143&lt;VFPData&gt;
 &lt;memberdata name="closetargetfile" type="method" display="closeTargetFile" favorites="False" /&gt;
 &lt;memberdata name="configurationobjtype" type="property" display="configurationObjtype" favorites="True" /&gt;
 &lt;memberdata name="configurationtable" type="property" display="configurationTable" favorites="False" /&gt;
 &lt;memberdata name="createconfigtable" type="method" display="createConfigTable" favorites="True" /&gt;
 &lt;memberdata name="getconfigtable" type="method" display="getConfigTable" favorites="True" /&gt;
 &lt;memberdata name="opentargetfile" type="method" display="openTargetFile" favorites="False" /&gt;
 &lt;memberdata name="readconfiguration" type="property" display="readConfiguration" favorites="True" /&gt;
 &lt;memberdata name="setconfiguration" type="method" display="setConfiguration" favorites="True" /&gt;
 &lt;memberdata name="targetfileext" type="property" display="targetFileExt" favorites="True" /&gt;
 &lt;memberdata name="targetfilename" type="property" display="targetFileName" favorites="True" /&gt;
 &lt;memberdata name="targethandle" type="property" display="targetHandle" favorites="True" /&gt;
 &lt;memberdata name="verifyconfigtable" type="property" display="verifyConfigTable" favorites="True" /&gt;
 &lt;memberdata name="verifytargetfile" type="method" display="verifyTargetFile" favorites="True" /&gt;
&lt;memberdata name="externalfilelocation" type="property" display="externalFileLocation" favorites="True" /&gt;
&lt;memberdata name="pageimagetype" type="property" display="pageImageType" favorites="True"/&gt;
&lt;memberdata name="getpageimageextension" type="method" display="getPageImageExtension"/&gt;
&lt;memberdata name="pageimageextension" type="property" display="pageImageExtension"/&gt;
&lt;memberdata name="generatepageimagefilename" type="method" 
display="generatePageImageFileName"/&gt;
&lt;memberdata name="supportspageimages" type="method" display="supportsPageImages"/&gt;
&lt;memberdata name="outputpageimage" type="method" display="outputPageImage"/&gt;
&lt;memberdata name="currentpageimagefilename" display="currentPageImageFilename" type="property"/&gt;
&lt;memberdata name="makeexternalfilelocationreachable" display="makeExternalFileLocationReachable" type="method"/&gt;
&lt;/VFPData&gt;

Name = "utilityreportlistener"
</properties>
		<protected>configurationtable
pageimageextension
opentargetfile
closetargetfile
getpageimageextension
generatepageimagefilename
supportspageimages
outputpageimage
makeexternalfilelocationreachable
</protected>
		<methods>PROCEDURE AfterReport
DODEFAULT()
IF (NOT THIS.CommandClauses.NOPAGEEJECT) AND ;
THIS.supportsPageImages("AFTERREPORT")
LOCAL m.lcFileLocation, m.liPage,  m.lcFile
m.lcFileLocation = THIS.ExternalFileLocation
THIS.makeExternalFileLocationReachable()
FOR m.liPage = 1 TO THIS.OutputPageCount
IF NOT THIS.outputPageImage(m.liPage)
EXIT
ENDIF
NEXT
THIS.externalFileLocation = m.lcFileLocation
ENDIF

ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo

IF (m.nBandObjCode = FRX_OBJCOD_PAGEHEADER OR ;
m.nBandObjCode = FRX_OBJCOD_TITLE) AND ;
THIS.supportsPageImages()
* Note: this assignment does not occur in
* OutputPageImage, because we don't know
* what listener mode (PRN vs cached) we're in.
* The point of this property is to make the value
* available either way, as it will eventually be
* used by OutputPageImage no matter when that occurs,
* during the run of the report.
LOCAL lcFile, liPageNo
m.lcFile = ""
DO CASE
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_MTIF
m.liPageNo = 1
CASE THIS.CommandClauses.RangeFrom &lt; 2
IF THIS.isSuccessor
m.liPageNo = THIS.sharedPageNo
ELSE
m.liPageNo = THIS.PageNo
ENDIF
OTHERWISE
IF THIS.isSuccessor
m.liPageNo = (THIS.sharedPageNo - THIS.CommandClauses.RangeFrom) + 1
ELSE
m.liPageNo = (THIS.PageNo - THIS.CommandClauses.RangeFrom) + 1
ENDIF
ENDCASE
m.lcFile = THIS.generatePageImageFileName(m.liPageNo)
THIS.currentPageImageFilename = m.lcFile
IF NOT ISNULL(THIS.successor)
THIS.successor.currentPageImageFilename = m.lcFile
ENDIF
ENDIF

IF THIS.sharedPageNo  = 1 AND ;
m.nBandObjCode = FRX_OBJCOD_PAGEHEADER AND ;
(NOT EMPTY(THIS.pageImageType)) AND ;
(EMPTY(THIS.currentPageImageFilename)) AND ;
((NOT THIS.TwoPassProcess) OR THIS.CurrentPass = LISTENER_FULLPASS)
THIS.DoMessage(OUTPUTFILE_NOIMAGEFILES_LOC,MB_ICONEXCLAMATION)
ENDIF

DODEFAULT(m.nBandObjCode, m.nFRXRecNo)




ENDPROC
PROCEDURE BeforeReport
THIS.currentPageImageFilename =""

IF (NOT EMPTY(THIS.pageImageType)) AND ;
(NOT THIS.supportsPageImages())
IF (NOT THIS.isSuccessor)
THIS.ListenerType = LISTENER_TYPE_PAGED
ENDIF
ENDIF

IF THIS.supportsPageImages()
THIS.makeExternalFileLocationReachable()
ENDIF

IF NOT ISNULL(THIS.successor)
THIS.successor.AddProperty("currentPageImageFilename","")
ENDIF

DODEFAULT()

IF INLIST(THIS.ReadConfiguration,;
OUTPUTCLASS_READCONFIG_REPORT,;
OUTPUTCLASS_READCONFIG_BOTH)
THIS.SetConfiguration()
ENDIF

THIS.resetDataSession()
ENDPROC
PROCEDURE closetargetfile
LOCAL laDummy[1]

IF THIS.TargetHandle &gt; -1

=FCLOSE(THIS.TargetHandle)
THIS.TargetHandle = -1

IF ADIR(laDummy,THIS.TargetFileName) = 1 AND ;
laDummy[1,2] &gt; 0
* NB: have to check this as well as
* error because some COM errors may not
* end up in THIS.HadError.
* if continuation, update status rather than
* modal message
IF THIS.HadError
THIS.DoMessage(OUTPUTCLASS_CREATEERRORS_LOC,MB_ICONEXCLAMATION  )
THIS.lastErrorMessage = OUTPUTCLASS_CREATEERRORS_LOC
ELSE
IF THIS.DoMessage( OUTPUTCLASS_SUCCESS_LOC + ;
IIF(SYS(2024)="Y",CHR(13)+OUTPUTCLASS_REPORT_INCOMPLETE_LOC,""),;
MB_ICONINFORMATION + MB_YESNO ) = IDYES
_CLIPTEXT = THIS.TargetFileName
ENDIF
ENDIF
ELSE
THIS.DoMessage(OUTPUTCLASS_NOCREATE_LOC,MB_ICONSTOP )
THIS.lastErrorMessage = OUTPUTCLASS_NOCREATE_LOC

ENDIF

ENDIF

ENDPROC
PROCEDURE configurationobjtype_access
* readonly property

RETURN OUTPUTCLASS_OBJTYPE_CONFIG

ENDPROC
PROCEDURE createconfigtable
LPARAMETERS m.tcDBF, m.tlOverWrite
LOCAL m.liSelect, m.lcFile

m.lcFile = FORCEEXT(m.tcDBF,"DBF")

IF (NOT EMPTY(SYS(2000,m.lcFile))) AND m.tlOverWrite
ERASE (m.lcFile) RECYCLE
ERASE (FORCEEXT(m.lcFile,"FPT")) RECYCLE
ERASE (FORCEEXT(m.lcFile,"CDX")) RECYCLE
ENDIF

m.liSelect = SELECT(0)

SELECT 0

CREATE TABLE (m.lcFile) FREE ;
(objtype i, ;
objcode i, ;
objname v(60), ;
objvalue v(60), ;
objinfo m)

IF NOT EMPTY(ALIAS()) &amp;&amp; can happen if SAFETY ON and they decide not to overwrite

INDEX ON Objtype TAG ObjType
INDEX ON ObjCode TAG ObjCode
INDEX ON ObjName TAG ObjName
INDEX ON ObjValue TAG ObjValue
INDEX ON DELETED() TAG OnDeleted

INSERT INTO (ALIAS()) VALUES ;
(OUTPUTCLASS_OBJTYPE_CONFIG,0,'DoMessage','"Welcome to the demo run!",64','Sample initialization/config method call')
DELETE NEXT 1

INSERT INTO (ALIAS()) VALUES ;
(OUTPUTCLASS_OBJTYPE_CONFIG,0,'TargetFileName','"xxx"','Sample initialization/config property')
DELETE NEXT 1
USE

ENDIF

SELECT (m.liSelect)
ENDPROC
PROCEDURE currentpageimagefilename_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) # "C"
THIS.currentPageImageFilename = ""
ELSE
THIS.currentPageImageFilename = m.tvNewVal
ENDIF


ENDPROC
PROCEDURE Destroy
THIS.CloseTargetFile()
DODEFAULT()
ENDPROC
PROCEDURE externalfilelocation_assign
LPARAMETERS m.vNewVal
IF THIS.isRunning AND NOT EMPTY(THIS.externalFileLocation)
RETURN
ENDIF
IF VARTYPE(m.vNewVal) = "C"
THIS.externalFileLocation = ALLTRIM(m.vNewVal)
IF NOT EMPTY(THIS.externalFileLocation)
THIS.externalFileLocation = ADDBS(THIS.externalFileLocation)
ENDIF
ENDIF

ENDPROC
PROCEDURE generatepageimagefilename
LPARAMETERS m.tiPage, m.tlFullPath
LOCAL lcFileName

m.lcFileName = FORCEEXT(JUSTSTEM(THIS.targetFileName) + ;
"_" + ;
PADL(TRANSFORM(m.tiPage),;
OUTPUTFILE_MAX_FILEPLACES ,"0"), ;
THIS.pageImageExtension)
IF m.tlFullPath
RETURN  FULLPATH(FORCEPATH( m.lcFileName,THIS.ExternalFileLocation),;
ADDBS(JUSTPATH(THIS.TargetFileName)))
ELSE
RETURN FORCEPATH(m.lcFileName,THIS.externalFileLocation)
ENDIF


ENDPROC
PROCEDURE getconfigtable
LPARAMETERS m.tlForceExternal

LOCAL m.lcDBF, m.lcPath

m.lcDBF = ""

IF m.tlForceExternal OR (NOT EMPTY(SYS(2000,FULLPATH(FORCEEXT(OUTPUTCLASS_EXTERNALDBF,"DBF")))))
m.lcDBF = FULLPATH(FORCEEXT(OUTPUTCLASS_EXTERNALDBF,"DBF"))
ELSE
m.lcDBF = FORCEEXT(OUTPUTCLASS_INTERNALDBF,"DBF")
ENDIF

IF NOT (FILE(m.lcDBF) OR THIS.IsRunning)

m.lcPath = THIS.GetPathForExternals()
* this may be the internal *or* external dbf name;
* we could be testing and not yet built into an app,
* so accept either, before the next test:
m.lcDBF = FORCEPATH(m.lcDBF,m.lcPath)

IF NOT FILE(m.lcDBF)
* now force to the external name:
m.lcDBF = FORCEEXT(FORCEPATH(OUTPUTCLASS_EXTERNALDBF,m.lcPath),"DBF")
* now check again
IF NOT FILE(m.lcDBF)
THIS.CreateConfigTable(m.lcDBF)
IF FILE(m.lcDBF)
THIS.DoMessage(OUTPUTCLASS_CONFIGTABLECREATED_LOC)
ENDIF
ENDIF
ENDIF

ENDIF

IF NOT FILE(m.lcDBF)
m.lcDBF = ""
ENDIF

THIS.ConfigurationTable = m.lcDBF

RETURN m.lcDBF
ENDPROC
PROCEDURE getpageimageextension
LOCAL lcExt
m.lcExt = ""
DO CASE
CASE INLIST(THIS.pageImageType,;
LISTENER_DEVICE_TYPE_TIF,;
LISTENER_DEVICE_TYPE_MTIF)
m.lcExt = "TIF"
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_JPG
m.lcExt = "JPG"
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_GIF
m.lcExt = "GIF"
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_PNG
m.lcExt = "PNG"
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_BMP
m.lcExt = "BMP"
ENDCASE

RETURN m.lcExt
ENDPROC
PROCEDURE Init
IF DODEFAULT()
* NB: this one doesn't necessarily need its
* own AppName LOC'd value, because
* it is basically an abstract layer
* and should not be instantiated directly.
* Doesn't hurt, though.
THIS.appName = OUTPUTFILE_APPNAME_LOC

IF INLIST(THIS.ReadConfiguration,;
OUTPUTCLASS_READCONFIG_INIT,;
OUTPUTCLASS_READCONFIG_BOTH)
THIS.SetConfiguration(.T.)
ENDIF

ELSE

RETURN .F.

ENDIF

RETURN NOT THIS.HadError
ENDPROC
PROCEDURE makeexternalfilelocationreachable
IF EMPTY(THIS.externalFileLocation)
THIS.externalFileLocation = "."
ENDIF
IF NOT DIRECTORY(FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))
TRY
MD (FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))
CATCH
LOCAL m.llRunning
m.llRunning = THIS.isRunning
THIS.isRunning = .F.
THIS.externalFileLocation = "."
THIS.isRunning = m.llRunning
ENDTRY
ENDIF

ENDPROC
PROCEDURE opentargetfile
THIS.VerifyTargetFile()

THIS.TargetHandle = FCREATE(THIS.TargetFileName)

IF THIS.TargetHandle &lt; 0 OR THIS.HadError
THIS.HadError = .T.
THIS.DoMessage(OUTPUTCLASS_NOFILECREATE_LOC,MB_ICONSTOP )
THIS.lastErrorMessage = OUTPUTCLASS_NOFILECREATE_LOC
ENDIF

RETURN (NOT THIS.HadError)

ENDPROC
PROCEDURE OutputPage
LPARAMETERS nPageNo, eDevice, nDeviceType, nLeft, nTop, nWidth, nHeight, nClipLeft, nClipTop, nClipWidth, nClipHeight

IF THIS.supportsPageImages("OUTPUTPAGE")
IF m.nDeviceType &lt; 100
* ascertain that this is the native call; have to make
* sure it's not recursive...
THIS.OutputPageImage(m.nPageNo)
ENDIF
ELSE
IF m.nDeviceType &gt; 99
DODEFAULT(nPageNo, eDevice, nDeviceType)
ENDIF
ENDIF

ENDPROC
PROCEDURE outputpageimage
LPARAMETERS m.tiPage

LOCAL m.lcFile, m.llError

TRY
IF THIS.pageImageType = LISTENER_DEVICE_TYPE_MTIF
m.lcFile = THIS.generatePageImageFilename(1, .T.)
IF m.tiPage = 1
IF NOT EMPTY(SYS(2000,m.lcFile))
ERASE (m.lcFile) NORECYCLE
ENDIF
THIS.OutputPage(m.tiPage,m.lcFile,LISTENER_DEVICE_TYPE_TIF )
ELSE
THIS.OutputPage(m.tiPage,m.lcFile,LISTENER_DEVICE_TYPE_MTIF )
ENDIF
ELSE
m.lcFile = THIS.generatePageImageFilename(m.tiPage, .T.)
IF NOT EMPTY(SYS(2000,m.lcFile))
ERASE (m.lcFile) NORECYCLE
ENDIF
THIS.OutputPage(m.tiPage,m.lcFile,THIS.pageImageType)
ENDIF
CATCH WHEN .T.
m.llError = .T.
ENDTRY

RETURN (NOT m.llError)

ENDPROC
PROCEDURE pageimagetype_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
(m.vNewVal = 0 OR ;
INLIST(m.vNewVal,;
LISTENER_DEVICE_TYPE_EMF,;
LISTENER_DEVICE_TYPE_TIF,;
LISTENER_DEVICE_TYPE_JPG,;
LISTENER_DEVICE_TYPE_GIF,;
LISTENER_DEVICE_TYPE_PNG,;
LISTENER_DEVICE_TYPE_BMP,;
LISTENER_DEVICE_TYPE_MTIF))
THIS.pageImageType = m.vNewVal
THIS.pageImageExtension = THIS.getPageImageExtension()
ENDIF



ENDPROC
PROCEDURE readconfiguration_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
THIS.ReadConfiguration = m.vNewVal
ENDIF

ENDPROC
PROCEDURE setconfiguration
LPARAMETERS m.tlCalledFromInit

IF NOT THIS.IsRunning
* do some config work, don't change sessions --
* at this point we don't have our private session
* if we're being called in the Init

LOCAL m.liSelect, m.lcPEM, m.llOpened, m.lcOrder, m.liType, m.llQuiet

m.liSelect = SELECT(0)

IF NOT USED("OutputConfig")
* if called from Init,
* do this in quietmode
* because the caller has no
* opportunity to
* turn off the message
m.llQuiet = (m.tlCalledFromInit AND NOT THIS.QuietMode)
IF m.llQuiet
THIS.QuietMode = .T.
ENDIF
THIS.GetConfigTable()
IF m.llQuiet
THIS.QuietMode = .F.
ENDIF
USE (THIS.ConfigurationTable) ALIAS "OutputConfig" IN 0 AGAIN NOUPDATE SHARED
m.llOpened = .T.
ELSE
m.lcOrder = ORDER("OutputConfig")
SET ORDER TO ObjCode
ENDIF

IF (NOT THIS.HadError) AND THIS.VerifyConfigTable("OutputConfig")

SELECT OutputConfig
m.liType = THIS.ConfigurationObjtype

SCAN FOR ObjType = m.liType AND ;
NOT(DELETED() OR ;
ObjName == "" OR ;
ObjValue =="" )

IF PEMSTATUS(THIS,ObjName,5)
m.lcPEM = UPPER(PEMSTATUS(THIS,ObjName,3))
DO CASE
CASE lcPEM == "PROPERTY"
STORE EVAL(ObjValue) TO ("THIS."+ObjName)
CASE INLIST("|"+lcPEM+"|","|METHOD|","|EVENT|")
EVAL("THIS."+ObjName+"("+ObjValue+")")
OTHERWISE
ENDCASE
ENDIF

ENDSCAN

IF m.llOpened
USE IN OutputConfig
ELSE
SET ORDER TO (m.lcOrder) IN OutputConfig
ENDIF

ENDIF

SELECT (m.liSelect)

ENDIF

ENDPROC
PROCEDURE setfrxdatasessionenvironment
DODEFAULT()
SET DELETED ON
SET EXCLUSIVE OFF
SET TALK OFF

ENDPROC
PROCEDURE supportspageimages
LPARAMETERS tcMethodToken

DO CASE
CASE THIS.isSuccessor OR EMPTY(THIS.pageImageType)
RETURN .F.
CASE EMPTY(m.tcMethodToken)
RETURN THIS.ListenerType # LISTENER_TYPE_DEF
* this indicates the set we are supporting in total
CASE m.tcMethodToken = "OUTPUTPAGE"
RETURN INLIST(THIS.ListenerType,LISTENER_TYPE_PRN,LISTENER_TYPE_PAGED)
CASE INLIST(m.tcMethodToken,"AFTERREPORT","UNLOADREPORT")
RETURN INLIST(THIS.ListenerType,LISTENER_TYPE_PRV,LISTENER_TYPE_ALLPGS)
ENDCASE
ENDPROC
PROCEDURE targetfileext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT THIS.IsRunning
THIS.targetfileext = m.vNewVal
ENDIF

ENDPROC
PROCEDURE targetfilename_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT THIS.IsRunning
THIS.targetfilename = m.vNewVal
ENDIF

ENDPROC
PROCEDURE targethandle_assign
LPARAMETERS m.vNewVal
* Readonly during report run
IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
THIS.targethandle = m.vNewVal
ENDIF

ENDPROC
PROCEDURE verifyconfigtable
LPARAMETERS m.tcAlias, m.tcFailureMsgTable, m.tcFailureMsgIndexes

IF EMPTY(m.tcAlias) OR VARTYPE(m.tcAlias) # "C"
RETURN .F.
ENDIF
LOCAL m.lcTable, m.lcMessage, m.lcAlias, m.liSelect, ;
m.llReturn, m.liTagCount, laRequired[1], laKeys[1], ;
m.liFound, m.llExactOff, m.llSafetyOn

m.llReturn = ;
TYPE(m.tcAlias+".OBJTYPE") = "N" AND ;
TYPE(m.tcAlias+".OBJCODE") = "N" AND ;
TYPE(m.tcAlias+".OBJNAME") = "C" AND ;
TYPE(m.tcAlias+".OBJVALUE") = "C" AND ;
TYPE(m.tcAlias+".OBJINFO") = "M"

* additional fields may be included and order
* is not significant

IF NOT m.llReturn

m.lcMessage = IIF(EMPTY(m.tcFailureMsgTable),;
OUTPUTCLASS_CONFIGTABLEWRONG_LOC, ;
m.tcFailureMsgTable)  + ;
CHR(13)+CHR(13)+ ;
DBF(m.tcAlias)
ENDIF


IF m.llReturn

IF (SET("EXACT") = "OFF")
SET EXACT ON
m.llExactOff = .T.
ENDIF

m.liSelect = SELECT(0)
SELECT (m.tcAlias)

* check for required keys...

DIME laRequired[5]
laRequired[1] = "OBJTYPE"
laRequired[2] = "OBJCODE"
laRequired[3] = "OBJNAME"
laRequired[4] = "OBJVALUE"
laRequired[5] = "DELETED()"

IF TAGCOUNT() &gt; 0
DIME laKeys[TAGCOUNT()]

FOR m.liTagCount = 1 TO TAGCOUNT()
laKeys[m.liTagCount] = UPPER(KEY(m.liTagCount))
ENDFOR

FOR m.liTagCount = 1 TO ALEN(laRequired)
m.liFound = ASCAN(laKeys,UPPER(laRequired[m.liTagCount]))
IF m.liFound = 0
m.llReturn = .F.
EXIT
ENDIF
ENDFOR
ELSE
m.llReturn = .F.
ENDIF

IF NOT m.llReturn

m.llSafetyOn = (SET("SAFETY") = "ON")
SET SAFETY OFF

TRY
USE (DBF(m.tcAlias)) EXCLU ALIAS (m.tcAlias)
INDEX ON Objtype TAG ObjType
INDEX ON ObjCode TAG ObjCode
INDEX ON ObjName TAG ObjName
INDEX ON ObjValue TAG ObjValue
INDEX ON DELETED() TAG OnDeleted
m.llReturn = .T.
CATCH
ENDTRY

IF m.llSafetyOn
SET SAFETY ON
ENDIF

IF m.llReturn
DIME laKeys[TAGCOUNT()]

FOR m.liTagCount = 1 TO TAGCOUNT()
laKeys[m.liTagCount] = UPPER(KEY(m.liTagCount))
ENDFOR

FOR m.liTagCount = 1 TO ALEN(laRequired)
m.liFound = ASCAN(laKeys,UPPER(laRequired[m.liTagCount]))
IF m.liFound = 0
m.llReturn = .F.
EXIT
ENDIF
ENDFOR
ENDIF

USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)

ENDIF

IF NOT m.llReturn
m.lcMessage =  IIF(EMPTY(m.tcFailureMsgIndexes),;
OUTPUTCLASS_CONFIGINDEXMISSING_LOC, ;
m.tcFailureMsgTable) + CHR(13)
FOR m.liTagCount = 1 TO ALEN(laRequired)
m.lcMessage = m.lcMessage +  CHR(13) + ;
laRequired[m.liTagCount]
ENDFOR
ENDIF

IF m.llExactOff
SET EXACT OFF
ENDIF
SELECT (m.liSelect)

ENDIF

IF NOT(m.llReturn)
THIS.DoMessage(m.lcMessage,MB_ICONSTOP )
THIS.lastErrorMessage = m.lcMessage
ENDIF

RETURN m.llReturn


ENDPROC
PROCEDURE verifytargetfile
LOCAL m.lcFile

m.lcFile =  ALLTR(CHRTRAN(CHRTRAN(THIS.TargetFileName,;
OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_"),"/","\"))
* embracing chrtran for slashes is necessary because of FULLPATH behavior.

IF NOT DIRECTORY(JUSTPATH(m.lcFile))
m.lcFile = FULLPATH(ALLTR(m.lcFile))
ENDIF

IF DIRECTORY(m.lcFile)
* we have to generate a filename
m.lcFile = FORCEPATH(SYS(2015), m.lcFile)
ENDIF

THIS.TargetFileName = m.lcFile

IF JUSTEXT(THIS.TargetFileName) == "" AND ;
RIGHT(THIS.TargetFileName,1) # "."

THIS.TargetFileExt = CHRTRAN(THIS.TargetFileExt,;
OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_")

THIS.TargetFileName = FORCEEXT(THIS.TargetFileName, ;
THIS.TargetFileExt)
ENDIF

IF NOT EMPTY(SYS(2000,THIS.TargetFileName))
ERASE (THIS.TargetFileName) NORECYCLE
ENDIF

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>readconfiguration Indicates the conditions under which SetConfiguration code will run. 0=never, 1 = when the class instance Init runs, 2 = when the class instance runs BeforeReport, 3 = at both Init and BeforeReport.
targetfileext Provides the default file extension for file output.
targetfilename Provides the filename to which output will be written.  A unique name is generated for the class instance, which will be overwritten for successive report runs if not adjusted by the user.
targethandle Provides a low-level file handle, to which output is written directly when the class provides raw data to the file, otherwise reserves the file during the report run so other applications don't write to it .
configurationobjtype Holds the reserved value used to indicate that a configuration table row provides dynamic configuration information at runtime.
configurationtable Holds the name of the current configuration table.
externalfilelocation Assigns a  UNC or file system path, either relative to the main output target or absolute, the file-outputting process uses for external files, such as images, it creates along with the main output target. 
pageimagetype Indicates a type of image file you want generated for each output page in a report run at the conclusion of a chained report set.
pageimageextension Caches appropriate image file extension for current pageImageType.
currentpageimagefilename Provides the filename for the generated page image file for the current page during a report run, including the externalFileLocation path, which may be relative.
*readconfiguration_assign 
*setconfiguration Checks the current configuration table for dynamic information in records of appropriate type, and executes these instructions if found.
*getconfigtable Assesses and provides the name of the current configuration table, optionally creating it on disk if it is not available. 
*createconfigtable Creates a configuration table on demand.
*opentargetfile Initializes a file for output purposes.
*verifytargetfile Assures that the nominated filename and its network location are available at the beginning of a file-based report run.
*targetfileext_assign 
*targetfilename_assign 
*targethandle_assign 
*closetargetfile Finalizes file output.
*verifyconfigtable Ascertains that the format and and contents of the configuration meet requirements, adjusting it if necessary.
*configurationobjtype_access 
*externalfilelocation_assign 
*pageimagetype_assign 
*getpageimageextension Provides the appropriate file extension for the current pageImageType value.
*generatepageimagefilename Creates a filename for a generated page image file.
*supportspageimages Evaluates whether the current reporting mode supports generating page images.
*outputpageimage Use OutputPage method to create a page image file according to current report's requirements.
*currentpageimagefilename_assign 
*makeexternalfilelocationreachable Checks to see if the externalFileLocation (which may be relative to the current targetfilename) exists in the current environment, adjusting if necessary when the output process determines the need to create ancillary output files along with main target.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Adds configuration table handling and output target file handling to fxListener class</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>utilityreportlistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1QM0BUK5J</uniqueid>
		<timestamp>923837222</timestamp>
		<class>fxabstract</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>gfxnorender</objname>
		<parent/>
		<properties>Height = 17
Width = 98
listener = (.NULL.)
norenderdataalias = ("GNR"+SYS(2015))
_memberdata = &lt;VFPData&gt;&lt;memberdata name="applyfx" type="property" display="applyFX" favorites="True"/&gt;&lt;memberdata name="omitrendering" display="omitRendering" type="method"/&gt;&lt;memberdata name="norenderdataalias" display="noRenderDataAlias" type="property"/&gt;&lt;/VFPData&gt;
Name = "gfxnorender"
</properties>
		<protected>listener
norenderdataalias
omitrendering
</protected>
		<methods>PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

LOCAL m.liSession, m.liSelect, m.liFRXRecno, m.liReturn, ;
m.llNoRender, m.llSwap, m.lcConditions, m.err AS Exception
m.liReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR

DO CASE
CASE m.tcMethodToken == "RENDER" AND ;
NOT ISNULL(m.toListener.FFCGraphics)
TRY
m.liSession = SET("DATASESSION")
SET DATASESSION TO m.toListener.FRXDataSession
m.liSelect = SELECT(0)
IF USED(THIS.noRenderDataAlias)
SELECT (THIS.noRenderDataAlias)
m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
LOCATE FOR FrxRecno = m.liFRXRecno AND PreProcess
* there won't be any if it's a Sedna-type build, unless it was a built-in report
* to another app and we couldn't make the swap.
IF FOUND()
m.llNoRender = THIS.omitRendering(m.toListener, ALLTRIM(Execute))
ENDIF
IF NOT (m.llNoRender)
* rendering override for this instance in the report
LOCATE FOR FrxRecno = m.liFRXRecno AND NOT PreProcess
IF FOUND()
m.llNoRender = THIS.omitRendering(m.toListener, ALLTRIM(Execute))
ENDIF
ENDIF
IF m.llNoRender
m.liReturn = OUTPUTFX_BASERENDER_NORENDER
ENDIF
ENDIF
CATCH TO m.err
#IF OUTPUTCLASS_DEBUGGING
m.toListener.DoMessage(m.err.Message)
#ELSE
* could expose this error but won't,
* we'll just swallow it
* code line here for suspend capabilities
m.liReturn = m.liReturn
#ENDIF
FINALLY
SELECT (m.liSelect)
SET DATASESSION TO (m.liSession)
ENDTRY
CASE m.tcMethodToken == "LOADREPORT" AND ;
VERSION(4) &gt; "09.00.0000.3504" AND ;
(NOT m.toListener.CommandClauses.IsDesignerLoaded) AND ;
FILE(m.toListener.CommandClauses.File)

* We can't do this in a design session because
* of the Designer's lock on the original file.
* We also can't do this in SP1 or below,
* or when the report is built in to a different app.
* (Note the use of FILE() rather than SYS(2000) here,
* it's okay if it's not on disk.)
* We will still handle this at render time if we can't make the swap;
* (we just won't get the performance benefits of preprocess-deletion)
TRY
m.liSession = SET("DATASESSION")
SET DATASESSION TO m.toListener.FRXDataSession
m.liSelect = SELECT(0)
* nb: this is before memberdata is normally available.
SELECT 0

USE (m.toListener.CommandClausesFile) ;
AGAIN NOUPDATE SHARED ALIAS  FRX
m.toListener.FRXCursor.UnpackFrxMemberData("FRX",;
m.toListener.MemberDataAlias, m.toListener.FRXDataSession)
USE IN FRX
IF USED(m.toListener.MemberDataAlias)
SELECT (m.toListener.MemberDataAlias)
LOCATE FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER AND ;
NOT EMPTY(Execute)
IF FOUND()
* check to see if we are already working on
* a temporary report.
IF (NOT m.toListener.isFRXSwapCopyPresent())
* must perform the swap, storing
* CommandClauses.File for later use
m.llSwap = .T.
m.toListener.prepareFRXSwapCopy(,,.T.)
ENDIF
* After creating swap report or ascertaining that
* we are already working with a temp report,
* delete the items in that report as required.
* BUT FIRST make sure the swap went through as planned.
IF m.llSwap AND ;
(EMPTY(m.toListener.CommandClauses.File) OR ;
EMPTY(SYS(2000,m.toListener.CommandClauses.File)))
m.llSwap = .F.
m.toListener.CommandClauses.File = ;
m.toListener.commandClausesFile
ENDIF
* now if we're positive we're in the right place
* and that we have possible memberdata content
* we can start deleting records out of the swap copy:
IF USED(m.toListener.MemberDataAlias) AND ;
NOT (m.toListener.CommandClauses.File == ;
m.toListener.commandClausesFile)
USE (m.toListener.CommandClauses.File) IN 0 ;
AGAIN EXCLU ALIAS FRX
* can't do a NOUP to do the delete.
* since we're in a private copy,
* we switch this to an
* EXCLU and PACK although it doesn't appear
* to be necessary for the engine's POV.
* This means users of this copy of the
* FRX don't have to pay attention to
* whether some records are potentially-deleted.

SELECT (m.toListener.MemberDataAlias)
SCAN FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER AND ;
NOT EMPTY(Execute)
m.liRecno = FRXRecno
m.llNoRender = THIS.omitRendering(m.toListener,ALLTRIM(Execute))
IF m.llNoRender
SELECT FRX
DELETE ALL FOR RECNO() = m.liRecno
SELECT (m.toListener.MemberDataAlias)
ENDIF
ENDSCAN
SELECT FRX
PACK
ENDIF
ENDIF
ENDIF
CATCH TO m.err
* revert the swap if we did one
* being careful not to remove the original report
#IF OUTPUTCLASS_DEBUGGING
m.toListener.DoMessage(OUTPUTFX_CONDITIONALRENDERING_UNAVAILABLE_LOC + ;
CHR(13) + m.err.Message )
#ENDIF
IF m.llSwap
m.toListener.removeFRXSwapCopy(,OUTPUTCLASS_DEBUGGING )
ENDIF
FINALLY
IF USED("FRX")
USE IN FRX
ENDIF
* we must close this early version of the
* memberdata cursor -- later its frxrecno values
* will be re-created correctly
IF USED(m.toListener.MemberDataAlias)
USE IN (m.toListener.MemberDataAlias)
ENDIF
SELECT (m.liSelect)
SET DATASESSION TO (m.liSession)
ENDTRY
CASE m.tcMethodToken == "BEFOREREPORT"
m.liSession = SET("DATASESSION")
SET Datasession TO m.toListener.FRXDataSession
IF USED(m.toListener.MemberDataAlias)
m.liSelect = SELECT(0)
m.lcConditions = "(ExecWhen == '" + FRX_BLDR_ADVPROP_PREPROCESS_NORENDER + "' OR " + ;
" ExecWhen == '" + FRX_BLDR_ADVPROP_INSTANCE_NORENDER +"' ) "
SELECT FrxRecno,ExecWhen,Execute, ;
IIF(ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER, .T., .F.) AS PreProcess ;
FROM (m.toListener.MemberDataAlias) ;
INTO CURSOR (THIS.noRenderDataAlias) ;
WHERE Type = FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
(NOT EMPTY(Execute)) AND &amp;lcConditions.
IF RECCOUNT(THIS.noRenderDataAlias) = 0
USE IN (THIS.noRenderDataAlias)
ELSE
SELECT (THIS.noRenderDataAlias)
INDEX ON FrxRecno TAG FrxRecno
ENDIF
SELECT (m.liSelect)
ENDIF
SET Datasession TO (m.liSession)
CASE m.tcMethodToken == "UNLOADREPORT"
* if swap was performed, and if the temporary
* report is still "in place"
* as commandClausesFile
* get rid of temporary report
* if there is one and if it still exists
* and return CommandClauses.File to its original value
* it should not matter what order objects handle this
IF m.toListener.isFRXSwapCopyPresent()
m.liSession = SET("DATASESSION")
SET DATASESSION TO m.toListener.FRXDataSession
IF USED(THIS.noRenderDataAlias)
USE IN (THIS.noRenderDataAlias)
ENDIF
m.liSelect = SELECT(0)
IF USED("FRX")
m.llSwap = .T.
SELECT FRX
USE
ENDIF
m.toListener.removeFRXSwapCopy(,OUTPUTCLASS_DEBUGGING )
IF m.llSwap
SELECT 0
USE (m.toListener.CommandClauses.File) ALIAS FRX NOUPDATE
ENDIF
SELECT (m.liSelect)
SET DATASESSION TO (m.liSession)
ENDIF
ENDCASE

RETURN  m.liReturn
ENDPROC
PROCEDURE Destroy
THIS.listener = NULL
ENDPROC
PROCEDURE omitrendering
LPARAMETERS m.toListener, m.tcExpr
LOCAL m.llNoRender, m.liSession
IF VARTYPE(m.tcExpr) = "C"
m.liSession = SET("DATASESSION")
THIS.listener = m.toListener
SET DATASESSION TO m.toListener.CurrentDataSession
IF TYPE(m.tcExpr) = "L"
m.llNoRender = EVALUATE(m.tcExpr)
SET DATASESSION TO m.toListener.FRXDataSession
ELSE
SET DATASESSION TO m.toListener.FRXDataSession
IF TYPE(m.tcExpr) = "L"
m.llNoRender = EVALUATE(m.tcExpr)
ENDIF
ENDIF
THIS.listener = NULL
SET DATASESSION TO (m.liSession)
ENDIF
RETURN m.llNoRender
ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>listener Holds a ReportListener reference during applyFX processing for use in evaluating "Render When" conditions.
norenderdataalias Alias of private cursor for gfxNoRender subset of memberdata.
*omitrendering Evaluates Rendering requirements, returning True or False, in both current and frx data sessions.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Conditionally eliminates default rendering behavior for report layout controls by evaluating a ReportListener-referencing expression specified in MemberData.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>gfxnorender</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_13T0MHHPZ</uniqueid>
		<timestamp>924270456</timestamp>
		<class>reportlistener</class>
		<classloc/>
		<baseclass>reportlistener</baseclass>
		<objname>_reportlistener</objname>
		<parent/>
		<properties>Height = 23
Width = 23
FRXDataSession = -1
AllowModalMessages = (INLIST(_VFP.Startmode, 0, 4))
QuietMode = (NOT INLIST(_VFP.Startmode, 0, 4))
appname = ("VFP Report Listener")
lasterrormessage = ("")
reportfilenames = (NULL)
reportclauses = (NULL)
listeners = (NULL)
listenerdatasession = 1
successor = (NULL)
sharedgdiplusgraphics = 0
sharedpageheight = 0
sharedpagewidth = 0
drivingalias = ("")
_memberdata =     5188&lt;VFPData&gt;&lt;memberdata name="addreport" type="method" display="addReport" favorites="True" /&gt;&lt;memberdata name="appname" type="property" display="appName" favorites="True" /&gt;&lt;memberdata name="clearerrors" type="method" display="clearErrors" favorites="True" /&gt;&lt;memberdata name="drivingalias" type="property" display="drivingAlias" favorites="False" /&gt;&lt;memberdata name="getfrxstartupinfo" type="method" display="getFRXStartupInfo" favorites="False" /&gt;&lt;memberdata name="getlasterrormessage" type="method" display="getLastErrorMessage" favorites="True" /&gt;&lt;memberdata name="haderror" type="property" display="hadError" favorites="False" /&gt;&lt;memberdata name="invokeoncurrentpass" type="method" display="invokeOnCurrentPass" favorites="True" /&gt;&lt;memberdata name="isrunning" type="property" display="isRunning" favorites="False" /&gt;&lt;memberdata name="isrunningreports" type="property" display="isRunningReports" favorites="False" /&gt;&lt;memberdata name="issuccessor" type="property" display="isSuccessor" favorites="True" /&gt;&lt;memberdata name="lasterrormessage" type="property" display="lastErrorMessage" favorites="False" /&gt;&lt;memberdata name="lignoreerrors" type="property" display="lIgnoreErrors" favorites="False" /&gt;&lt;memberdata name="listeners" type="property" display="listeners" favorites="False" /&gt;&lt;memberdata name="popglobalsets" type="method" display="popGlobalSets" favorites="False" /&gt;&lt;memberdata name="prepareerrormessage" type="method" display="prepareErrorMessage" favorites="True" /&gt;&lt;memberdata name="pushglobalsets" type="method" display="pushGlobalSets" favorites="False" /&gt;&lt;memberdata name="removereports" type="method" display="removeReports" favorites="True" /&gt;&lt;memberdata name="reportclauses" type="property" display="reportClauses" favorites="False" /&gt;&lt;memberdata name="reportfilenames" type="property" display="reportFilenames" favorites="False" /&gt;&lt;memberdata name="reportpages" type="property" display="reportPages" favorites="False" /&gt;&lt;memberdata name="reportusesprivatedatasession" type="property" display="reportUsesPrivateDataSession" favorites="True" /&gt;&lt;memberdata name="resetdatasession" type="method" display="resetDataSession" favorites="False" /&gt;&lt;memberdata name="runreports" type="method" display="runReports" favorites="True" /&gt;&lt;memberdata name="setcurrentdatasession" type="method" display="setCurrentDataSession" favorites="False" /&gt;&lt;memberdata name="setfrxdatasession" type="method" display="setFRXDataSession" favorites="False" /&gt;&lt;memberdata name="setfrxdatasessionenvironment" type="method" display="setFRXDataSessionEnvironment" favorites="False" /&gt;&lt;memberdata name="setsuccessordynamicproperties" type="method" display="setSuccessorDynamicProperties" favorites="True" /&gt;&lt;memberdata name="sharedgdiplusgraphics" type="property" display="sharedGdiplusGraphics" favorites="True" /&gt;&lt;memberdata name="sharedpagetotal" type="property" display="sharedPageTotal" favorites="True" /&gt;&lt;memberdata name="sharedoutputpagecount" type="property" display="sharedOutputPageCount" favorites="True" /&gt;&lt;memberdata name="sharedpageno" type="property" display="sharedPageNo" favorites="True" /&gt;&lt;memberdata name="sharedpageheight" type="property" display="sharedPageHeight" favorites="True" /&gt;&lt;memberdata name="sharedpagewidth" type="property" display="sharedPageWidth" favorites="True" /&gt;&lt;memberdata name="listenerdatasession" type="property" display="listenerDataSession" favorites="False" /&gt;&lt;memberdata name="successor" type="property" display="successor" favorites="True" /&gt;&lt;memberdata name="setfrxrunstartupconditions" type="method" display="setFRXRunStartupConditions"/&gt;&lt;memberdata name="pagelimit" type="property" display="pageLimit" favorites="True" /&gt;&lt;memberdata name="pagetoplimit" type="property" display="pageTopLimit" favorites="True" /&gt;&lt;memberdata name="pagetaillimit" type="property" display="pageTailLimit" favorites="True" /&gt;&lt;memberdata name="pagelimitquietmode" type="property" display="pageLimitQuietMode" favorites="True" /&gt;&lt;memberdata name="pagelimitinsiderange" type="property" display="pageLimitInsideRange" favorites="True" /&gt;&lt;memberdata name="resetdynamicmethodcalls" type="method" display="resetDynamicMethodCalls"/&gt;&lt;memberdata name="resetcallevaluatecontents" type="method" display="resetCallEvaluateContents"/&gt;&lt;memberdata name="resetcalladjustobjectsize" type="method" display="resetCallAdjustObjectSize"/&gt;&lt;memberdata name="runcollector" display="runCollector" type="property" favorites="True"/&gt;&lt;memberdata name="resetruncollector" display="resetRunCollector" type="method"/&gt;&lt;memberdata name="fillruncollector" display="fillRunCollector" type="method"/&gt;&lt;memberdata name="frxheaderrecno" display="frxHeaderRecno" type="property"/&gt;&lt;memberdata name="sharedlistenertype" display="sharedListenerType" type="property"/&gt;&lt;memberdata name="commandclausesfile" display="commandClausesFile" type="property" favorites="True"/&gt;&lt;memberdata name="preparefrxswapcopy" display="prepareFRXSwapCopy" type="method"/&gt;&lt;memberdata name="removefrxswapcopy" display="removeFRXSwapCopy" type="method"/&gt;
&lt;memberdata name="isfrxswapcopypresent" display="isFRXSwapCopyPresent" type="method"/&gt;
&lt;memberdata name="adjustreportpagesinfo" display="adjustReportPagesInfo" type="method"/&gt;
&lt;/VFPData&gt;
sharedoutputpagecount = 0
sharedpageno = 0
sharedpagetotal = 0
pagelimit = -1
pagetoplimit = -1
pagetaillimit = -1
pagelimitquietmode = .F.
pagelimitinsiderange = .F.
runcollector = (NULL)
frxheaderrecno = 1
sharedlistenertype = -1
commandclausesfile = .NULL.
Name = "_reportlistener"
</properties>
		<protected>haderror
isrunning
lasterrormessage
isrunningreports
reportfilenames
reportclauses
listeners
drivingalias
runcollector
frxheaderrecno
pushglobalsets
popglobalsets
setfrxdatasessionenvironment
resetdatasession
setfrxdatasession
setcurrentdatasession
getfrxstartupinfo
setfrxrunstartupconditions
resetdynamicmethodcalls
resetcalladjustobjectsize
resetcallevaluatecontents
resetruncollector
fillruncollector
adjustreportpagesinfo
</protected>
		<methods>PROCEDURE addreport
LPARAMETERS m.tcFRXName, m.tcClauses, m.toListener

* can this one be done while report is running?
* Possibly yes because we're always adding to the end.

IF VARTYPE(m.tcFrxName) = "C" AND ;
(FILE(m.tcFRXName) OR FILE(FORCEEXT(m.tcFRXName,"FRX")) OR FILE(FORCEEXT(m.tcFRXName,"LBX")))

* If any is null, create all collections
* always add to all three collections
* to keep them in synch

IF ISNULL(THIS.ReportFileNames) OR ;
ISNULL(THIS.ReportClauses) OR ;
ISNULL(THIS.Listeners)
* start fresh
* this *shouldn't* be a datasession problem
* unless they're doing it from inside a form,
* but JIC:
LOCAL liSession
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
THIS.ReportFileNames = CREATEOBJECT("Collection")
THIS.ReportClauses = CREATEOBJECT("Collection")
THIS.Listeners = CREATEOBJECT("Collection")
DIME THIS.ReportPages[1]
SET DATASESSION TO (m.liSession)
ENDIF

THIS.ReportFileNames.Add(m.tcFRXName)

DIME THIS.ReportPages[THIS.ReportFileNames.Count]
THIS.ReportPages[THIS.ReportFileNames.Count] = 0

IF VARTYPE(m.tcClauses) = "C"
THIS.ReportClauses.Add(m.tcClauses)
ELSE
THIS.ReportClauses.Add("")
ENDIF

IF TYPE("toListener.BaseClass") = "C" AND ;
UPPER(toListener.BaseClass) == "REPORTLISTENER"
THIS.Listeners.Add(toListener)
ELSE
THIS.Listeners.Add(NULL)
ENDIF

ELSE

* TBD: should we error here?

ENDIF


ENDPROC
PROCEDURE adjustreportpagesinfo
LPARAMETERS m.tiReportIndex, m.tcClauses, m.toListener

* this is a *sketch*.  There are lots of different ways you
* could decide you wanted this to work.
* Subclasses can make this a multi-column array with
* output pages (responsive to RANGE clause)
* represented as well, decide when to accumulate and when not,
* or whether to set up a separate array col for
* curr page versus total page,
* when to use listener ref data versus _PAGENO when a
* listener ref is available,
* and if so how to deal with NORESET,
* when to use the shared/writable versions of FFC's SharedPageNo
* and SharedPageTotal versus the readonly product versions,
* because they are more similar to _PAGENO and _PAGETOTAL,
* whether page limits (top and tail) are significant, etc, etc, etc, etc.

IF m.tiReportIndex = 1
* adjust the columns however you want to use them...
* in our version:
IF ALEN(THIS.reportPages,2) &lt; 2
DIME THIS.reportPages(THIS.ReportFileNames.Count,2)
ENDIF

ENDIF
IF THIS.ReportFileNames.Count &gt;= m.tiReportIndex
IF ISNULL(m.toListener)
THIS.reportPages[m.tiReportIndex,1] = _PAGENO
ELSE
THIS.reportPages[m.tiReportIndex,1] = m.toListener.PageNo
ENDIF
IF m.tiReportIndex = 1
THIS.reportPages[m.tiReportIndex,2] = THIS.reportPages[m.tiReportIndex,1]
ELSE
THIS.reportPages[m.tiReportIndex,2] = ;
THIS.reportPages[m.tiReportIndex,1] + ;
THIS.reportPages[m.tiReportIndex-1,2]
ENDIF
ENDIF
ENDPROC
PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecno
IF NOT ISNULL(THIS.Successor)
THIS.SetSuccessorDynamicProperties()
THIS.Successor.AfterBand(m.nBandObjCode, m.nFRXRecNo)
ENDIF

ENDPROC
PROCEDURE AfterReport
IF NOT THIS.IsSuccessor
THIS.SharedPageWidth = THIS.GetPageWidth()
THIS.SharedPageHeight = THIS.GetPageHeight()
ENDIF

IF NOT ISNULL(THIS.Successor)
WITH THIS.Successor
.FRXDataSession = THIS.FRXDataSession
.CurrentDataSession = THIS.CurrentDataSession
.TwoPassProcess = THIS.TwoPassProcess
.CommandClauses = THIS.CommandClauses
.SharedPageHeight = THIS.SharedPageHeight
.SharedPageWidth = THIS.SharedPageWidth
THIS.SetSuccessorDynamicProperties()
.AfterReport()
.ResetToDefault("FRXDataSession")
.ResetToDefault("CurrentDataSession")

ENDWITH
ENDIF
IF NOT THIS.IsSuccessor
NODEFAULT
DODEFAULT()
ENDIF


ENDPROC
PROCEDURE allowmodalmessages_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.AllowModalMessages = m.vNewVal
ENDIF


ENDPROC
PROCEDURE appname_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.appname = m.vNewVal
ENDIF

ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo

IF NOT ISNULL(THIS.Successor)
THIS.SetSuccessorDynamicProperties()
THIS.Successor.BeforeBand(m.nBandObjCode, m.nFRXRecNo)
ENDIF

THIS.resetDataSession()

ENDPROC
PROCEDURE BeforeReport
THIS.setFRXRunStartupConditions()

THIS.getFRXStartupInfo()

THIS.resetDataSession()

IF NOT THIS.IsSuccessor
THIS.sharedPageHeight = THIS.GetPageHeight()
THIS.sharedPageWidth = THIS.GetPageWidth()
THIS.sharedListenerType = THIS.ListenerType
THIS.ResetToDefault("sharedPageNo")
THIS.ResetToDefault("sharedPageTotal")
THIS.ResetToDefault("sharedOutputPageCount")
THIS.ResetToDefault("sharedGDIPlusGraphics")
ENDIF

IF NOT ISNULL(THIS.Successor)
WITH THIS.Successor
.AddProperty("sharedGDIPlusGraphics", THIS.sharedGDIPlusGraphics)
.AddProperty("sharedPageHeight", THIS.sharedPageHeight)
.AddProperty("sharedPageWidth", THIS.sharedPageWidth)
.AddProperty("sharedOutputPageCount", THIS.sharedOutputPageCount)
.AddProperty("sharedPageNo", THIS.sharedPageNo)
.AddProperty("sharedPageTotal", THIS.sharedPageTotal)
.AddProperty("sharedListenerType",THIS.ListenerType)
THIS.setSuccessorDynamicProperties()
.FRXDataSession = THIS.FRXDataSession
.CurrentDataSession = THIS.CurrentDataSession
.TwoPassProcess = THIS.TwoPassProcess
.CommandClauses = THIS.CommandClauses
.commandClausesFile = THIS.commandClausesFile
* doing the above line here because some dynamic
* object may have adjusted it in the Load and we can
* correct original value here.
.BeforeReport()
ENDWITH
ENDIF

*&amp;* Sedna -- we want this *after* successor has run BeforeReport code,
*&amp;* but some Successor.BeforeReport code might
*&amp;* have an affect on Dynamics
THIS.resetDynamicMethodCalls()
*&amp;* .. so we'll re-set those dynamic properties again afterwards
IF NOT ISNULL(THIS.Successor)
WITH THIS.successor
IF .CallEvaluateContents &lt; THIS.CallEvaluateContents
.CallEvaluateContents = THIS.CallEvaluateContents
ENDIF
IF .CallAdjustObjectSize &lt; THIS.CallAdjustObjectSize
.CallAdjustObjectSize = THIS.CallAdjustObjectSize
ENDIF
ENDWITH
ENDIF
ENDPROC
PROCEDURE CancelReport
IF NOT THIS.IsSuccessor
DODEFAULT()
NODEFAULT
ENDIF
IF NOT ISNULL(THIS.Successor)
THIS.SetSuccessorDynamicProperties()
THIS.Successor.CancelReport()
ENDIF

ENDPROC
PROCEDURE clearerrors
THIS.HadError = .F.
THIS.LastErrorMessage = ""
ENDPROC
PROCEDURE ClearStatus
DODEFAULT()
IF NOT ISNULL(THIS.Successor)
THIS.SetSuccessorDynamicProperties()
THIS.Successor.ClearStatus()
ENDIF
ENDPROC
PROCEDURE commandclausesfile_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) = "C" AND ;
FILE(m.tvNewVal) &amp;&amp; not SYS(2000), could be built into an app
THIS.commandClausesFile = m.tvNewVal
ELSE
THIS.commandClausesFile = NULL
ENDIF

ENDPROC
PROCEDURE Destroy
STORE NULL TO ;
THIS.runCollector, ;
THIS.Successor, ;
THIS.Listeners, ;
THIS.ReportClauses, ;
THIS.ReportFileNames, ;
THIS.PreviewContainer, ;
THIS.CommandClauses

ENDPROC
PROCEDURE DoMessage
LPARAMETERS m.cMessage,m.iParams,m.cTitle
NODEFAULT
IF THIS.QuietMode OR ;
(THIS.IsRunning AND THIS.CommandClauses.NoDialog)
* to emulate the base class behavior, do both checks,
* in case the call to DoMessage() occurs
* before the baseclass sets QuietMode .T. in response
* to NoDialog at the beginning of the report run,
* or after the baseclass re-sets Quietmode to .F.
* at the end of the report run.
RETURN 0
ELSE
IF THIS.AllowModalMessages
IF VARTYPE(m.cTitle) = "C"
RETURN MESSAGEBOX(TRANS(m.cMessage),VAL(TRANS(m.iParams)),m.cTitle)
ELSE
RETURN MESSAGEBOX(TRANS(m.cMessage),VAL(TRANS(m.iParams)),THIS.AppName)
ENDIF
ELSE
THIS.DoStatus(m.cMessage)
RETURN 0
ENDIF
ENDIF
ENDPROC
PROCEDURE DoStatus
LPARAMETERS m.cMessage
NODEFAULT
IF NOT (THIS.QuietMode OR (THIS.IsRunning AND THIS.CommandClauses.Nodialog))
IF THIS.TwoPassProcess AND THIS.CurrentPass = 0
WAIT WINDOW NOWAIT OUTPUTCLASS_PREPSTATUS_LOC
ELSE
IF VARTYPE(m.cMessage) = "C"
DODEFAULT(m.cMessage)
ENDIF
ENDIF
ENDIF
ENDPROC
PROCEDURE Error
LPARAMETERS m.nError, m.cMethod, m.nLine
LOCAL m.lcOnError,m.lcErrorMsg,m.lcCodeLineMsg
THIS.HadError = .T.
IF this.lIgnoreErrors OR _vfp.StartMode&gt;0
	RETURN .F.
ENDIF
m.lcOnError=UPPER(ALLTRIM(ON("ERROR")))
IF NOT EMPTY(m.lcOnError)
	m.lcOnError=STRTRAN(STRTRAN(STRTRAN(lcOnError,"ERROR()","nError"), ;
			"PROGRAM()","cMethod"),"LINENO()","nLine")
	&amp;lcOnError
	RETURN
ENDIF
m.lcErrorMsg = THIS.PrepareErrorMessage(m.nError,m.cMethod, m.nLine)
THIS.LastErrorMessage = m.lcErrorMsg

THIS.DoMessage(m.lcErrorMsg, MB_ICONSTOP )

#IF OUTPUTCLASS_DEBUGGING
ERROR m.nError
#ENDIF
ENDPROC
PROCEDURE getfrxstartupinfo
THIS.SetFRXDataSession()
IF USED("FRX")
SELECT FRX
LOCATE FOR ObjType = FRX_OBJTYP_DATAENV AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT DELETED()
THIS.ReportUsesPrivateDataSession = Frx.Environ
* could also use
* THIS.CommandClauses.StartDataSession # THIS.CurrentDataSession
LOCATE FOR ObjType = FRX_OBJTYP_REPORTHEADER AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT DELETED()
THIS.frxHeaderRecno = RECNO("FRX")
ELSE
THIS.ReportUsesPrivateDataSession = .F.
THIS.frxHeaderRecno = -1
ENDIF
THIS.SetCurrentDataSession()
IF THIS.reportUsesPrivateDataSession
SET TALK OFF
ENDIF
THIS.DrivingAlias = UPPER(ALIAS())
ENDPROC
PROCEDURE getlasterrormessage
RETURN STRTRAN(THIS.LastErrorMessage, CHR(13), " ")
ENDPROC
PROCEDURE IncludePageInOutput
LPARAMETERS m.nPageNo
LOCAL m.llInclude
IF (NOT THIS.isSuccessor) AND ;
(THIS.PageLimit &gt; 0) AND ;
(THIS.PageNo &gt; THIS.PageLimit)
* note that nPageNo and the
* current CommandClauses.RangeFrom and RangeTo values
* only refer to the current report, which
* is potentially one of a series using NOPAGEEJECT.
* THIS.PageNo refers to the overall number of pages that
* have been run, across the multiple reports.
IF NOT THIS.pageLimitQuietMode
THIS.DoMessage(OUTPUTCLASS_PAGELIMIT_LOC , MB_ICONEXCLAMATION)
ENDIF
THIS.LastErrorMessage = OUTPUTCLASS_PAGELIMIT_LOC
THIS.CancelReport()
ELSE
DO CASE
CASE (THIS.isSuccessor)
* do not try to limit run unless
* communicating with native engine
m.llInclude = .T.
CASE (THIS.PageTopLimit = -1) AND ;
(THIS.PageTailLimit = -1)
* no limits set
m.llInclude = .T.
CASE THIS.PageTopLimit = -1
* only bottom end requested
IF THIS.PageLimitInsideRange
m.llInclude = (THIS.PageNo &lt;= THIS.PageTailLimit)
ELSE
m.llInclude = (THIS.PageNo &gt;= THIS.PageTailLimit)
ENDIF
CASE THIS.PageTailLimit = -1
* only top end requested
IF THIS.PageLimitInsideRange
m.llInclude = (THIS.PageNo &gt;= THIS.PageTopLimit)
ELSE
m.llInclude = (THIS.PageNo &lt;= THIS.PageTopLimit)
ENDIF
OTHERWISE
* both top and tail requested
IF THIS.PageLimitInsideRange
m.llInclude = BETWEEN(THIS.PageNo,THIS.PageTopLimit, THIS.PageTailLimit)
ELSE
m.llInclude = ((THIS.PageNo &lt;= THIS.PageTopLimit) OR ;
(THIS.PageNo &gt;= THIS.PageTailLimit))
ENDIF
ENDCASE
ENDIF
RETURN (m.llInclude AND DODEFAULT(m.nPageNo))

ENDPROC
PROCEDURE Init
THIS.listenerDataSession = SET("DATASESSION")

IF DODEFAULT()
THIS.AppName = OUTPUTCLASS_APPNAME_LOC
ELSE
RETURN .F.
ENDIF

*&amp;* Sedna
* this may be necessary if you
* modify and compile these classes in a build that
* does have the two native properties
* and then go back to use them with a version
* that does *not* have the native properties
* (it's possible to lose the custom definitions)

IF NOT PEMSTATUS(THIS,"CallEvaluateContents",5)
THIS.AddProperty("CallEvaluateContents", LISTENER_CALLDYNAMICMETHOD_CHECK_CODE)
ENDIF

IF NOT PEMSTATUS(THIS,"CallAdjustObjectSize",5)
THIS.AddProperty("CallAdjustObjectSize", LISTENER_CALLDYNAMICMETHOD_CHECK_CODE)
ENDIF


RETURN NOT THIS.HadError
ENDPROC
PROCEDURE invokeoncurrentpass
RETURN .T.
ENDPROC
PROCEDURE isfrxswapcopypresent
RETURN (NOT ISNULL(THIS.commandClausesFile)) AND ;
(NOT EMPTY(THIS.commandClausesFile)) AND ;
(TYPE("THIS.commandClauses.File") = "C") AND ;
(NOT UPPER(THIS.commandClausesFile) == UPPER(THIS.CommandClauses.File))

ENDPROC
PROCEDURE issuccessor_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.isSuccessor = m.vNewVal
ENDIF

ENDPROC
PROCEDURE lignoreerrors_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.lIgnoreErrors = m.vNewVal
ENDIf


ENDPROC
PROCEDURE listenertype_assign
LPARAMETERS m.vNewVal
IF THIS.SupportsListenerType(m.vNewVal) AND ;
NOT THIS.IsRunning
THIS.ListenerType = m.vNewVal
ENDIF

ENDPROC
PROCEDURE LoadReport
THIS.clearErrors()

THIS.setFRXDataSessionEnvironment()

THIS.resetDataSession()
THIS.frxHeaderRecno = -1

IF NOT ISNULL(THIS.Successor)
WITH THIS.Successor
.AddProperty("isSuccessor",.T.)
.AddProperty("commandClausesFile",THIS.commandClausesFile )
.PrintJobName = THIS.PrintJobName
.CommandClauses = THIS.CommandClauses
.LoadReport()
ENDWITH
ENDIF






ENDPROC
PROCEDURE outputtype_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
THIS.OutputType = INT(m.vNewVal)
IF THIS.SupportsListenerType(THIS.OutputType)
THIS.ListenerType = THIS.OutputType
ENDIF
ENDIF

ENDPROC
PROCEDURE pagelimit_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) &gt; 0
THIS.PageLimit = CEILING(m.tVal)
ELSE
THIS.PageLimit = -1
ENDIF


ENDPROC
PROCEDURE pagelimitinsiderange_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "L"
THIS.PageLimitInsideRange = m.tVal
ENDIF


ENDPROC
PROCEDURE pagelimitquietmode_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "L"
THIS.PageLimitQuietMode = m.tVal
ENDIF


ENDPROC
PROCEDURE pagetaillimit_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) &gt; 0
THIS.PageTailLimit = CEILING(m.tVal)
ELSE
THIS.PageTailLimit = -1
ENDIF


ENDPROC
PROCEDURE pagetoplimit_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) &gt; 0
THIS.PageTopLimit = CEILING(m.tVal)
ELSE
THIS.PageTopLimit = -1
ENDIF


ENDPROC
PROCEDURE popglobalsets
* abstract: restore any globals here that aren't session-bound


ENDPROC
PROCEDURE prepareerrormessage
LPARAMETERS m.nError, m.cMethod, m.nLine, m.cName, m.cMessage, m.cCodeLine

LOCAL m.lcErrorMessage, m.lcCodeLineMsg

IF VARTYPE(cMessage) = "C"
m.lcErrorMessage = m.cMessage
ELSE
m.lcErrorMessage = MESSAGE()
ENDIF

m.lcErrorMessage = m.lcErrorMessage + CHR(13) + CHR(13)

IF VARTYPE(cName) = "C"
m.lcErrorMessage = m.lcErrorMessage + m.cName
ELSE
m.lcErrorMessage = m.lcErrorMessage + this.Name
ENDIF

m.lcErrorMessage = m.lcErrorMessage + CHR(13)+ ;
		 OUTPUTCLASS_ERRNOLABEL_LOC +ALLTRIM(STR(m.nError))+CHR(13)+ ;
		 OUTPUTCLASS_ERRPROCLABEL_LOC +LOWER(ALLTRIM(m.cMethod))
		
IF VARTYPE(m.cCodeLine) = "C"
m.lcCodeLineMsg = m.cCodeLine
ELSE
m.lcCodeLineMsg = MESSAGE(1)
ENDIF		

IF BETWEEN(m.nLine,1,100000) AND NOT m.lcCodeLineMsg="..."
	m.lcErrorMessage= ;
m.lcErrorMessage+CHR(13)+ OUTPUTCLASS_ERRLINELABEL_LOC+ ;
	    ALLTRIM(STR(m.nLine))
	IF NOT EMPTY(m.lcCodeLineMsg)
m.lcErrorMessage= ;
		   m.lcErrorMessage+CHR(13)+CHR(13)+m.lcCodeLineMsg
	ENDIF
ENDIF

RETURN m.lcErrorMessage
ENDPROC
PROCEDURE preparefrxswapcopy
LPARAMETERS m.tcPath, m.tlKeepCopyOpen, m.tlAdjustCommandClausesInLoadReport
LOCAL m.lcPath, m.lcFile, m.liSession, m.lcAlias, m.liSelect, m.llSafety
m.lcFile = ""
m.liSession = SET("DATASESSION")
m.liSelect = 0
TRY
THIS.setFRXDataSession()
m.liSelect = SELECT(0)
DO CASE
CASE VARTYPE(m.tcPath) = "C" AND ;
(NOT EMPTY(m.tcPath)) AND DIRECTORY(ADDBS(m.tcPath))
m.lcPath = m.tcPath
CASE NOT DIRECTORY(ADDBS(JUSTPATH(THIS.CommandClauses.FILE)))
* report does not exist on disk
* and its path has not been re-created in the
* current environment, potentially with related
* image directories, etc.
m.lcPath = SYS(2023)
CASE EMPTY(SYS(2000,THIS.CommandClauses.File))
* report does not exist on disk
m.lcPath = SYS(2023)
OTHERWISE
* whenever possible,
* the best place for this copy will
* always be in the same location as the
* original FRX, for relative-pathing reasons.
m.lcPath = JUSTPATH(THIS.CommandClauses.File)
ENDCASE
m.lcFile = FORCEEXT(FORCEPATH("F"+SYS(2015), m.lcPath),"FRX")
IF USED("FRX") &amp;&amp; this method should ordinarily
&amp;&amp; be used as part of a report swap, and that
&amp;&amp; means in LoadReport only.  FRX isn't used yet.
&amp;&amp; But we'll provide this mechanism,
&amp;&amp; in case somebody has a different reason
&amp;&amp; to use this method at another
&amp;&amp; point in report processing --
&amp;&amp; XML Listener has one,
&amp;&amp; for example!
SELECT 0
CREATE CURSOR x (onefield l)
* we're in the frxdatasession, this is safe
CREATE REPORT (m.lcFile) FROM  (ALIAS()) &amp;&amp; (DBF("x"))
USE IN x
SELECT 0
USE (m.lcFile) EXCLUSIVE ALIAS (JUSTSTEM(m.lcFile))
m.lcAlias = ALIAS()
m.llSafety = (SET("SAFETY") == "ON")
SET SAFETY OFF
ZAP
IF m.llSafety
SET SAFETY ON
ENDIF
SELECT FRX
SCAN ALL FOR NOT DELETED()
SCATTER MEMVAR MEMO
INSERT INTO (m.lcAlias) FROM MEMVAR
ENDSCAN
IF NOT m.tlKeepCopyOpen
USE IN (m.lcAlias)
ENDIF
ELSE
* this is the normal swap mechanism
* SYS(2000) may be empty but FILE() should not
* be, even if this report was not on disk,
* and CommandClauses.File should be fully-qualified.
SELECT 0
USE (THIS.CommandClauses.File) ;
SHARED NOUPDATE ;
ALIAS (JUSTSTEM(THIS.CommandClauses.File))
m.lcAlias = ALIAS()
SELECT * FROM (THIS.CommandClauses.File) ;
WHERE NOT DELETED() ;
INTO TABLE (m.lcFile)
USE IN (m.lcAlias)
IF NOT m.tlKeepCopyOpen
m.lcAlias = JUSTSTEM(m.lcFile)
* this should always work because of the way
* we've defined the m.lcFile contents
IF USED(m.lcAlias)
USE IN (m.lcAlias)
ENDIF
ENDIF
ENDIF
CATCH WHEN .T.
m.lcFile = ""
FINALLY
IF (NOT (EMPTY(m.lcFile) OR EMPTY(SYS(2000,m.lcFile)))) AND ;
m.tlAdjustCommandClausesInLoadReport AND ;
NOT m.tlKeepCopyOpen
THIS.CommandClauses.File = m.lcFile
ENDIF
IF m.liSelect &gt; 0
SELECT (m.liSelect)
ENDIF
SET DATASESSION TO (m.liSession)
ENDTRY

RETURN m.lcFile
ENDPROC
PROCEDURE pushglobalsets
* abstract: set any globals here that aren't session-bound

ENDPROC
PROCEDURE quietmode_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.quietmode = m.vNewVal
ENDIF
ENDPROC
PROCEDURE removefrxswapcopy
LPARAMETERS m.tcFile,m.tlRecycle
LOCAL m.lcRecyle, m.llResettingSharedCopy
IF EMPTY(m.tcFile) AND THIS.isFRXSwapCopyPresent()
m.llResettingSharedCopy = .T.
m.tcFile = THIS.CommandClauses.File
ENDIF
IF NOT EMPTY(m.tcFile)
IF m.tlRecycle
m.lcRecycle = " RECYCLE"
ELSE
m.lcRecycle = ""
ENDIF
IF NOT EMPTY(SYS(2000,FORCEEXT(m.tcFile,"FRX")))
ERASE (FORCEEXT(m.tcFile,"FRX")) &amp;lcRecycle
ENDIF
IF NOT EMPTY(SYS(2000,FORCEEXT(m.tcFile,"FRT")))
ERASE (FORCEEXT(m.tcFile,"FRT")) &amp;lcRecycle
ENDIF
IF m.llResettingSharedCopy
THIS.CommandClauses.File = THIS.commandClausesFile
ENDIF
ENDIF

ENDPROC
PROCEDURE removereports
IF NOT (THIS.IsRunningReports)
THIS.ReportFileNames = NULL
THIS.ReportClauses = NULL
THIS.Listeners = NULL
DIME THIS.ReportPages[1]
THIS.ReportPages[1] = 0

ENDIF
ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage
IF NOT ISNULL(THIS.Successor)
THIS.SetSuccessorDynamicProperties()
THIS.Successor.Render( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
ENDIF


ENDPROC
PROCEDURE resetcalladjustobjectsize
* abstract, poll members
ENDPROC
PROCEDURE resetcallevaluatecontents
* abstract, poll members
ENDPROC
PROCEDURE resetdatasession
IF (THIS.listenerDataSession &gt; -1)
TRY
SET DATASESSION TO (THIS.listenerDataSession)
CATCH WHEN .T.
THIS.ResetToDefault("listenerDataSession")
SET DATASESSION TO (THIS.listenerDataSession)
ENDTRY
ENDIF

ENDPROC
PROCEDURE resetdynamicmethodcalls
*&amp;* Sedna:

* poll Successor, who would
* have already run all this code on its
* own behalf:

IF INLIST(THIS.callAdjustObjectSize,;
LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
LISTENER_CALLDYNAMICMETHOD_NEVER)
THIS.resetCallAdjustObjectSize()
ELSE  &amp;&amp; already set to LISTENER_CALLDYNAMICMETHOD_ALWAYS, always call
* leave alone
ENDIF

IF INLIST(THIS.callEvaluateContents,;
LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
LISTENER_CALLDYNAMICMETHOD_NEVER)
THIS.resetCallEvaluateContents()
ELSE  &amp;&amp; already set to LISTENER_CALLDYNAMICMETHOD_ALWAYS, always call
* leave alone
ENDIF

IF NOT ISNULL(THIS.Successor)
IF PEMSTATUS(THIS.successor,"CallAdjustObjectSize",5) AND ;
THIS.successor.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
THIS.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
ENDIF
IF PEMSTATUS(THIS.successor,"CallEvaluateContents",5) AND ;
THIS.successor.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
ENDIF
ENDIF




ENDPROC
PROCEDURE runreports
LPARAMETERS m.tlRemoveReportsAfterRun, m.tlOmitListenerReferences

IF NOT ;
(THIS.IsRunningReports OR ;
ISNULL(THIS.ReportFileNames) OR ;
THIS.ReportFileNames.Count = 0)

LOCAL m.oError, m.liIndex, m.lcClauses, m.loListener, m.lcParse
m.oError = NULL

THIS.IsRunningReports = .T.

TRY

FOR m.liIndex = 1 TO THIS.ReportFileNames.Count
* the clauses, filenames, and listener collections are
* protected properties, we're
* taking care of how they match up,
* that FRXs exist, etc.
m.lcClauses = UPPER(THIS.ReportClauses[m.liIndex])
m.loListener = THIS.Listeners[m.liIndex]
DO CASE
CASE " OBJE " $ STRTRAN(" "+m.lcClauses,"CT", " ") OR ;
" OBJEC " $ " "+m.lcClauses OR ;
m.tlOmitListenerReferences
m.loListener = NULL
REPORT FORM (THIS.ReportFileNames[m.liIndex]) &amp;lcClauses
TRY
m.lcParse = " " + STRTRAN(" "+m.lcClauses," OBJECT ", " OBJE ")
m.lcParse = STRTRAN(m.lcParse," OBJEC ", " OBJE ")
m.lcParse = SUBSTR(m.lcParse,AT(" OBJE ", m.lcParse)+5)
DO CASE
CASE m.tlOmitListenerReferences
* we're going with old-style behavior for sure here
CASE " TYPE " $ " " + m.lcClauses
m.lcParse = ALLTRIM(STRTRAN(" " + m.lcParse," TYPE ",""))
IF " " $ m.lcParse
m.lcParse = ALLTRIM(LEFT(m.lcParse,AT(" ",m.lcParse,1)))
ENDIF
IF VAL(m.lcParse) &gt; 0
m.loListener = EVALUATE("_oReportOutput['" + m.lcParse+"']")
ENDIF
OTHERWISE
m.lcParse = ALLTRIM(m.lcParse)
IF " " $ m.lcParse
m.lcParse = ALLTRIM(LEFT(m.lcParse,AT(" ",m.lcParse,1)))
ENDIF
m.loListener = EVALUATE(m.lcParse)
ENDCASE
CATCH
m.loListener = NULL
ENDTRY
CASE ISNULL(loListener)
REPORT FORM (THIS.ReportFileNames[m.liIndex]) &amp;lcClauses  OBJECT THIS
m.loListener = THIS
OTHERWISE
REPORT FORM (THIS.ReportFileNames[m.liIndex]) &amp;lcClauses  OBJECT m.loListener
ENDCASE

THIS.adjustReportPagesInfo(m.liIndex, m.lcClauses, m.loListener)

*&amp;* Sedna change:
*&amp;*  see new THIS.adjustReportPagesInfo method, to which we pass report index, clauses, and
*&amp;*  evaluated listener ref.  Original code here was:
*&amp;*          IF NOT (" NOWA " $ STRTRAN(" "+m.lcClauses,"IT"," ") OR ;
*&amp;*                  " NOWAI " $ " " + m.lcClauses)
*&amp;*             THIS.ReportPages[m.liIndex] = THIS.SharedPageTotal
*&amp;*             * TBD: make this a two-column array with
*&amp;*             * output pages (responsive to RANGE clause)
*&amp;*             * represented as well?
*&amp;*          ENDIF

ENDFOR


CATCH TO m.oError
LOCAL lcErrMsg
IF (ISNULL(m.oError))
lcErrMsg = MESSAGE() + CHR(13) + MESSAGE(1)
ELSE
lcErrMsg = THIS.PrepareErrorMessage(;
m.oError.ErrorNo, ;
m.oError.PROCEDURE, ;
m.oError.LINENO, ;
THIS.AppName, ;
m.oError.MESSAGE, ;
m.oError.LineContents)
ENDIF
THIS.DoMessage(lcErrMsg, MB_ICONSTOP)
THIS.lastErrorMessage = lcErrMsg
#IF OUTPUTCLASS_DEBUGGING
SUSPEND
#ENDIF
EXIT
FINALLY

THIS.IsRunningReports = .F.
IF m.tlRemoveReportsAfterRun
THIS.RemoveReports()
ENDIF
STORE NULL TO m.loListener, m.oError

ENDTRY


ENDIF





ENDPROC
PROCEDURE setcurrentdatasession
IF (THIS.CurrentDataSession # SET("DATASESSION"))
TRY
SET DATASESSION TO (THIS.CurrentDataSession)
CATCH WHEN .T.
THIS.ResetToDefault("CurrentDataSession")
THIS.resetDataSession()
ENDTRY
ENDIF


ENDPROC
PROCEDURE setfrxdatasession
IF (THIS.FRXDataSession &gt; -1) AND (THIS.FRXDataSession # SET("DATASESSION"))

TRY
SET DATASESSION TO (THIS.FRXDataSession)
CATCH WHEN .T.
THIS.ResetToDefault("FRXDataSession")
THIS.resetDataSession()
ENDTRY

ENDIF

ENDPROC
PROCEDURE setfrxdatasessionenvironment
THIS.setFRXDataSession()
SET TALK OFF

ENDPROC
PROCEDURE setfrxrunstartupconditions
IF ISNULL(THIS.CommandClauses)
THIS.CommandClauses = CREATEOBJECT("Empty")
ENDIF
IF TYPE("THIS.CommandClauses.NoDialog") # "L"
ADDPROPERTY(THIS.CommandClauses,"NoDialog",.F.)
ENDIF


* add anything critical during a run
* that might not be available, whether
* because this is a custom attribute
* or because public methods of ReportListener
* might be called outside a normal report run.
ENDPROC
PROCEDURE setsuccessordynamicproperties
IF NOT THIS.isSuccessor
THIS.sharedOutputPageCount = THIS.OutputPageCount
THIS.sharedPageTotal = THIS.PageTotal
THIS.sharedPageNo = THIS.PageNo
THIS.sharedGdiplusGraphics = THIS.GDIPlusGraphics
ENDIF
WITH THIS.Successor
.CurrentPass = THIS.CurrentPass
.TwoPassProcess = THIS.TwoPassProcess
.sharedOutputPageCount = THIS.sharedOutputPageCount
.sharedPageTotal = THIS.sharedPageTotal
.sharedPageNo = THIS.sharedPageNo
.sharedGdiplusGraphics  = THIS.sharedGdiplusGraphics
.CallEvaluateContents = THIS.CallEvaluateContents
.CallAdjustObjectSize = THIS.CallAdjustObjectSize
ENDWITH

ENDPROC
PROCEDURE sharedgdiplusgraphics_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.SharedGDIplusGraphics = m.vNewVal
ENDIF

ENDPROC
PROCEDURE sharedlistenertype_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
INLIST(m.vNewVal,LISTENER_TYPE_DEF,;
LISTENER_TYPE_PRN,;
LISTENER_TYPE_PRV,;
LISTENER_TYPE_PAGED,;
LISTENER_TYPE_ALLPGS)
THIS.sharedListenerType = m.vNewVal
ENDIF

ENDPROC
PROCEDURE sharedoutputpagecount_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.sharedOutputPageCount = m.vNewVal
ENDIF

ENDPROC
PROCEDURE sharedpageheight_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.sharedPageHeight = m.vNewVal
ENDIF

ENDPROC
PROCEDURE sharedpageno_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.sharedPageNo = m.vNewVal
ENDIF

ENDPROC
PROCEDURE sharedpagetotal_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.sharedPageTotal = m.vNewVal
ENDIF

ENDPROC
PROCEDURE sharedpagewidth_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
THIS.sharedPageWidth = m.vNewVal
ENDIF

ENDPROC
PROCEDURE successor_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND ;
(ISNULL(m.vNewVal) OR ;
(VARTYPE(m.vNewVal) = "O" AND UPPER(m.vNewVal.BaseClass) == "REPORTLISTENER"))
THIS.Successor = m.vNewVal
ENDIF


ENDPROC
PROCEDURE UnloadReport

IF NOT THIS.IsSuccessor
THIS.SharedPageWidth = THIS.GetPageWidth()
THIS.SharedPageHeight = THIS.GetPageHeight()
ENDIF

THIS.resetDataSession()

IF NOT ISNULL(THIS.Successor)

WITH THIS.Successor
.FRXDataSession = THIS.FRXDataSession
.CurrentDataSession = THIS.CurrentDataSession
.TwoPassProcess = THIS.TwoPassProcess
.CommandClauses = THIS.CommandClauses
.SharedPageHeight = THIS.SharedPageHeight
.SharedPageWidth = THIS.SharedPageWidth
THIS.SetSuccessorDynamicProperties()
.UnloadReport()
.IsSuccessor = .F.
ENDWITH

ENDIF


ENDPROC
PROCEDURE UpdateStatus
DODEFAULT()
IF NOT ISNULL(THIS.Successor)
THIS.SetSuccessorDynamicProperties()
THIS.Successor.UpdateStatus()
ENDIF
ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>lignoreerrors Provides a flag to determine how this class handles activities subsequent to an error.
haderror Provides a flag indicating whether an error occurred.
appname Localizable application name string for use in user feedback.
isrunning Provides a flag to indicate whether a report run is underway.  When IsRunning is true, the class may wish to disallow certain activities or method calls.
lasterrormessage
isrunningreports Provides a flag to indicate this ReportListener is running a series of reports using its collection.
reportfilenames Stores the filenames of reports to be managed and executed in a series.
reportclauses Stores REPORT FORM command clauses associated with each report in the ReportFileNames collection.
listeners Collection of ReportListeners associated with each report in this Listener's ReportFileNames collection.
listenerdatasession Saves the DataSessionID in which the Listener originated.
reportusesprivatedatasession Provides a flag to indicate whether this report shares the data session from which it was executed or maintains a private data session.
issuccessor Indicates whether this Listener is chained to one or more others to provide output during a report run.  When .T., this Listener was not the object referenced in the REPORT FORM command OBJECT clauses.
successor An object reference to the next Listener in a succession chain.
sharedgdiplusgraphics Provides a readwrite copy of the the Engine's GDIPlusGraphics handle which the Listener can share with a succession chain.
sharedpageheight Shares information gathered by the GetPageHeight method with other Listeners linked in a succession chain.
sharedpagewidth Shares information gathered by the GetPageWidth method with other Listeners linked in a succession chain.
drivingalias Holds the alias of the table or cursor driving the report scope.
_memberdata XML Metadata for customizable properties
sharedoutputpagecount Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
sharedpageno Provides a readwrite copy of the the Engine's PageNo property which the Listener can share with a succession chain.
sharedpagetotal Provides a readwrite copy of the the Engine's PageTotal property which the Listener can share with a succession chain.
pagelimit If &gt; 0, represents the highest number of pages allowed in a report run (potentially across multiple reports using NOPAGEEJECT).  Especially useful for ListenerTypes 1 and 3, to avoid GDI resource issues, but can provide abbreviated results for any type
pagetoplimit If &gt; 0, represents the highest number of pages for "top" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTailLimit or alone. No user feedback provided.
pagetaillimit If &gt; 0, represents the lowest number of pages for "tail" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTopLimit or alone. No user feedback provided. 
pagelimitquietmode Indicates whether the class provides user feedback when the report results are limited because the run exceeded the specified pageLimit.
pagelimitinsiderange If .T., indicates that pageTopLimit and pageTailLimit provide an inside range rather than beginning and end of report contents.  Makes pageTopLimit and pageTailLimit similar to RANGE clause, but active over multiple reports with NOPAGEEJECT.
runcollector Placeholder available to hold extension output generated during a report run. Property may contain an alias for a cursor holding property names and values, a collection object reference, or an empty-type object reference.
frxheaderrecno Stores the header record number for the Windows platform in cross-platform FRXs.
sharedlistenertype Provides a readwrite copy of the the Engine's ListenerType property which the Listener can share with a succession chain.
commandclausesfile Allows saving and restoring of the original CommandClauses.File value by any derived class that permits dynamic FRX-fileswapping during LoadReport.
*allowmodalmessages_assign 
*lignoreerrors_assign 
*prepareerrormessage Organizes common error information values (nError, cMethod, nLine, cName, cMessage, cCodeLine) into a coherent string for presentation to the user.
*pushglobalsets Provides a hook for Listeners to save global settings not scoped to a data session for later restoration with PopGlobalSets.
*popglobalsets Provides a hook for Listeners to restore global settings not scoped to a data session after saving them with PushGlobalSets.
*clearerrors Resets the class's error status.
*getlasterrormessage Provides information about the last error that occurred.
*addreport Adds to the class's collection of ReportFileNames, optionally associating REPORT FORM clauses and a listener for the specified report.
*removereports Removes report filenames as well as associated clauses and listeners from this Listeners' various collections.
*runreports Executes a series of REPORT FORM commands according to the instructions in the ReportFileNames, ReportClauses, and Listeners collections.  Optionally clears collection after run and issues the REPORT FORM commands without OBJECTreferences.
*setfrxdatasessionenvironment Provides a hook for classes to determine the datasession-scoped SETs they wish to add to the private FRX data session.
^reportpages[1,0] Holds accumulated page count  info when this class runs a collection of reports as a series. Can be used in report expressions or checked after a report run (if .removeReports has not been called).  Set in adjustReportPagesInfo.
*invokeoncurrentpass Provides a hook for listeners to evaluate whether they wish to generate output or perform other actions during the current report execution pass.
*resetdatasession Sets the DataSessionID to the session where the Listener originated.
*setfrxdatasession Sets the DataSessionID to the data session in which the Engine has opened a readonly copy of the report file as a table for the Listener's use.
*setcurrentdatasession Sets the DataSessionID to the data session holding report's data tables.
*quietmode_assign 
*issuccessor_assign 
*successor_assign 
*getfrxstartupinfo Provides a hook for gathering FRX information during BeforeReport method processing.
*setsuccessordynamicproperties Provides a hook for the Listener to share information changed by the Engine with a succession of Listeners, during the run of a report.
*appname_assign 
*sharedgdiplusgraphics_assign 
*sharedpageheight_assign 
*sharedpagewidth_assign 
*listenertype_assign 
*outputtype_assign 
*sharedoutputpagecount_assign Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
*sharedpageno_assign 
*sharedpagetotal_assign 
*setfrxrunstartupconditions Hook method called in BeforeReport, allowing you to set up CommandClauses properties or other attributes required by your class.
*pagelimit_assign 
*pagetoplimit_assign 
*pagetaillimit_assign 
*pagelimitquietmode_assign 
*pagelimitinsiderange_assign 
*resetdynamicmethodcalls Evaluates whether AdjustObjectSize and EvaluateContents methods should be called for a report run, for this reportlistener's activity or as requested by Successor chain.
*resetcalladjustobjectsize Evaluates whether this reportlistener's activity requires calls to AdjustObjectSize method for any layout controls on this report run.
*resetcallevaluatecontents Evaluates whether this reportlistener's activity requires calls to EvaluateContents method for any layout controls on this report run.
*resetruncollector Abstract method to clean up runCollector object at whatever point is appropriate in a given implementation.
*fillruncollector Abstract method to set up up runCollector object with contents at whatever point is appropriate in a given implementation.
*sharedlistenertype_assign 
*commandclausesfile_assign 
*preparefrxswapcopy Provides an FRX copy on disk, in the same path/location as the original FRX if possible to support relative file references, for use during a report run.  Returns fully-qualified temporary file name it generates for the copy.
*removefrxswapcopy Removes an FRX file and its matching FRT file from disk, if present.
*isfrxswapcopypresent Indicates whether the original CommandClauses.File value has been swapped for a temporary copy during a report run.
*adjustreportpagesinfo Hook to allow subclasses to decide how to associate the page numbers for each report in a collection with the member array representing page numbers, during the runReports method.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Adds error handling, session handling, and other common report run-time tasks to ReportListener base class.  Provides the ability to chain a series of reports as well as the means to delegate or share output activities to a chain of Listener-successors.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>_reportlistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1L50LCL98</uniqueid>
		<timestamp>924359586</timestamp>
		<class>_reportlistener</class>
		<classloc>_ReportListener.vcx</classloc>
		<baseclass>reportlistener</baseclass>
		<objname>fxlistener</objname>
		<parent/>
		<properties>FRXDataSession = -1
fxs = (NULL)
gfxs = (NULL)
ffcgraphics = (NULL)
cancelrequested = .F.
fxfeedbackclass = ("fxTherm")
fxfeedbackclasslib = (THIS.ClassLibrary)
fxfeedbackmodule = ("")
classpath = ("")
fxmemberdatascriptclass = ("fxMemberDataScript")
fxmemberdatascriptclasslib = (THIS.ClassLibrary)
fxmemberdatascriptmodule = ("")
frxcursor = (NULL)
memberdataalias = ("M"+SYS(2015))
runcollectorresetlevel = 0
gfxrotateclass = ("gfxRotate")
gfxrotateclasslib = (THIS.ClassLibrary)
gfxrotatemodule = ("")
reportstoprundatetime = (DTOT({}))
reportstartrundatetime = (DTOT({}))
gfxnorenderclass = ("gfxNoRender")
gfxnorenderclasslib = (THIS.ClassLibrary)
gfxnorendermodule = ("")
_memberdata =     3942&lt;VFPData&gt;&lt;memberdata name="fxs" type="property" display="FXs" favorites="True" /&gt;&lt;memberdata name="gfxs" type="property" display="GFXs" favorites="True" /&gt;&lt;memberdata name="ffcgraphics" type="property" display="FFCGraphics"  favorites="True"/&gt;&lt;memberdata name="createhelperobjects" type="method" display="createHelperObjects"/&gt;&lt;memberdata name="needgfxs" type="method" display="needGFXs"/&gt;&lt;memberdata name="sendfx" type="method" display="sendFX"/&gt;&lt;memberdata name="checkcollectionmembers" type="method" display="checkCollectionMembers"/&gt;&lt;memberdata name="uppermethodname" type="method" display="upperMethodName" favorites="True"/&gt;&lt;memberdata name="cancelrequested" type="property" display="cancelRequested" /&gt;&lt;memberdata name="fxmemberdatascriptclass" type="property" display="fxMemberDataScriptClass" favorites="True" /&gt;&lt;memberdata name="fxmemberdatascriptclasslib" type="property" display="fxMemberDataScriptClassLib" favorites="True" /&gt;&lt;memberdata name="fxmemberdatascriptmodule" type="property" display="fxMemberDataScriptModule" favorites="True" /&gt;&lt;memberdata name="fxfeedbackclass" type="property" display="fxFeedbackClass" favorites="True" /&gt;&lt;memberdata name="fxfeedbackclasslib" type="property" display="fxFeedbackClassLib" favorites="True" /&gt;&lt;memberdata name="fxfeedbackmodule" type="property" display="fxFeedbackModule" favorites="True" /&gt;&lt;memberdata name="getmemberdatascriptfxobject" type="method" display="getMemberDataScriptFXObject" favorites="True"/&gt;&lt;memberdata name="getfeedbackfxobject" type="method" display="getFeedbackFXObject" favorites="True"/&gt;&lt;memberdata name="classpath" type="property" display="classPath" favorites="True"/&gt;&lt;memberdata name="getobjectinstance" type="method" display="getObjectInstance" favorites="True"/&gt;
&lt;memberdata name="checkcollectionforspecifiedmember" type="method" display="checkCollectionForSpecifiedMember" favorites="True"/&gt;&lt;memberdata name="addcollectionmember" type="method" display="addCollectionMember" favorites="True"/&gt;
&lt;memberdata name="getpathforexternals" type="method" display="getPathForExternals" favorites="True" /&gt; &lt;memberdata name="loadfrxcursor" type="property" display="loadFrxCursor" favorites="True" /&gt; &lt;memberdata name="frxcursor" type="property" display="frxCursor" favorites="True" /&gt;
&lt;memberdata name="memberdataalias" type="property" display="memberDataAlias" favorites = "True"/&gt;
&lt;memberdata name="creatememberdatacursor" type="method" display="createMemberDataCursor"/&gt;&lt;memberdata name="runcollectorresetlevel" type="property" favorites="True" display="runCollectorResetLevel"/&gt;&lt;memberdata name="getfrxrecno" type="method" display="getFRXRecno" favorites="True"/&gt;&lt;memberdata name="getrotategfxobject" type="method" display="getRotateGFXObject" favorites="True"/&gt;&lt;memberdata name="gfxrotateclass" type="property" display="gfxRotateClass" favorites="True" /&gt;&lt;memberdata name="gfxrotateclasslib" type="property" display="gfxRotateClassLib" favorites="True" /&gt;&lt;memberdata name="gfxrotatemodule" type="property" display="gfxRotateModule" favorites="True" /&gt;&lt;memberdata name="removecollectionmember" display="removeCollectionMember" type="method" favorites="True"/&gt; &lt;memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" /&gt; &lt;memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" /&gt;&lt;memberdata name="evaluateuserexpression" display="evaluateUserExpression" type="method"/&gt;&lt;memberdata name="getnorendergfxobject" type="method" display="getNoRenderGFXObject" favorites="True"/&gt;&lt;memberdata name="gfxnorenderclass" type="property" display="gfxNoRenderClass" favorites="True" /&gt;&lt;memberdata name="gfxnorenderclasslib" type="property" display="gfxNoRenderClassLib" favorites="True" /&gt;&lt;memberdata name="gfxnorendermodule" type="property" display="gfxNoRenderModule" favorites="True" /&gt;&lt;memberdata name="ensurecollection" type="method" display="ensureCollection"/&gt;
&lt;/VFPData&gt;
Name = "fxlistener"
</properties>
		<protected>createhelperobjects
needgfxs
sendfx
checkcollectionmembers
uppermethodname
getfeedbackfxobject
getobjectinstance
getmemberdatascriptfxobject
creatememberdatacursor
getrotategfxobject
evaluateuserexpression
getnorendergfxobject
ensurecollection
</protected>
		<methods>PROCEDURE addcollectionmember
LPARAMETERS m.tcClass, m.tcClassLib,m.tcModule,m.tlSingleton, m.tlInGFX, m.tlRequired

LOCAL m.loX, m.lExists, m.liReturn

m.liReturn = OUTPUTFX_ADDCOLLECTION_NOACTION

IF m.tlSingleton
m.lExists =  THIS.checkCollectionForSpecifiedMember(m.tcClass,m.tcClassLib,m.tlInGFX)
ELSE
* checkCollectionForSpecifiedMember will have done this already
THIS.ensureCollection(m.tlInGFX)
ENDIF

IF NOT m.lExists
m.loX = THIS.getObjectInstance(;
m.tcClass,;
m.tcClassLib,;
m.tcModule, ;
.T., IIF(tlInGFX,"GFX","FX"),tlRequired)
IF ISNULL(m.loX)
m.liReturn = OUTPUTFX_ADDCOLLECTION_FAILURE
ELSE
IF (NOT PEMSTATUS(m.loX,"ApplyFX",5))
m.liReturn = OUTPUTFX_ADDCOLLECTION_UNSUITABLE
ELSE
IF tlInGFX
THIS.GFXs.Add(m.loX)
ELSE
THIS.FXs.Add(m.loX)
ENDIF
m.liReturn = OUTPUTFX_ADDCOLLECTION_SUCCESS
ENDIF
ENDIF

ENDIF

RETURN m.liReturn

ENDPROC
PROCEDURE AdjustObjectSize
LPARAMETERS m.nFRXRecno, m.oObjProperties
THIS.sendFX(PROGRAM(),m.nFRXRecno, m.oObjProperties)
NODEFAULT
IF (NOT ISNULL(THIS.Successor))
THIS.SetSuccessorDynamicProperties()
THIS.Successor.AdjustObjectSize(m.nFRXRecno, m.oObjProperties)
ENDIF
DODEFAULT(m.nFRXRecno, m.oObjProperties)
ENDPROC
PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
THIS.sendFX(PROGRAM(),m.nBandObjCode, m.nFRXRecNo)
NODEFAULT
RETURN DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
ENDPROC
PROCEDURE AfterReport
THIS.sendFX(PROGRAM())
NODEFAULT
RETURN DODEFAULT()

ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
IF m.nBandObjCode = FRX_OBJCOD_PAGEHEADER  ;
AND THIS.GFXs.Count &gt; 0
THIS.FFCGraphics.SetHandle(THIS.GDIPlusGraphics)
ENDIF
THIS.sendFX(PROGRAM(),m.nBandObjCode, m.nFRXRecNo)
NODEFAULT
RETURN DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
ENDPROC
PROCEDURE BeforeReport
THIS.setFRXDataSession()
IF (NOT THIS.IsSuccessor)
THIS.createMemberDataCursor()
IF NOT ISNULL(THIS.successor)
THIS.successor.AddProperty("memberDataAlias",THIS.memberDataAlias)
ENDIF
ENDIF

* second opportunity to create FX and GFX objects,
* in case some are needed that were not needed before:
THIS.checkCollectionMembers(.T.)

* second opportunity to create non-optional helper members,
* in case some are needed that were not needed before,
* Any items that would have been required for
* FX/GFX-specific use should already have been created during
* LoadReport, so this set of calls is "backwards"
* from LoadReport pairing:
THIS.createHelperObjects(.T.)

* note: at this point,
* the FX and GFX objects have
* an opportunity to
* adjust items such as CallAdjustObjectSize, CallEvaluateContents, TwoPassProcess
THIS.sendFX(PROGRAM())
NODEFAULT
RETURN DODEFAULT()

ENDPROC
PROCEDURE CancelReport
IF THIS.FXs.Count &gt; 0
THIS.sendFX(PROGRAM())
IF THIS.cancelRequested
DODEFAULT()
ELSE
NODEFAULT
ENDIF
ELSE
DODEFAULT()
ENDIF

ENDPROC
PROCEDURE cancelrequested_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
THIS.cancelRequested = m.vNewVal
ENDIF

ENDPROC
PROCEDURE checkcollectionforspecifiedmember
LPARAMETERS m.tcClass, m.tcClassLib, m.tlInGFX, m.tlReturnRef

LOCAL m.liIndex, m.loXs, m.loX, m.lcForceVCX, m.lcClassLib, ;
m.lcClass, m.lcThisLib, m.llFound, m.loRef

THIS.ensureCollection(m.tlInGFX)

IF m.tlInGFX
m.loXs = THIS.GFXs
ELSE
m.loXs = THIS.FXs
ENDIF

m.loRef = NULL

m.lcClass = UPPER(m.tcClass)

IF NOT EMPTY(m.tcClassLib)
m.lcClassLib = UPPER(JUSTFNAME(m.tcClassLib))
m.lcForceVCX = FORCEEXT(lcClassLib,"VCX")
m.lcForceFXP = STRTRAN(lcClassLib,".PRG",".FXP")
ENDIF

FOR m.liIndex = 1 TO m.loXs.Count
m.loX = loXs.Item(liIndex)
m.lcThisLib = UPPER(JUSTFNAME(loX.ClassLibrary))
IF UPPER(loX.Class) == m.lcClass AND ;
(EMPTY(m.lcClassLib) OR ;
m.lcThisLib == m.lcClassLib OR ;
m.lcThisLib == m.lcForceVCX OR ;
m.lcThisLib == m.lcForceFXP)
m.llFound = .T.
m.loRef = m.loX
EXIT
ENDIF
NEXT

IF m.tlReturnRef
RETURN m.loRef
ELSE
RETURN m.llFound
ENDIF
ENDPROC
PROCEDURE checkcollectionmembers
LPARAMETERS m.tlCalledFromBeforeReport
* NB: use of this argument and
* no distinction made between calls from
* BeforeReport and LoadReport at this level,
* this distinction is made available for subclasses
* that might not have all materials prepared for
* creation of required collection members during Load.

LOCAL m.liIndex, m.loX, m.loXs as Collection

THIS.getFeedbackFXObject()

THIS.getMemberDataScriptFXObject()

THIS.getRotateGFXObject()

THIS.getNoRenderGFXObject()

m.loXs = THIS.FXs

FOR m.liIndex = 1 TO THIS.FXs.Count
m.loX = loXs.Item(m.liIndex)
IF VARTYPE(m.loX) # "O" OR ;
(NOT PEMSTATUS(m.loX,"ApplyFX",5))
loXs.Remove(m.liIndex)
ENDIF
NEXT

m.loXs = THIS.GFXs

FOR m.liIndex = 1 TO THIS.GFXs.Count
m.loX = loXs.Item(liIndex)
IF VARTYPE(m.loX) # "O" OR ;
(NOT PEMSTATUS(m.loX,"ApplyFX",5))
loXs.Remove(m.liIndex)
ENDIF
NEXT

STORE NULL TO m.loX, m.loXs



ENDPROC
PROCEDURE classpath_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND ;
DIRECTORY(m.vNewVal)
IF NOT EMPTY(m.vNewVal)
m.vNewVal = ADDBS(m.vNewVal)
ENDIF
THIS.classPath = m.vNewVal
ELSE
THIS.ResetToDefault("classPath")
ENDIF



ENDPROC
PROCEDURE ClearStatus
THIS.sendFX(PROGRAM())


ENDPROC
PROCEDURE createhelperobjects
LPARAMETERS m.tlCalledFromBeforeReport
* see note in CheckCollectionMembers method about parameter, which
* is not used here but could provide significant information to
* subclasses

* NB this method creates only required helpers, not optional FX objects
* which is handled in CheckCollectionMembers
EXTERNAL CLASS _GDIPLUS.VCX
LOCAL liSession
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
THIS.ensureCollection()
THIS.ensureCollection(.T.)
SET DATASESSION TO (m.liSession)
IF VARTYPE(THIS.FFCGraphics) # "O"  AND THIS.GFXs.Count &gt; 0
THIS.FFCGraphics =;
THIS.getObjectInstance("GpGraphics","_GDIPlus.VCX","", .T.,"GP", .T.)
IF NOT ISNULL(THIS.FFCGraphics)
THIS.FFCGraphics.QuietOnError = THIS.QuietMode
ENDIF
ENDIF


ENDPROC
PROCEDURE creatememberdatacursor

IF USED("FRX")
SELECT FRX
LOCATE FOR Platform = FRX_PLATFORM_WINDOWS AND NOT (EMPTY(Style) OR DELETED())
IF  EOF()
THIS.loadFrxCursor = .F.
ELSE
THIS.loadFRXCursor = .T.
DO CASE
CASE (NOT THIS.loadFRXCursor) OR ISNULL(THIS.FRXCursor)
* message already taken care of
CASE PEMSTATUS(THIS.FRXCursor,"UnpackFRXMemberdata",5)
THIS.FRXCursor.UnpackFRXMemberData("FRX",THIS.memberDataAlias,THIS.FRXDataSession)
OTHERWISE
THIS.DoMessage(OUTPUTFX_SCRIPTING_UNAVAILABLE_LOC ,MB_ICONEXCLAMATION)
ENDCASE
ENDIF
ENDIF

ENDPROC
PROCEDURE Destroy
STORE NULL TO THIS.FXs, THIS.GFXs, THIS.FFCGraphics, ;
THIS.FRXCursor
DODEFAULT()
ENDPROC
PROCEDURE DoStatus
LPARAMETERS m.cMessage
THIS.sendFX(PROGRAM(),m.cMessage)
NODEFAULT

ENDPROC
PROCEDURE ensurecollection
LPARAMETERS m.tlGFXs
IF m.tlGFXs
IF VARTYPE(THIS.GFXs) # "O" OR ;
(NOT UPPER(THIS.GFXs.BaseClass) == "COLLECTION")
THIS.GFXs = CREATEOBJECT("Collection")
ENDIF
ELSE
IF VARTYPE(THIS.FXs) # "O" OR ;
(NOT UPPER(THIS.FXs.BaseClass) == "COLLECTION")
THIS.FXs = CREATEOBJECT("Collection")
ENDIF
ENDIF

ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS m.nFRXRecno, m.oObjProperties
THIS.sendFX(PROGRAM(),m.nFRXRecno, m.oObjProperties)
NODEFAULT
IF (NOT ISNULL(THIS.Successor))
THIS.SetSuccessorDynamicProperties()
THIS.Successor.EvaluateContents(m.nFRXRecno, m.oObjProperties)
ENDIF
DODEFAULT(m.nFRXRecno, m.oObjProperties)
ENDPROC
PROCEDURE evaluateuserexpression
LPARAMETERS m.tvValueExpr
LOCAL m.liSession, m.lvValue
m.lvValue = ""
m.liSession = SET("DATASESSION")
THIS.setCurrentDataSession()
IF TYPE(m.tvValueExpr) # "U"
m.lvValue = EVALUATE(m.tvValueExpr)
ELSE
THIS.setFRXDataSession()
IF TYPE(m.tvValueExpr) # "U"
m.lvValue = EVALUATE(m.tvValueExpr)
ELSE
THIS.resetDataSession()
IF TYPE(m.tvValueExpr) # "U"
m.lvValue = EVALUATE(m.tvValueExpr)
ELSE
IF TYPE ("THIS.CommandClauses.StartDatasession") = "N" AND ;
THIS.CommandClauses.StartDatasession &gt; 0 AND ;
(THIS.CommandClauses.StartDatasession # THIS.ListenerDataSession)
SET DATASESSION TO (THIS.CommandClauses.StartDataSession)
IF TYPE(m.tvValueExpr) # "U"
m.lvValue = EVALUATE(m.tvValueExpr)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
SET DATASESSION TO (m.liSession)
RETURN m.lvValue
ENDPROC
PROCEDURE ffcgraphics_assign
LPARAMETERS m.tvNewVal
DO CASE
CASE ISNULL(m.tvNewVal) AND (NOT THIS.isRunning)
THIS.FFCGraphics = m.tvNewVal
CASE VARTYPE(m.tvNewVal) = "O"
LOCAL laDummy[1]
IF ACLASS(laDummy,m.tvNewVal) &gt; 0 AND ;
ASCAN(laDummy,"GpGraphics",1,ALEN(laDummy),1, 7) &gt; 0 &amp;&amp; case insensitive, exact on
THIS.FFCGraphics = m.tvNewVal
ENDIF
OTHERWISE
* don't
ENDCASE

ENDPROC
PROCEDURE frxcursor_access
IF (NOT THIS.IsRunning) AND ;
ISNULL(THIS.frxCursor) AND THIS.loadFRXCursor
THIS.frxCursor = ;
THIS.getObjectInstance("FRXCursor","_FRXCURSOR.VCX","", .T.,"frx", .T.)
IF ISNULL(THIS.frxCursor)
THIS.loadFRXCursor = .F.
ELSE
THIS.frxCursor.QuietMode = THIS.QuietMode
ENDIF
ENDIF
RETURN THIS.frxCursor

ENDPROC
PROCEDURE frxcursor_assign
LPARAMETERS m.vNewVal
IF ISNULL(m.vNewVal) OR (NOT THIS.IsRunning)
THIS.frxcursor = m.vNewVal
ENDIF

ENDPROC
PROCEDURE fxfeedbackclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
THIS.fxFeedbackClass = m.vNewVal
ENDIF
ENDPROC
PROCEDURE fxfeedbackclasslib_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
THIS.fxFeedbackClassLib = m.vNewVal
ENDIF

ENDPROC
PROCEDURE fxfeedbackmodule_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.fxFeedbackModule = m.vNewVal
ENDIF

ENDPROC
PROCEDURE fxmemberdatascriptclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
THIS.fxMemberDataScriptClass = m.vNewVal
ENDIF

ENDPROC
PROCEDURE fxmemberdatascriptclasslib_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
THIS.fxMemberDataScriptClassLib = m.vNewVal
ENDIF

ENDPROC
PROCEDURE fxmemberdatascriptmodule_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.fxMemberDataScriptModule = m.vNewVal
ENDIF

ENDPROC
PROCEDURE getfeedbackfxobject
LPARAMETERS m.tlQuiet


IF (NOT THIS.QuietMode) AND ;
(NOT THIS.isSuccessor) AND ;
(TYPE("THIS.CommandClauses.NoDialog") # "L" OR ;
(NOT THIS.CommandClauses.NoDialog))

THIS.addCollectionMember(;
THIS.fxFeedbackClass,;
THIS.fxFeedbackClassLib,;
THIS.fxFeedbackModule, .T.)

IF NOT THIS.checkCollectionForSpecifiedMember(;
THIS.fxFeedbackClass,;
THIS.fxFeedbackClassLib)
IF NOT m.tlQuiet
THIS.DoMessage(OUTPUTFX_USERFEEDBACK_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
ENDIF
THIS.QuietMode = .T.
ENDIF

ENDIF


ENDPROC
PROCEDURE getfrxrecno
LPARAMETERS m.tcMethodToken,m.tP1, m.tP2

LOCAL m.liFRXRecno, m.liSession

m.liFRXRecno = 0

DO CASE
CASE INLIST(m.tcMethodToken,"BEFOREREPORT","AFTERREPORT","LOADREPORT","UNLOADREPORT")
IF THIS.frxHeaderRecno = -1
* this is an early call. find the value early if possible
m.liSession = SET("DATASESSION")
THIS.setFRXDataSession()
IF USED("FRX")
SELECT FRX
LOCATE FOR ObjType = FRX_OBJTYP_REPORTHEADER AND ;
Platform = FRX_PLATFORM_WINDOWS AND ;
NOT DELETED()
THIS.frxHeaderRecno = RECNO()
ELSE
THIS.frxHeaderRecno = 1
ENDIF
SET DATASESSION TO (m.liSession)
ENDIF
m.liFRXRecNo = THIS.frxHeaderRecno
CASE INLIST(m.tcMethodToken,"BEFOREBAND","AFTERBAND") AND ;
VARTYPE(m.tP2) = "N" &amp;&amp; Band events
m.liFRXRecNo = m.tP2
CASE VARTYPE(m.tP1) = "N"  &amp;&amp; Render, other events
m.liFRXRecNo = m.tP1
OTHERWISE
* called inappropriately
ENDCASE

RETURN  m.liFRXRecno
ENDPROC
PROCEDURE getmemberdatascriptfxobject

THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias) AND ;
RECCOUNT(THIS.memberDataAlias) &gt; 0
SELECT (THIS.memberDataAlias)
LOCATE FOR (NOT EMPTY(Execute))
IF NOT EOF()
THIS.addCollectionMember(;
THIS.fxMemberDataScriptClass,;
THIS.fxMemberDataScriptClassLib,;
THIS.fxMemberDataScriptModule, .T.)
IF NOT THIS.checkCollectionForSpecifiedMember(;
THIS.fxMemberDataScriptClass,;
THIS.fxMemberDataScriptClassLib)
THIS.DoMessage(OUTPUTFX_SCRIPTING_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
ENDIF
ENDIF
IF USED("FRX")
SELECT FRX
ENDIF
ENDIF



ENDPROC
PROCEDURE getnorendergfxobject
IF NOT EMPTY(THIS.gfxNoRenderClass)
LOCAL m.llNeedThisGFX, m.llOpenedMemberData
THIS.setFRXDataSession()
IF (NOT USED(THIS.memberDataAlias)) AND ;
(NOT THIS.CommandClauses.IsDesignerLoaded) AND ;
(NOT THIS.checkCollectionForSpecifiedMember(;
THIS.gfxNoRenderClass,;
THIS.gfxNoRenderClassLib, .T.))
IF NOT USED("FRX") &amp;&amp; during LoadReport
IF FILE(THIS.CommandClauses.File)
USE (THIS.CommandClauses.File) AGAIN SHARED NOUPDATE ALIAS FRX
* this is a special situation, in that
* this gfx needs to be available to do a swap
* *before* memberdata is commonly available.
* At this point, depending on what else has happened,
* Memberdata may or may not be here. If it is not,
* we could build the memberdata cursor here temporarily --
* the gfx itself will do that, in fact -- but in this
* method we're just ascertaining the requirement for
* the gfx to *exist*.  This doesn't merit the extra time
* to do an exact comparison of the appropriate memberdata
* element.  If we might need it, the class should be
* instantiated.  Let it do the special build of memberdata
* later and do its evaluations at that time.
LOCATE FOR  FRX_BLDR_ADVPROP_PREPROCESS_NORENDER $ Style ;
AND NOT DELETED()
m.llNeedThisGFX = (NOT EOF())
USE IN FRX
ELSE
* built-into another app, just load without the check
m.llNeedThisGFX = .T.
ENDIF
IF m.llNeedThisGFX
THIS.loadFrxCursor = .T.
ENDIF
ENDIF
ENDIF
IF (NOT m.llNeedThisGFX) AND ;
USED(THIS.memberDataAlias) AND ;
RECCOUNT(THIS.memberDataAlias) &gt; 0
* now we'll check in the normal way later in the report for
* any required instance suppression, which occurs
* later in the report cycle and can use the normal build
* of memberdata
SELECT (THIS.memberDataAlias)
LOCATE FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
(ExecWhen == FRX_BLDR_ADVPROP_INSTANCE_NORENDER AND ;
NOT EMPTY(Execute))  OR ;
(ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER)
IF NOT EOF()
m.llNeedThisGFX = .T.
ENDIF
ENDIF
IF m.llNeedThisGFX
THIS.addCollectionMember(;
THIS.gfxNoRenderClass,;
THIS.gfxNoRenderClassLib,;
THIS.gfxNoRenderModule, .T., .T.)
IF NOT THIS.checkCollectionForSpecifiedMember(;
THIS.gfxNoRenderClass,;
THIS.gfxNoRenderClassLib, .T.)
THIS.DoMessage(OUTPUTFX_CONDITIONALRENDERING_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
ENDIF
ENDIF
IF USED("FRX")
SELECT FRX
ENDIF
ENDIF

ENDPROC
PROCEDURE getobjectinstance
LPARAMETERS m.tcClass, m.tcClassLib, m.tcModule, ;
m.tlAssignUniqueNameToObject, ;
m.tcNamePrefix, m.tlMandatoryObject

IF VARTYPE(m.tcClass) # "C" OR EMPTY(m.tcClass)
IF m.tlMandatoryObject
THIS.DoMessage(OUTPUTFX_REQUIREDOBJECTDEF_MISSING_LOC,MB_ICONEXCLAMATION)
ENDIF
RETURN NULL
ENDIF

LOCAL m.loX,m.lcForceVCX, m.lcForceFXP, m.lcUseThisLib, m.lcExternalsPath, m.liSession

liSession = SET("DATASESSION")
THIS.ResetDataSession()
m.lcForceVCX = FORCEEXT(m.tcClassLib,"VCX")
m.lcForceFXP = STRTRAN(m.tcClassLib,".PRG",".FXP")
m.lcExternalsPath = THIS.getPathForExternals()

m.loX = NULL

TRY
DO CASE
CASE FILE(m.tcClassLib) OR ;
FILE(m.lcForceVCX) OR ;
ATC(FULLPATH(m.lcForceVCX) + " ALIAS ",SET("CLASSLIB")) &gt; 0 OR ;
ATC("\" + JUSTFNAME(m.lcForceVCX) + " ALIAS ",SET("CLASSLIB")) &gt; 0 OR ;
ATC(m.tcClassLib,SET("PROCEDURE")) &gt; 0 OR ;
ATC(m.lcForceFXP,SET("PROCEDURE")) &gt; 0
m.lcUseThisLib = m.tcClassLib
CASE FILE(FORCEPATH(m.tcClassLib,m.lcExternalsPath)) OR ;
FILE(FORCEPATH(m.lcForceVCX,m.lcExternalsPath)) OR ;
FILE(FORCEPATH(m.lcForceFXP,m.lcExternalsPath))
m.lcUseThisLib = FORCEPATH(m.tcClassLib,m.lcExternalsPath)
CASE FILE(FORCEPATH(m.tcClassLib,HOME(0)+"FFC\")) OR ;
FILE(FORCEPATH(m.lcForceVCX,HOME(0)+"FFC\"))
FILE(FORCEPATH(m.lcForceFXP,HOME(0)+"FFC\"))
m.lcUseThisLib = FORCEPATH(m.tcClassLib,HOME(0) + "FFC\")
CASE FILE(FORCEPATH(m.tcClassLib,HOME(0)+"FFC\" + THIS.classPath)) OR ;
FILE(FORCEPATH(m.lcForceVCX,HOME(0)+"FFC\" + THIS.classPath))
FILE(FORCEPATH(m.lcForceFXP,HOME(0)+"FFC\" + THIS.classPath))
m.lcUseThisLib = FORCEPATH(m.tcClassLib,HOME(0) + "FFC\" + THIS.classPath)
OTHERWISE
m.lcUseThisLib = m.tcClassLib
* may error, but if it's a required object,
* it *should* error.
ENDCASE

m.loX =  NEWOBJECT(m.tcClass, m.lcUseThisLib, ;
IIF(VARTYPE(m.tcModule)="C",m.tcModule,""))

IF (NOT ISNULL(m.loX)) AND m.tlAssignUniqueNameToObject
m.tcNamePrefix = IIF(VARTYPE(m.tcNamePrefix) = "C", ;
m.tcNamePrefix, "FXH")
m.loX.Name = m.tcNamePrefix + SYS(2015)
ENDIF

CATCH TO err
m.loX = NULL
#IF OUTPUTCLASS_DEBUGGING
SUSPEND
#ENDIF
ENDTRY

IF m.tlMandatoryObject AND ISNULL(m.loX)
THIS.DoMessage(OUTPUTFX_REQUIREDOBJECT_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
ENDIF
SET DATASESSION TO (m.liSession)
RETURN m.loX
ENDPROC
PROCEDURE getpathforexternals
* this is  mostly for standalone use
* first figure out where to put it
* with the idea of not littering
* the disk too much based on CURDIR().

* For app pieces, look for a container module
* and put it there.
* if there isn't one,
* put it with the VCX

LOCAL m.liLevel, m.lcSys16, m.lcPath

IF ":" $ THIS.classPath
* explicit path
m.lcPath = THIS.classPath
ELSE
FOR m.liLevel = PROGRAM(-1) TO 1 STEP -1
m.lcSys16 = UPPER(SYS(16,m.liLevel))
IF INLIST(RIGHT(m.lcSys16,3),"APP","EXE","DLL")
m.lcPath = JUSTPATH(m.lcSys16)
EXIT
ENDIF
ENDFOR
IF (NOT EMPTY(lcPath)) AND ;
(NOT EMPTY(THIS.classPath)) AND ;
DIRECTORY(FULLPATH(THIS.classPath,ADDBS(lcPath)))
m.lcPath = FULLPATH(THIS.classPath,ADDBS(lcPath))
ENDIF
ENDIF

IF EMPTY(m.lcPath)
m.lcPath = JUSTPATH(THIS.ClassLibrary)
IF (NOT EMPTY(lcPath)) AND ;
(NOT EMPTY(THIS.classPath)) AND ;
DIRECTORY(FULLPATH(THIS.classPath,ADDBS(lcPath)))
m.lcPath = FULLPATH(THIS.classPath,ADDBS(lcPath))
ENDIF
ENDIF

IF NOT DIRECTORY(m.lcPath)
m.lcPath = ""
ELSE
m.lcPath = ADDBS(m.lcPath)
ENDIF

RETURN m.lcPath
ENDPROC
PROCEDURE getrotategfxobject
THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias) AND RECCOUNT(THIS.memberDataAlias) &gt; 0
SELECT (THIS.memberDataAlias)
LOCATE FOR  Type = FRX_BLDR_MEMBERDATATYPE AND ;
Name == FRX_BLDR_NAMESPACE_ROTATE AND ;
NOT EMPTY(Execute)
IF NOT EOF()
THIS.addCollectionMember(;
THIS.gfxRotateClass,;
THIS.gfxRotateClassLib,;
THIS.gfxRotateModule, .T., .T.)
IF NOT THIS.checkCollectionForSpecifiedMember(;
THIS.gfxRotateClass,;
THIS.gfxRotateClassLib, .T.)
THIS.DoMessage(OUTPUTFX_ROTATION_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
ENDIF

ENDIF
IF USED("FRX")
SELECT FRX
ENDIF
ENDIF

ENDPROC
PROCEDURE gfxnorenderclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.gfxNoRenderClass = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxnorenderclasslib_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.gfxNoRenderClassLib = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxnorendermodule_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.gfxNoRenderModule = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxrotateclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
THIS.gfxRotateClass = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxrotateclasslib_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
THIS.gfxRotateClassLib = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxrotatemodule_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
THIS.gfxRotateModule = m.vNewVal
ENDIF

ENDPROC
PROCEDURE Init
IF DODEFAULT()
THIS.AppName = OUTPUTFX_APPNAME_LOC
THIS.Name = "FX" + SYS(2015)
THIS.createHelperObjects()
*&amp;* THIS.getFeedbackFXObject(.T.)
ELSE
RETURN .F.
ENDIF

RETURN NOT THIS.hadError
ENDPROC
PROCEDURE loadfrxcursor_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
THIS.loadfrxcursor = m.vNewVal
ENDIF

ENDPROC
PROCEDURE LoadReport
* always start with full reset for this run:
THIS.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_NEVER
THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_NEVER
THIS.commandClausesFile = THIS.CommandClauses.File

* see notes in BeforeReport
THIS.createHelperObjects()
THIS.checkCollectionMembers()
THIS.setFRXDataSessionEnvironment()
THIS.sendFX(PROGRAM())

NODEFAULT
RETURN DODEFAULT() &amp;&amp; these changes can be passed on to successors

ENDPROC
PROCEDURE memberdataalias_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
THIS.memberDataAlias = m.vNewVal
ENDIF

ENDPROC
PROCEDURE needgfxs
LPARAMETERS m.tcProgram,;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP8, m.tP10, m.tP11, m.tP12
* hook
* a subclass could evaluate conditions,
* such as whether any objects have custom properties
* requiring GFX activity.

RETURN .T.
ENDPROC
PROCEDURE quietmode_assign
LPARAMETERS m.vNewVal
DODEFAULT(m.vNewVal)
IF THIS.loadFRXCursor AND (NOT ISNULL(THIS.FRXCursor))
THIS.FRXCursor.QuietMode = THIS.QuietMode
ENDIF
IF NOT ISNULL(THIS.FFCGraphics)
THIS.FFCGraphics.QuietOnError = THIS.QuietMode
ENDIF


ENDPROC
PROCEDURE removecollectionmember
LPARAMETERS m.tcName, m.tlInGFX, m.tlNameIsClass

LOCAL m.liIndex, m.loXs, m.loX, m.llFound, m.lcName

IF EMPTY(m.tcName) OR VARTYPE(m.tcName) # "C"
RETURN .F.
ENDIF

IF m.tlInGFX
m.loXs = THIS.GFXs
ELSE
m.loXs = THIS.FXs
ENDIF

m.lcName = ALLTRIM(UPPER(m.tcName))

FOR m.liIndex = 1 TO m.loXs.Count
m.loX = loXs.Item(liIndex)
IF (UPPER(loX.Name) == m.lcName) OR ;
(m.tlNameIsClass AND UPPER(loX.Class) == m.lcName)
m.loXs.Remove(m.liIndex)
m.llFound = .T.
EXIT
ENDIF
NEXT

RETURN m.llFound
ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage

LOCAL m.liDefaultBehavior,m.llNeedGFXs, m.lnState

m.llNeedGFXs = (NOT THIS.IsSuccessor) AND THIS.GFXs.Count &gt; 0 AND ;
THIS.NeedGFXs(PROGRAM(),m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)

IF m.llNeedGFXs
THIS.FFCGraphics.SetHandle(THIS.GDIPlusGraphics)
* done in BeforeBand for the page header
* for GFX objects, in case they (for any reason) choose to
* manipulate the page in other methods than Render.
* but we'll do it again here.
THIS.FFCGraphics.Save(@m.lnState)
ENDIF

m.liDefaultBehavior = ;
THIS.sendFX(PROGRAM(),m.nFRXRecNo,;
@m.nLeft,@m.nTop,@m.nWidth,@m.nHeight,;
@m.nObjectContinuationType, ;
@m.cContentsToBeRendered, @m.GDIPlusImage)
NODEFAULT

* note that FX objects get the args passed by reference,
* however the GFX objects
* should not be seeking to change these args and
* receive the args passed by value. Their
* job is to draw, not to change what is drawn by others or the base.

DO CASE

CASE m.llNeedGFXs AND ;
m.liDefaultBehavior = OUTPUTFX_BASERENDER_RENDER_BEFORE_RESTORE

DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
THIS.FFCGraphics.Restore(m.lnState)

CASE m.llNeedGFXs AND ;
m.liDefaultBehavior &gt;= OUTPUTFX_BASERENDER_NORENDER
THIS.FFCGraphics.Restore(m.lnState)
IF (NOT ISNULL(THIS.Successor))
THIS.SetSuccessorDynamicProperties()
THIS.Successor.Render(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
ENDIF

CASE m.llNeedGFXs &amp;&amp; OUTPUTFX_BASERENDER_AFTERRESTORE, ;
&amp;&amp; OUTPUTFX_DEFAULT_RENDER_BEHAVIOR

THIS.FFCGraphics.Restore(m.lnState)
DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)

OTHERWISE  &amp;&amp; no GFX behavior at all, just base behavior

DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)

ENDCASE

RETURN m.liDefaultBehavior
ENDPROC
PROCEDURE reportstartrundatetime_access
LOCAL m.lox, m.ldt
m.lox = THIS.checkCollectionForSpecifiedMember(;
THIS.fxFeedbackClass, THIS.fxFeedbackClassLib,.f., .t.)
IF (NOT ISNULL(m.lox)) AND PEMSTATUS(m.lox,"reportStartRunDatetime",5)
m.ldt = m.lox.reportStartRunDateTime
ELSE
m.ldt = THIS.reportStartRunDateTime
ENDIF
m.lox = NULL
RETURN m.ldt


ENDPROC
PROCEDURE reportstoprundatetime_access
LOCAL m.lox, m.ldt
m.lox = THIS.checkCollectionForSpecifiedMember(;
THIS.fxFeedbackClass, THIS.fxFeedbackClassLib,.F., .T.)
IF (NOT ISNULL(m.lox)) AND PEMSTATUS(m.lox,"reportStopRunDatetime",5)
m.ldt = lox.reportStopRunDateTime
ELSE
m.ldt = THIS.reportStopRunDateTime
ENDIF
m.lox = NULL
RETURN m.ldt


ENDPROC
PROCEDURE resetcalladjustobjectsize
* abstract, note that fx and gfx objects already
* have an opportunity via sendFX call.
ENDPROC
PROCEDURE resetcallevaluatecontents
* abstract, note that fx and gfx objects already
* have an opportunity via sendFX call.

ENDPROC
PROCEDURE runcollectorresetlevel_assign
LPARAMETERS tvNewVal
IF VARTYPE(m.tvNewVal) = "N" AND ;
INLIST(m.tvNewVal,OUTPUTFX_RUNCOLLECTOR_RESET_NEVER , ;
OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT,;
OUTPUTFX_RUNCOLLECTOR_RESET_ONCHAIN)
THIS.runCollectorResetLevel = m.tvNewVal
ENDIF

ENDPROC
PROCEDURE sendfx
LPARAMETERS m.tcProgram, ;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, ;
m.tP6, m.tP7, m.tP8, m.tP9, m.tP10, ;
m.tP11, m.tP12)
LOCAL m.loFX, m.liRenderBehavior, m.liTemp, m.lcMethodToken
m.liRenderBehavior = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR
IF THIS.IsSuccessor
* Only the lead does this work.
RETURN m.liRenderBehavior
ENDIF
m.lcMethodToken = THIS.upperMethodName(m.tcProgram)
IF VARTYPE(THIS.FXs) = "O" AND THIS.FXs.Count &gt; 0
* The order of the
* invocation of this method,
* which precedes the DODEFAULT()
* in each event,
* makes the results available
* for all Successors.
FOR EACH m.loFX IN THIS.FXs FOXOBJECT
IF VARTYPE(m.loFX) = "O" &amp;&amp; contract API is checked in LoadReport and BeforeReport
&amp;&amp; but the object could release itself midway through a run
THIS.setCurrentDataSession()
m.loFX.ApplyFX(THIS,m.lcMethodToken, ;
@tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
@tP7, @tP8, @tP9, @tP10, @tP11, @tP12)
ENDIF
NEXT
ENDIF
IF VARTYPE(THIS.GFXs) = "O" AND THIS.GFXs.Count &gt; 0 AND ;
THIS.NeedGFXs(m.lcMethodToken,;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, ;
m.tP6, m.tP7, m.tP8, m.tP9, m.tP10, ;
m.tP11, m.tP12)
FOR EACH m.loFX IN THIS.GFXs FOXOBJECT
IF VARTYPE(m.loFX) = "O" &amp;&amp; contract API is checked in LoadReport and BeforeReport
&amp;&amp; but the object could release itself midway through a run
THIS.setCurrentDataSession()
m.liTemp = INT(VAL(TRANSFORM(m.loFX.ApplyFX(THIS, m.lcMethodToken, ;
@tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
@tP7, @tP8, @tP9, @tP10, @tP11, @tP12))))
IF m.liTemp &gt; m.liRenderBehavior  &amp;&amp; behavior is cumulative
m.liRenderBehavior = INT(m.liTemp)
ENDIF
ENDIF
NEXT
ENDIF
RETURN m.liRenderBehavior  &amp;&amp; this value only affects calls during Render method


ENDPROC
PROCEDURE UnloadReport
THIS.sendFX(PROGRAM())
THIS.CommandClauses.File = THIS.commandClausesFile
THIS.commandClausesFile = NULL
RETURN DODEFAULT()

ENDPROC
PROCEDURE UpdateStatus
THIS.sendFX(PROGRAM())
NODEFAULT

ENDPROC
PROCEDURE uppermethodname
LPARAMETERS m.tcProgram
LOCAL m.lcProgram
m.lcProgram = UPPER(TRANSFORM(m.tcProgram))
RETURN SUBSTR(m.lcProgram,RAT(".",m.lcProgram) + 1)
ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>fxs A collection of FX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,tP1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value ignored
gfxs A collection of GFX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,P1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value significant to Render method.
ffcgraphics A reference to an FFCGraphic object created during the run and provided to members of the GFXs collection. Validated as instance of GpGraphics from the FFC _GDIPLUS.VCX or a class derived from GpGraphics.
cancelrequested Notification flag for FX objects to request a report cancellation.
fxfeedbackclass Class to instantiate in FX collection for user feedback (defaults to fxTherm).
fxfeedbackclasslib Class library from which to instantiate FX collection object providing user feedback.
fxfeedbackmodule Application module (APP or EXE)  from which to instantiate FX collection object providing user feedback.
classpath Provides optional location specifying path for loading objects from external libraries.
fxmemberdatascriptclass Class to instantiate in FX collection for memberdata-based script handling (defaults to fxMemberDataScript).
fxmemberdatascriptclasslib Class library from which to instantiate FX collection object providing memberdata-based script-handling.
fxmemberdatascriptmodule Application module (APP or EXE)  from which to instantiate FX collection object providing memberdata-based script-handling.
frxcursor Holds a reference to an FRXCursor helper object to aid in run-time calculations related to FRX metadata, structure, and memberdata.
loadfrxcursor Determines whether this class should dynamically load an instance of the helper class FRXCursor when attempting to access a reference to it.
memberdataalias Alias of cursor holding memberdata in the FRXDataSession, read from the FRX table's Style field for easy access by other objects.
runcollectorresetlevel Indicates how often the runCollector member should be automatically reset by the reportListener (0=never, 1=after each report, 2=after a chained report run).
gfxrotateclass Class to instantiate in GFX collection for rotating layout controls (defaults to gfxRotate).
gfxrotateclasslib Class library from which to instantiate GFX collection object providing rotation.
gfxrotatemodule Application module (APP or EXE)  from which to instantiate GFX collection object providing rotation.
reportstoprundatetime A datetime value for use at the conclusion of a report run, storing when the last report generation run ended, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
reportstartrundatetime A datetime value indicating when the last report generation run began, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
gfxnorenderclass Class to instantiate in GFX collection for conditionally eliminating baseclass rendering of various layout controls (defaults to gfxNoRender, if empty conditional rendering is turned off).
gfxnorenderclasslib Class library from which to instantiate GFX collection object providing conditional baseclass rendering.
gfxnorendermodule Application module (APP or EXE) from which to instantiate GFX collection object providing conditional baseclass rendering.
*createhelperobjects Creates FXs and GFXs collections, and additional required object members such as the FFCGraphics object.
*needgfxs Hook method to evaluate whether this method needs to call the GFXs collection members for rendering purposes.
*sendfx Applies FXs and GFXs collection members when an event or method is called.  Returns value to indicate how default render behavior should work when invoked during Render event.
*checkcollectionmembers Eliminates members of FXs and GFXs collections in LoadReport and again in BeforeReport if they do not match required interfaces. Verifies availability of appropriate members.
*uppermethodname Passed a string such as PROGRAM(), returns an upper-case version of the method name with prefixes removed.  Utility method for use  when applying FX and GFX instructions.
*cancelrequested_assign 
*fxfeedbackclass_assign 
*fxfeedbackclasslib_assign 
*fxfeedbackmodule_assign 
*getfeedbackfxobject Instantiates FX object to provide user feedback.
*classpath_assign 
*getobjectinstance Provides a method for instancing classes as helper/member objects or FX/GFX collection members using specific path priorities.
*checkcollectionforspecifiedmember Checks FX or GFX collection for instance of specified class by class and (if specified) by class library name. Returns logical (.F. if not found) or object reference (NULL if not found).
*addcollectionmember Adds instance of specified class in specified class library  to FX or GFX collection. Params: tcClass, tcClassLib,tcModule,tlSingleton, tlInGFX, tlRequired
*getpathforexternals Determines the location at which the current configuration table and any other required external files will be expected.
*ffcgraphics_assign 
*getmemberdatascriptfxobject Instantiates FX object to provide memberdata-based script handling.
*fxmemberdatascriptclass_assign 
*fxmemberdatascriptclasslib_assign 
*fxmemberdatascriptmodule_assign 
*frxcursor_access 
*frxcursor_assign 
*loadfrxcursor_assign 
*memberdataalias_assign 
*creatememberdatacursor Creates a cursor in the FRX datasession to hold extended information about FRX data rows.
*runcollectorresetlevel_assign 
*getfrxrecno Determine the current FRX cursor row number from the parameters passed to a ReportListener event.
*getrotategfxobject Instantiates GFX object to provide memberdata-based rotation of layout controls.
*gfxrotateclass_assign 
*gfxrotateclasslib_assign 
*gfxrotatemodule_assign 
*removecollectionmember Provides a way to remove an FX or GFX object from FXListener's collections by object instance name or class name.
*reportstoprundatetime_access 
*reportstartrundatetime_access 
*evaluateuserexpression Attempts to evaluate a user-provided expression in various report run datasessions and return a valid result.
*gfxnorenderclass_assign 
*gfxnorenderclasslib_assign 
*gfxnorendermodule_assign 
*getnorendergfxobject Instantiates GFX object to provide memberdata-specified conditional baseclass rendering.
*ensurecollection Ensures valid object collections for GFXs and FXs member references.
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>ReportListener supplying the means to decorate base report content during a report run, using two member collections: FXs (adjust content and format instructions) and GFXs (adjust or replace GDIPlus-graphics rendering).</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>fxlistener</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_2220SN8V0</uniqueid>
		<timestamp>924994991</timestamp>
		<class>custom</class>
		<classloc/>
		<baseclass>custom</baseclass>
		<objname>gfxoutputclip</objname>
		<parent/>
		<properties>oimagesrc = NULL
oimagedest = NULL
oprivategraphics = NULL
opoint = NULL
orect = NULL
lonthisrun = .F.
iimageinstanceindex = 0
margin = 10
snamespace = ("")
mimetype = ("image/png")
forceon = .F.
gdipluslib = ("")
_memberdata =     2083&lt;VFPData&gt;&lt;memberdata name="forceon" type="property" display="forceOn" favorites="True"/&gt;&lt;memberdata name="gdipluslib" type="property" display="gdiPlusLib" favorites="True"/&gt;&lt;memberdata name="iimageinstanceimage" type="property" display="iImageInstanceimage"/&gt;&lt;memberdata name="mimetype" type="property" display="mimetype" favorites="True"/&gt;&lt;memberdata name="aimagecopies" type="property" display="aImageCopies"/&gt;&lt;memberdata name="iimageinstanceindex" type="property" display="iImageInstanceIndex"/&gt;&lt;memberdata name="margin" type="property" display="margin" favorites="True"/&gt;&lt;memberdata name="lonthisrun" type="property" display="lOnThisRun"/&gt;&lt;memberdata name="lthisruninpagedmode" type="property" display="lThisRunInPagedMode"/&gt;&lt;memberdata name="oimagedest" type="property" display="oImageDest"/&gt;&lt;memberdata name="oimagesrc" type="property" display="oImageSrc"/&gt;&lt;memberdata name="opoint" type="property" display="oPoint"/&gt;&lt;memberdata name="oprivategraphics" type="property" display="oPrivateGraphics"/&gt;&lt;memberdata name="orect" type="property" display="oRect"/&gt;&lt;memberdata name="snamespace" type="property" display="sNamespace"/&gt;&lt;memberdata name="applyfx" type="method" display="applyFX"/&gt;&lt;memberdata name="getcurrentclipfilename" type="method" display="getCurrentClipFileName" favorites="True"/&gt;&lt;memberdata name="outputpageclip" type="method" display="outputPageClip" favorites="True"/&gt;&lt;memberdata name="setupimageclip" type="method" display="setupImageClip" favorites="True"/&gt;&lt;memberdata name="saveimageclips" type="method" display="saveImageClips"/&gt;&lt;memberdata name="getimageext" type="method" display="getImageExt"/&gt;&lt;memberdata name="setup" type="method" display="setup"/&gt;&lt;memberdata name="gdipluslibmodule" type="property" display="gdiPlusLibModule" favorites="True"/&gt;&lt;memberdata name="listenersupportssaveclip" type="method" display="listenerSupportsSaveClip"/&gt;&lt;memberdata name="cleanup" type="method" display="cleanup"/&gt;&lt;memberdata name="simagepath" type="property" display="sImagePath"/&gt;&lt;memberdata name="simagefullpath" type="property" display="sImageFullPath"/&gt;&lt;/VFPData&gt;

gdipluslibmodule = ("")
simagepath = ("")
simagefullpath = ("")
Name = "gfxoutputclip"
</properties>
		<protected>oimagesrc
oimagedest
oprivategraphics
opoint
orect
lonthisrun
iimageinstanceindex
snamespace
simagepath
simagefullpath
aimagecopies
saveimageclips
getimageext
setup
listenersupportssaveclip
cleanup
</protected>
		<methods>PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

LOCAL m.liSession, m.liSelect, m.liFRXRecno, m.lvReturn, ;
m.liDriver, m.err AS EXCEPTION

m.lvReturn = .T.

IF THIS.listenerSupportsSaveClip(m.toListener)

TRY

m.liSession = SET("DATASESSION")

IF m.toListener.FRXDATASESSION &gt; -1

SET DATASESSION TO m.toListener.FRXDATASESSION
m.liSelect = SELECT(0)

DO CASE

CASE m.tcMethodToken == "BEFOREREPORT"

THIS.aImageCopies = .F.
THIS.iImageInstanceIndex = 0
IF USED (m.toListener.MemberDataAlias)
SELECT (m.toListener.MemberDataAlias)
LOCATE FOR ;
NAME == THIS.sNameSpace
THIS.lOnThisRun = (FOUND() OR THIS.forceOn)
IF THIS.lOnThisRun
THIS.Setup(m.toListener)
ENDIF
ENDIF

CASE m.tcMethodToken == "RENDER" AND ;
NOT ISNULL(m.toListener.FFCGraphics) AND ;
THIS.lOnThisRun

m.lvReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR
m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
GO m.liFRXRecNo IN FRX
SELECT (m.toListener.MemberDataAlias)
LOCATE FOR FRXRecno = m.liFRXRecno AND ;
NAME == THIS.sNameSpace
IF FOUND()
THIS.setupImageClip(m.toListener, ;
m.tP2, m.tP3, m.tP4, m.tP5, @m.tP7, ;
(FRX.ObjType = FRX_OBJTYP_PICTURE))
ENDIF

CASE m.tcMethodToken == "AFTERREPORT"

IF THIS.listenerSupportsSaveClip(m.toListener,.F.)
THIS.saveImageClips(m.toListener)
ENDIF
THIS.Cleanup(m.toListener)

ENDCASE

ELSE
THIS.lOnThisRun = .F.
ENDIF

CATCH TO m.err

#IF OUTPUTCLASS_DEBUGGING
SUSPEND
#ENDIF

FINALLY

IF VARTYPE(m.err) = "O"
*&amp;* this object cleans up after an error --
*&amp;* doesn't provide a choice, although it could.
THIS.Cleanup(m.toListener)
ENDIF

IF m.toListener.FRXDataSession # -1
SET DATASESSION TO m.toListener.FrxDataSession
SELECT (m.liSelect)
SET DATASESSION TO (m.liSession)
ENDIF

ENDTRY

ENDIF

RETURN  m.lvReturn




ENDPROC
PROCEDURE cleanup
LPARAMETERS m.toListener

IF THIS.lOnThisRun AND VARTYPE(m.toListener) = "O" AND ;
THIS.listenerSupportsSaveClip(m.toListener,.T.)
UNBINDEVENTS(THIS)
ENDIF

THIS.lOnThisRun = .F.

STORE "" TO ;
THIS.sImagePath, ;
THIS.sImageFullPath

STORE NULL TO  ;
THIS.oImageSrc, ;
THIS.oImageDest, THIS.oPrivateGraphics, ;
THIS.oPoint, THIS.oRect
ENDPROC
PROCEDURE Destroy
THIS.Cleanup()
ENDPROC
PROCEDURE forceon_assign
LPARAMETERS m.tvValue
IF VARTYPE(m.tvValue) = "L"
THIS.forceOn = m.tvValue
ENDIF

ENDPROC
PROCEDURE gdipluslib_assign
LPARAMETERS m.tvValue
IF VARTYPE(m.tvValue) = "C"
m.tvValue = ALLTRIM(m.tvValue)
DO CASE
CASE(EMPTY(m.tvValue) OR FILE(m.tvValue))
THIS.gdiPlusLib = m.tvValue
CASE FILE(FORCEEXT(m.tvValue,"VCX"))
THIS.gdiPlusLib = FORCEEXT(m.tvValue,"VCX")
ENDCASE
ENDIF

ENDPROC
PROCEDURE gdipluslibmodule_assign
LPARAMETERS m.tvValue
IF VARTYPE(m.tvValue) = "C"
m.tvValue = ALLTRIM(m.tvValue)
IF(EMPTY(m.tvValue) OR (NOT EMPTY(SYS(2000,(m.tvValue)))))
THIS.gdiPlusLibModule = m.tvValue
ENDIF
ENDIF


ENDPROC
PROCEDURE getcurrentclipfilename
IF THIS.iImageInstanceIndex = 0 OR ;
EMPTY(THIS.aImageCopies[THIS.iImageInstanceIndex,2])
RETURN ""
ELSE
RETURN THIS.aImageCopies[THIS.iImageInstanceIndex,2]
ENDIF

ENDPROC
PROCEDURE getimageext
*&amp;* override as you see fit.
RETURN SUBSTR(THIS.mimetype,RAT("/",THIS.mimetype) + 1)
ENDPROC
PROCEDURE Init
#DEFINE THISNAMESPACE         "Spacefold.LSN.gfxOutputClip"

*&amp;* An appropriate namespace must be defined for cases in which
*&amp;* you want to use this gfx on its own and share it
*&amp;* by placing it in the GFXs collection.
*&amp;* You can set the outputclip behavior to occur only
*&amp;* after all other rendering is through, and
*&amp;* also ensure availability of the clip files and
*&amp;* clip file names to all Successors, by using this
*&amp;* approach.  Simply add memberdata to the layout elements
*&amp;* you want clipped (no other memberdata property besides
*&amp;* the name attribute is needed by this object).
*&amp;* The layout elements to be clipped
*&amp;* can be of any report control type.

*&amp;* However, this object can be invoked explicitly, even
*&amp;* when shared, by a custom rendering extension
*&amp;* using "ForceOn" behavior, and without
*&amp;* any memberdata instructions in the report.
*&amp;* It is also constructed to be
*&amp;* well-behaved if multiple custom rendering extensions
*&amp;* keeps private copies and invoke them explicitly
*&amp;* rather than putting a shared copy in the GFXs collection.

*&amp;* Now that you have read this note &lt;g&gt;
*&amp;* and if you want this object to work on its
*&amp;* own in the GFXs collection as a shared worker object,
*&amp;* you can :
*&amp;* override the Init in your subclass with
*&amp;* an appropriate namespace value
*&amp;* OR
*&amp;* uncomment the IF/ENDIF below and set
*&amp;* an appropriate default property definition
*&amp;* in your subclass.

*&amp;* IF VARTYPE(THIS.sNamespace) # "C" OR EMPTY(THIS.sNamespace)
THIS.sNameSpace = THISNAMESPACE
*&amp;* ENDIF

ENDPROC
PROCEDURE listenersupportssaveclip
LPARAMETERS m.toListener,m.tlActInPagedMode

DO CASE
CASE m.toListener.ListenerType = LISTENER_TYPE_DEF
RETURN .F.
CASE PCOUNT() &lt; 2
RETURN m.toListener.ListenerType # LISTENER_TYPE_DEF
CASE tlActInPagedMode
RETURN INLIST(m.toListener.ListenerType,LISTENER_TYPE_PRN,LISTENER_TYPE_PAGED)
OTHERWISE
RETURN INLIST(m.toListener.ListenerType,LISTENER_TYPE_PRV,LISTENER_TYPE_ALLPGS)
ENDCASE

ENDPROC
PROCEDURE margin_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) = "N"
THIS.margin = INT(m.tvNewVal)
ENDIF

ENDPROC
PROCEDURE mimetype_assign
LPARAMETERS m.tvValue

IF VARTYPE(m.tvValue) = "C" AND "/" $ m.tvValue
THIS.mimetype = ALLTRIM(m.tvValue)
ENDIF

ENDPROC
PROCEDURE outputpageclip
LPARAMETERS m.nPageNo, ;
m.eDevice, ;
m.nDeviceType, ;
m.nleft, m.nTop, m.nWidth, m.nHeight, ;
m.nClipLeft,m.nClipTop, m.nClipWidth, m.nClipHeight

LOCAL m.laBind[1]
AEVENTS(m.laBind,0)
THIS.saveImageClips(laBind[1],m.nPageNo)


ENDPROC
PROCEDURE saveimageclips
LPARAMETERS m.toListener, m.tiPage

IF NOT THIS.listenerSupportsSaveClip(m.toListener)
RETURN .F.
ENDIF

LOCAL m.lcTempfile, m.liPageIndex, m.liImageIndex, m.liStartPage, m.liEndPage

m.lcTempFile = FORCEEXT(FORCEPATH(SYS(2015),SYS(2023)),"EMF") &amp;&amp; always goes to temp dir

THIS.oPoint.Set(0,0)

IF THIS.listenerSupportsSaveClip(m.toListener, .T.)
m.liStartPage = VAL(TRANSFORM(m.tiPage))
m.liEndPage  = m.liStartPage
UNBINDEVENTS(THIS)
* avoid recursion the easy way.
ELSE
m.liStartPage = 1
m.liEndPage = m.toListener.PageTotal
ENDIF

IF EMPTY(THIS.sImageFullPath)
* should just happen the first time through
* in paged mode
IF PEMSTATUS(m.toListener,"targetFileName",5) AND ;
NOT EMPTY(JUSTPATH(m.toListener.targetFileName))
THIS.sImageFullPath = FULLPATH(THIS.sImagePath,m.toListener.targetFileName)
ELSE
THIS.sImageFullPath = FULLPATH(THIS.sImagePath)
ENDIF
ENDIF


m.liImageIndex = ASCAN(THIS.aImageCopies,m.liStartPage,1,THIS.iImageInstanceIndex,1,8)

IF m.liImageIndex &gt; 0
FOR m.liPageIndex = m.liStartPage TO m.liEndPage
m.toListener.OutputPage(m.liPageIndex,m.lcTempFile,100)
THIS.oImageSrc.CreateFromFile(m.lcTempFile)
DO WHILE m.liImageIndex &lt;= THIS.iImageInstanceIndex
IF THIS.aImageCopies[m.liImageIndex,1] &gt; m.liPageIndex
EXIT
ENDIF
THIS.oImageDest.Create(CEILING(THIS.aImageCopies[m.liImageIndex,5]/10) + ;
THIS.margin,;
CEILING(THIS.aImageCopies[liImageIndex,6]/10) + ;
THIS.margin)
THIS.oPrivateGraphics.CreateFromImage(THIS.oImageDest)
THIS.oRect.Set(FLOOR(THIS.aImageCopies[m.liImageIndex,3]/10) ,;
FLOOR(THIS.aImageCopies[m.liImageIndex,4]/10) ,;
CEILING(THIS.aImageCopies[m.liImageIndex,5]/10  + ;
THIS.margin),;
CEILING(THIS.aImageCopies[liImageIndex,6]/10) + ;
THIS.margin)
THIS.oPrivateGraphics.DrawImagePortionAt(;
THIS.oImageSrc, THIS.oPoint, THIS.oRect, 2)
THIS.oImageDest.SaveToFile(FORCEPATH(THIS.aImageCopies[m.liImageIndex,2], ;
THIS.sImageFullPath), ;
THIS.mimetype)
m.liImageIndex = m.liImageIndex + 1
ENDDO
NEXT
ERASE (m.lcTempFile)
ENDIF

IF THIS.listenerSupportsSaveClip(m.toListener,.T.)
BINDEVENT(m.toListener,"OutputPage",THIS,"outputPageClip")
ENDIF

ENDPROC
PROCEDURE setup
LPARAMETERS m.toListener

IF VARTYPE(m.toListener) # "O"
THIS.lOnThisRun = .F.
* early quit
ENDIF

IF THIS.lOnThisRun
IF EMPTY(THIS.gdiPlusLib) OR ;
NOT FILE(THIS.gdiPlusLib)
IF ISNULL(m.toListener.FFCGraphics)
THIS.lOnThisRun = .F.
ELSE
THIS.gdiPlusLib = m.toListener.FFCGraphics.ClassLibrary
ENDIF
ENDIF
* test:
LOCAL loTemp
TRY
loTemp = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
CATCH WHEN .T.
THIS.gdiPlusLib = "_gdiplus.vcx"
IF FILE(THIS.gdiPlusLib)
THIS.gdiPlusLib = ""
ELSE
THIS.gdiPlusLib = _REPORTOUTPUT
ENDIF
* one more try
TRY
loTemp = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
CATCH WHEN .T.
loTemp = NULL
ENDTRY
FINALLY
IF VARTYPE(loTemp) # "O"
THIS.lOnThisRun = .F.
ENDIF
loTemp = NULL
ENDTRY
ENDIF

IF THIS.lOnThisRun
IF PEMSTATUS(m.toListener,"externalFileLocation",5) AND ;
(NOT EMPTY(m.toListener.externalFileLocation))
THIS.sImagePath = ADDBS(m.toListener.externalFileLocation)
ELSE
STORE SYS(2023) TO THIS.sImagePath, THIS.sImageFullPath
ENDIF
IF THIS.listenerSupportsSaveClip(m.toListener,.T.)
* page-at-a-time mode
* bind to outputpage event
BINDEVENT(m.toListener,"OutputPage",THIS,"outputPageClip")
ENDIF
IF VARTYPE(THIS.oImageSrc) # "O"
THIS.oImageSrc = NEWOBJECT("gpBitMap",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
ENDIF
IF VARTYPE(THIS.oImageDest) # "O"
THIS.oImageDest = NEWOBJECT("gpBitMap",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
ENDIF
IF VARTYPE(THIS.oPoint) # "O"
THIS.oPoint = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
ENDIF
IF VARTYPE(THIS.oRect) # "O"
THIS.oRect = NEWOBJECT("gpRectangle",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
ENDIF
IF VARTYPE(THIS.oPrivateGraphics) # "O"
THIS.oPrivateGraphics = NEWOBJECT("gpGraphics",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
ENDIF
ENDIF

ENDPROC
PROCEDURE setupimageclip
LPARAMETERS m.toListener, ;
m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, ;
m.tvContentsToBeRendered, m.tlImageControl

LOCAL m.lcFileName

THIS.iImageInstanceIndex = THIS.iImageInstanceIndex + 1

DIME THIS.aImageCopies[THIS.iImageInstanceIndex,6]

* create a file name based on THIS.Name and THIS.iImageInstanceIndex
* unless the name of the object is the name of the class, which
* may happen if it is a privately-owned object

IF UPPER(THIS.Name) == UPPER(THIS.Class)
m.lcFileName = "C"+SYS(2015)
ELSE
m.lcFileName = THIS.Name
ENDIF

m.lcFileName = FORCEPATH(FORCEEXT(;
m.lcFileName + "_"+TRANSFORM(THIS.iImageInstanceIndex), ;
THIS.getImageExt()),THIS.sImagePath)

IF m.tlImageControl
m.tvContentsToBeRendered = m.lcFileName
ELSE
#IF OUTPUTCLASS_DEBUGGING
m.tvContentsToBeRendered = STRCONV(m.lcFileName,STRCONV_DBCS_UNICODE)
#ENDIF
ENDIF

THIS.aImageCopies[THIS.iImageInstanceIndex,1] = m.toListener.PageNo
THIS.aImageCopies[THIS.iImageInstanceIndex,2] = m.lcFileName
THIS.aImageCopies[THIS.iImageInstanceIndex,3] = m.tnLeft
THIS.aImageCopies[THIS.iImageInstanceIndex,4] = m.tnTop
THIS.aImageCopies[THIS.iImageInstanceIndex,5] = m.tnWidth
THIS.aImageCopies[THIS.iImageInstanceIndex,6] = m.tnHeight
ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>oimagesrc Helper object for image-copy process.
oimagedest Helper object for image-copy process.
oprivategraphics Helper object for image-copy process.
opoint Helper object for image-copy process.
orect Helper object for image-copy process.
lonthisrun Logical value determining whether the object should take action during this run.
iimageinstanceindex Index of the current image copy file.
margin Integer value of frame margin to add to both width and height when determining the clip coordinates for the current portion of the page to be copied.
snamespace Reporting Memberdata namespace for which the object will look when determining whether a layout control's page region has been  explicitly tagged for copy to an image file.
mimetype Mimetype to use for image-copy files the object creates.
forceon Require this object to turn itself on for a report run, even if it does not see any objects tagged for its attention with the Memberdata values it expects. 
gdipluslib Class library to use for instantation of point, rect, and other helper objects.
_memberdata XML Metadata for customizable properties
gdipluslibmodule Optional APP or EXE file (module) from which to instantiate helper objects in the gdiPlusLib class library.
simagepath Potentially relative path to which image copy files are saved, determined by ReportListener's externalFileLocation property (which may be relative) if it exists and is in use.
simagefullpath Full path to which image copy files are saved, determined by ReportListener's externalFileLocation and targetFileName properties if they exist and are in use.
^aimagecopies[1,6] Collection of values about each image copy the object makes during a report run (each row contains PageNo, output filename, and Left,Top,Width,Height values for the copy).
*gdipluslib_assign 
*mimetype_assign 
*forceon_assign 
*applyfx Implementation of required method for the FX interface.
*getcurrentclipfilename Provides generated output image copy filename for the current copy action.
*outputpageclip Bindable procedure to save image copy files at the correct moment (the OutputPage event) during a paged report run.
*setupimageclip Saves a row to the aImageCopies array during rendering procedures when a page region is marked for an image copy, for later use in image copy procedures.
*saveimageclips Performs image copy procedures on the page regions requested for one or more pages.
*getimageext Derive file extension from current mimetype value.
*setup Setup code for each report run specific to this object.
*gdipluslibmodule_assign 
*listenersupportssaveclip Evaluates whether the object can handle image copy processing in the current ReportListener output mode and during the current ReportListener event.
*cleanup Cleanup code for each report run specific to this object.
*margin_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides copy-to-image file for designated page regions during a report run, so you can export the rendered regions for embedding in output targets. Alternative to xmlDisplayListener.copyImageFilesToExternalFileLocation handling custom-rendered content.</reserved7>
		<reserved8>reportlisteners.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>gfxoutputclip</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
</VFPData>
