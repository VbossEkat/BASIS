<?xml version = "1.0" encoding="UTF-8" standalone="yes"?>
<VFPData>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>Class</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname/>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>VERSION =   3.00</reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IG0VJ7IY</uniqueid>
		<timestamp>883122908</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>specialdirectories</objname>
		<parent/>
		<properties>desktop = 
favorites = 
mydocuments = 
nethood = 
printhood = 
programs = 
startmenu = 
temp = 
owsh = .NULL.
_memberdata =     2130&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="desktop" type="property" display="Desktop"/&gt;
&lt;memberdata name="desktop_access" type="property" display="Desktop_Access"/&gt;
&lt;memberdata name="desktop_assign" type="property" display="Desktop_Assign"/&gt;
&lt;memberdata name="favorites" type="property" display="Favorites"/&gt;
&lt;memberdata name="favorites_access" type="property" display="Favorites_Access"/&gt;
&lt;memberdata name="favorites_assign" type="property" display="Favorites_Assign"/&gt;
&lt;memberdata name="mydocuments" type="property" display="MyDocuments"/&gt;
&lt;memberdata name="mydocuments_access" type="property" display="MyDocuments_Access"/&gt;
&lt;memberdata name="mydocuments_assign" type="property" display="MyDocuments_Assign"/&gt;
&lt;memberdata name="nethood" type="property" display="NetHood"/&gt;
&lt;memberdata name="nethood_access" type="property" display="NetHood_Access"/&gt;
&lt;memberdata name="nethood_assign" type="property" display="NetHood_Assign"/&gt;
&lt;memberdata name="printhood" type="property" display="PrintHood"/&gt;
&lt;memberdata name="printhood_access" type="property" display="PrintHood_Access"/&gt;
&lt;memberdata name="printhood_assign" type="property" display="PrintHood_Assign"/&gt;
&lt;memberdata name="programs" type="property" display="Programs"/&gt;
&lt;memberdata name="programs_access" type="property" display="Programs_Access"/&gt;
&lt;memberdata name="programs_assign" type="property" display="Programs_Assign"/&gt;
&lt;memberdata name="startmenu" type="property" display="StartMenu"/&gt;
&lt;memberdata name="startmenu_access" type="property" display="StartMenu_Access"/&gt;
&lt;memberdata name="startmenu_assign" type="property" display="StartMenu_Assign"/&gt;
&lt;memberdata name="temp" type="property" display="Temp"/&gt;
&lt;memberdata name="temp_access" type="property" display="Temp_Access"/&gt;
&lt;memberdata name="temp_assign" type="property" display="Temp_Assign"/&gt;
&lt;memberdata name="owsh" type="property" display="oWSH"/&gt;
&lt;/VFPData&gt;

cnamespace = My.Computer.FileSystem.SpecialFolders
Name = "specialfolders"
</properties>
		<protected>owsh
</protected>
		<methods>PROCEDURE desktop_access
with This
	if empty(.Desktop)
		.Desktop = .oWSH.SpecialFolders('Desktop')
	endif empty(.Desktop)
endwith
return This.Desktop

ENDPROC
PROCEDURE desktop_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.Desktop = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'Desktop'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE Destroy
* Nuke member objects and clear API functions we declared.

This.oWSH = .NULL.
clear dlls GetLongPathName

ENDPROC
PROCEDURE favorites_access
with This
	if empty(.Favorites)
		.Favorites = .oWSH.SpecialFolders('Favorites')
	endif empty(.Favorites)
endwith
return This.Favorites

ENDPROC
PROCEDURE favorites_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.Favorites = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'Favorites'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE Init
* Create instances of the Windows Script Host and File System Object.

This.oWSH = createobject('WScript.Shell')
dodefault()

ENDPROC
PROCEDURE mydocuments_access
with This
	if empty(.MyDocuments)
		.MyDocuments = .oWSH.SpecialFolders('MyDocuments')
	endif empty(.MyDocuments)
endwith
return This.MyDocuments

ENDPROC
PROCEDURE mydocuments_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.MyDocuments = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'MyDocuments'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE nethood_access
with This
	if empty(.NetHood)
		.NetHood = .oWSH.SpecialFolders('NetHood')
	endif empty(.NetHood)
endwith
return This.NetHood

ENDPROC
PROCEDURE nethood_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.NetHood = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'NetHood'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE printhood_access
with This
	if empty(.PrintHood)
		.PrintHood = .oWSH.SpecialFolders('PrintHood')
	endif empty(.PrintHood)
endwith
return This.PrintHood

ENDPROC
PROCEDURE printhood_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.PrintHood = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'PrintHood'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE programs_access
with This
	if empty(.Programs)
		.Programs = .oWSH.SpecialFolders('Programs')
	endif empty(.Programs)
endwith
return This.Programs

ENDPROC
PROCEDURE programs_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.Programs = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'Programs'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE startmenu_access
with This
	if empty(.StartMenu)
		.StartMenu = .oWSH.SpecialFolders('StartMenu')
	endif empty(.StartMenu)
endwith
return This.StartMenu

ENDPROC
PROCEDURE startmenu_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.StartMenu = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'StartMenu'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE temp_access
local lcPath, ;
	lnLength, ;
	lcBuffer
with This
	if empty(.Temp)
		declare integer GetLongPathName in Win32API ;
			string @lpszShortPath, string @lpszLongPath, integer cchBuffer
		lcPath   = sys(2023) + ccNULL
		lnLength = 260
		lcBuffer = space(lnLength)
		GetLongPathName(@lcPath, @lcBuffer, lnLength)
		.Temp = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
	endif empty(.Temp)
endwith
return This.Temp

ENDPROC
PROCEDURE temp_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.Temp = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'Temp'
endif This.CalledFromThisClass()

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>desktop The current user's Desktop folder
favorites The current user's Favorites folder
mydocuments The current user's MyDocuments folder
nethood The current user's Network Neighbourhood folder
printhood The current user's Printer Neighbourhood folder
programs The current user's Programs folder
startmenu The current user's StartMenu folder
temp The current user's temporary folder
owsh A reference to a Windows Scripting Host object
*desktop_access 
*desktop_assign 
*favorites_access 
*favorites_assign 
*mydocuments_access 
*mydocuments_assign 
*nethood_access 
*nethood_assign 
*printhood_access 
*printhood_assign 
*programs_access 
*programs_assign 
*startmenu_access 
*startmenu_assign 
*temp_access 
*temp_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides the paths to "special" Windows folders for the current user</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>specialdirectories</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18MLEK</uniqueid>
		<timestamp>883510533</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>network</objname>
		<parent/>
		<properties>owsh = .NULL.
cnamespace = My.Computer.Network
_memberdata =      577&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="mapnetworkdrive" type="method" display="MapNetworkDrive"/&gt;
&lt;memberdata name="downloadfile" type="method" display="DownloadFile"/&gt;
&lt;memberdata name="owsh" type="property" display="oWSH"/&gt;
&lt;memberdata name="removenetworkdrive" type="method" display="RemoveNetworkDrive"/&gt;
&lt;/VFPData&gt;

Name = "network"
</properties>
		<protected>owsh
</protected>
		<methods>PROCEDURE Destroy
* Remove any API functions we declared and nuke all memebers.

clear dlls URLDownloadToFile
This.oWSH = .NULL.
dodefault()

ENDPROC
PROCEDURE downloadfile
* Download the specified file over the Internet.

lparameters URL as String, ;
	Destination as String
local lnResult
if vartype(URL) &lt;&gt; 'C' or empty(URL) or ;
	vartype(Destination) &lt;&gt; 'C' or empty(Destination)
	error cnERR_ARGUMENT_INVALID
	lnResult = -1
else
	declare long URLDownloadToFile in URLMON.DLL long, string, string, long, ;
		long
	lnResult = URLDownloadToFile(0, URL, Destination, 0, 0)
endif vartype(URL) &lt;&gt; 'C' ...
return lnResult

ENDPROC
PROCEDURE Init
* Create an instance of the Windows Script Host.

This.oWSH = createobject('WScript.Network')

ENDPROC
PROCEDURE mapnetworkdrive
* Map the specified UNC path to the specified drive.

lparameters DriveLetter as String, ;
	UNCPath as String, ;
	ReconnectAtLogon as Logical, ;
	UserName as String, ;
	Password as String
local lnResult
do case
	case vartype(DriveLetter) &lt;&gt; 'C' or len(DriveLetter) &lt;&gt; 2 or ;
		not isalpha(left(DriveLetter, 1)) or right(DriveLetter, 1) &lt;&gt; ':' or ;
		vartype(UNCPath) &lt;&gt; 'C' or empty(UNCPath) or ;
		(pcount() &gt;= 3 and vartype(ReconnectAtLogon) &lt;&gt; 'L') or ;
		(pcount() &gt;= 4 and (vartype(UserName) &lt;&gt; 'C' or empty(UserName))) or ;
		(pcount() = 5 and (vartype(Password) &lt;&gt; 'C' or empty(Password)))
		error cnERR_ARGUMENT_INVALID
	case pcount() &gt; 3
		lnResult = This.oWSH.MapNetworkDrive(DriveLetter, UNCPath, ;
			ReconnectAtLogon, UserName, Password)
	otherwise
		lnResult = This.oWSH.MapNetworkDrive(DriveLetter, UNCPath, ;
			ReconnectAtLogon)
endcase
return lnResult

ENDPROC
PROCEDURE removenetworkdrive
* Map the specified UNC path to the specified drive.

lparameters DriveLetter as String, ;
	Force as Logical, ;
	UpdateUserProfile as Logical
local lnResult
if vartype(DriveLetter) &lt;&gt; 'C' or vartype(Force) &lt;&gt; 'L' or ;
	vartype(UpdateUserProfile) &lt;&gt; 'L'
	error cnERR_ARGUMENT_INVALID
else
	lnResult = This.oWSH.RemoveNetworkDrive(DriveLetter, Force, ;
		UpdateUserProfile)
endif vartype(DriveLetter) &lt;&gt; 'C' ...
return lnResult

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>owsh A reference to the Windows Script Host object
*mapnetworkdrive Maps to a network drive
*downloadfile Downloads the specified file to the specified location
*removenetworkdrive Removes a mapping for a network drive
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides properties and methods dealing with networks</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>network</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18LOV5</uniqueid>
		<timestamp>883513001</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>registry</objname>
		<parent/>
		<properties>ccurrentkey = 
ncurrentkey = 0
ncurrentmainkey = 0
nmainkey = 0
cnamespace = My.Computer.Registry
_memberdata =     1180&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="closekey" type="method" display="CloseKey"/&gt;
&lt;memberdata name="deletekey" type="method" display="DeleteKey"/&gt;
&lt;memberdata name="deletekeyvalue" type="method" display="DeleteKeyValue"/&gt;
&lt;memberdata name="getkey" type="method" display="GetKey"/&gt;
&lt;memberdata name="getvalue" type="method" display="GetValue"/&gt;
&lt;memberdata name="openkey" type="method" display="OpenKey"/&gt;
&lt;memberdata name="setvalue" type="method" display="SetValue"/&gt;
&lt;memberdata name="ccurrentkey" type="property" display="cCurrentKey"/&gt;
&lt;memberdata name="ncurrentkey" type="property" display="nCurrentKey"/&gt;
&lt;memberdata name="ncurrentmainkey" type="property" display="nCurrentMainKey"/&gt;
&lt;memberdata name="nmainkey" type="property" display="nMainKey"/&gt;
&lt;memberdata name="enumeratekeys" type="method" display="EnumerateKeys"/&gt;
&lt;memberdata name="enumeratekeyvalues" type="method" display="EnumerateKeyValues"/&gt;
&lt;/VFPData&gt;

Name = "registry"
</properties>
		<protected>ccurrentkey
ncurrentkey
ncurrentmainkey
nmainkey
closekey
getkey
openkey
</protected>
		<methods>PROCEDURE closekey
* Close the current key and blank the current key value.

with This
	RegCloseKey(.nCurrentKey)
	.nCurrentKey = 0
endwith

ENDPROC
PROCEDURE deletekey
* Delete the specified key and all subkeys and values under it.

lparameters Key as String
local lcCurrentKey, ;
	loKeys, ;
	llReturn, ;
	lcKey, ;
	lnResult
with This

* Get the key and hive to use, then get a collection of subkeys and delete
* each one by calling ourselves recursively. Then delete the key and return .T.
* if it succeeded.

	if .GetKey(Key)
		lcCurrentKey = .cCurrentKey
		loKeys       = .EnumerateKeys(Key)
		llReturn     = .T.
		for each lcKey in loKeys
			lcKey    = addbs(Key) + lcKey
			llReturn = .DeleteKey(lcKey)
			if not llReturn
				exit
			endif not llReturn
		next lcKey
		.cCurrentKey = lcCurrentKey
		if llReturn
			lnResult = RegDeleteKey(.nCurrentMainKey, .cCurrentKey)
			llReturn = lnResult = cnSUCCESS
		endif llReturn

* Give an error if the key wasn't specified properly.

	else
		error cnERR_ARGUMENT_INVALID
	endif .GetKey(Key)
endwith
return llReturn

ENDPROC
PROCEDURE deletekeyvalue
* Delete the specified value in the specified key.

lparameters Key as String, ;
	ValueName as String
local lnResult, ;
	llReturn
with This

* Give an error if the value name wasn't specified.

	do case
		case vartype(ValueName) &lt;&gt; 'C' or empty(ValueName)
			error cnERR_ARGUMENT_INVALID

* Get the key and hive to use. If we succeeded, try to open the registry key.
* If we could, delete the specified value name.

		case .GetKey(Key)
			if .OpenKey(.cCurrentKey, .nCurrentMainKey)
				lnResult = RegDeleteValue(.nCurrentKey, ValueName)
				llReturn = lnResult = cnSUCCESS
				.CloseKey()
			endif .OpenKey(.cCurrentKey, .nCurrentMainKey)

* Give an error if the key wasn't specified properly.

		otherwise
			error cnERR_ARGUMENT_INVALID
	endcase
endwith
return llReturn

ENDPROC
PROCEDURE Destroy
* Remove any API functions we declared.

clear dlls RegOpenKey, RegCreateKey, RegDeleteKey, RegCloseKey, ;
	RegSetValueEx, RegQueryValueEx, RegDeleteValue, RegEnumKeyEx, RegEnumValue
dodefault()

ENDPROC
PROCEDURE enumeratekeys
lparameters Key as String
local loKeys as Collection, ;
	lnNames, ;
	lnResult, ;
	lcKey, ;
	lnSize, ;
	lcBuffer1, ;
	lnSize1, ;
	lcBuffer2
with This

* Instantiate a collection to return.

	loKeys = createobject('Collection')

* Get the key and hive to use.

	if .GetKey(Key)

* Try to open the registry key. If we couldn't, return an empty collection.

		if .OpenKey(.cCurrentKey, .nCurrentMainKey)

* Initialize the number of names and the result code.

			lnNames  = 0
			lnResult = cnSUCCESS

* As long as everything is OK, keep getting key names.

			do while lnResult = cnSUCCESS

* Create buffers to hold return values from the Registry function.

				lcKey     = space(cnBUFFER_SIZE)
				lnSize    = cnBUFFER_SIZE
				lcBuffer1 = space(cnBUFFER_SIZE)
				lnSize1   = cnBUFFER_SIZE
				lcBuffer2 = space(cnBUFFER_SIZE)

* Get the next key name from the Registry.

				lnResult = RegEnumKeyEx(.nCurrentKey, lnNames, @lcKey, ;
					@lnSize, cnRESERVED, @lcBuffer1, @lnSize1, @lcBuffer2)

* If we got a name, add it to the collection.

				if lnResult = cnSUCCESS
					lcKey   = alltrim(lcKey)
					lcKey   = left(lcKey, len(lcKey) - 1)
					lnNames = lnNames + 1
					loKeys.Add(lcKey)
				endif lnResult = cnSUCCESS
			enddo while lnResult = cnSUCCESS

* Close the registry key.

			.CloseKey()
		endif .OpenKey(.cCurrentKey, .nCurrentMainKey)

* Give an error if the key wasn't specified properly.

	else
		error cnERR_ARGUMENT_INVALID
	endif .GetKey(tcKey)
endwith
return loKeys

ENDPROC
PROCEDURE enumeratekeyvalues
lparameters Key as String
local loValues as Collection, ;
	lnValues, ;
	lnResult, ;
	lcKey, ;
	lnKeySize, ;
	lcValue, ;
	lnValSize, ;
	lnType, ;
	luValue
with This

* Instantiate a collection to return.

	loValues = createobject('Collection')

* Get the key and hive to use.

	if .GetKey(Key)

* Try to open the registry key. If we couldn't, return an empty collection.

		if .OpenKey(.cCurrentKey, .nCurrentMainKey)

* Initialize the number of names and the result code.

			lnValues = 0
			lnResult = cnSUCCESS

* As long as everything is OK, keep getting key names.

			do while lnResult = cnSUCCESS

* Create buffers to hold return values from the Registry function.

				lcKey     = space(cnBUFFER_SIZE)
				lnKeySize = cnBUFFER_SIZE
				lcValue   = space(cnBUFFER_SIZE)
				lnValSize = cnBUFFER_SIZE
				lnType    = 0

* Get the next key name from the Registry.

				lnResult = RegEnumValue(.nCurrentKey, lnValues, @lcKey, ;
					@lnKeySize, cnRESERVED, @lnType, @lcValue, @lnValSize)

* If we got a name, add it to the collection.

				if lnResult = cnSUCCESS
					lcKey    = left(lcKey, lnKeySize)
					lnValues = lnValues + 1
					do case
						case lnType = cnREG_SZ
							luValue = left(lcValue, lnValSize - 1)
						case lpdwType = cnREG_DWORD
							luValue = ctobin(left(lcValue, 4), 'RS')
						otherwise
							luValue = ''
					endcase
					loValues.Add(luValue, lcKey)
				endif lnResult = cnSUCCESS
			enddo while lnResult = cnSUCCESS

* Close the registry key.

			.CloseKey()
		endif .OpenKey(.cCurrentKey, .nCurrentMainKey)

* Give an error if the key wasn't specified properly.

	else
		error cnERR_ARGUMENT_INVALID
	endif .GetKey(tcKey)
endwith
return loValues

ENDPROC
PROCEDURE getkey
lparameters tcKey
local llReturn, ;
	lnPos, ;
	lcMainKey
with This

* Ensure the key was specified.

	llReturn = .T.
	do case
		case vartype(tcKey) &lt;&gt; 'C' or empty(tcKey)
			llReturn = .F.

* If the hive was included in the key, get it. Otherwise, use the default
* value.

		case upper(left(tcKey, 5)) = 'HKEY_'
			lnPos     = at('\', tcKey)
			lcMainKey = upper(left(tcKey, lnPos - 1))
			do case
				case lcMainKey = 'HKEY_CLASSES_ROOT'
					.nCurrentMainKey = cnHKEY_CLASSES_ROOT
				case lcMainKey = 'HKEY_CURRENT_USER'
					.nCurrentMainKey = cnHKEY_CURRENT_USER
				case lcMainKey = 'HKEY_LOCAL_MACHINE'
					.nCurrentMainKey = cnHKEY_LOCAL_MACHINE
				case lcMainKey = 'HKEY_USERS'
					.nCurrentMainKey = cnHKEY_USERS
				otherwise
					llReturn = .F.
			endcase
			.cCurrentKey = substr(tcKey, lnPos + 1)
		otherwise
			.nCurrentMainKey = .nMainKey
			.cCurrentKey     = tcKey
	endcase

* Strip any trailing backslash off the key (Windows 95/98 won't accept a
* trailing backslash).

	if llReturn
		.cCurrentKey = iif(right(.cCurrentKey, 1) = '\', ;
			left(.cCurrentKey, len(.cCurrentKey) - 1), .cCurrentKey)
	endif llReturn
endwith
return llReturn

ENDPROC
PROCEDURE getvalue
lparameters Key as String, ;
	ValueName as String, ;
	DefaultValue as Variant
local luValue, ;
	lcValueName, ;
	lcBuffer, ;
	lnSize, ;
	lnType, ;
	lnResult
with This

* Get the key and hive to use.

	if .GetKey(Key)

* If the default to use wasn't passed, initialize it to an empty string.

		luValue = iif(vartype(DefaultValue) = 'C', DefaultValue, '')

* If the value name wasn't specified, initialize it to an empty string.

		lcValueName = iif(pcount() = 1, '', ValueName)

* Try to open the registry key. If we couldn't, return the default value.

		if .OpenKey(.cCurrentKey, .nCurrentMainKey)

* Create a buffer to hold the key value.

			lcBuffer = space(cnBUFFER_SIZE)
			lnSize   = cnBUFFER_SIZE
			lnType   = 0

* Set the key value. Make sure we have a data string data type.

			lnResult = RegQueryValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
				@lnType, @lcBuffer, @lnSize)
			if lnResult = cnSUCCESS and lnType = cnREG_SZ
				luValue = left(lcBuffer, lnSize - 1)
			endif lnResult ...

* Close the registry key and return the value.

			.CloseKey()
		endif .OpenKey(.cCurrentKey, .nCurrentMainKey)

* Give an error if the key wasn't specified properly.

	else
		error cnERR_ARGUMENT_INVALID
		luValue = .NULL.
	endif .GetKey(tcKey)
endwith
return luValue

ENDPROC
PROCEDURE Init
* Declare the API functions we'll need.

declare integer RegOpenKey in Win32API ;
	integer nKey, string @cSubKey, integer @nHandle
declare integer RegCreateKey in Win32API ;
	integer nKey, string @cSubKey, integer @nHandle
declare integer RegDeleteKey in Win32API ;
	integer nKey, string @cSubKey
declare integer RegCloseKey in Win32API ;
	integer nKey
declare integer RegSetValueEx in Win32API ;
	integer nKey, string cValueName, integer nReserved, ;
	integer nType, string cBuffer, integer nBufferSize
declare integer RegQueryValueEx in Win32API ;
	integer nKey, string cValueName, integer nReserved, ;
	integer @nType, string @cBuffer, integer @nBufferSize
declare integer RegDeleteValue in Win32API ;
	integer nKey, string cSubKey
declare integer RegEnumKeyEx in Win32API ;
	integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize,;
	integer nReserved, string @cBuffer, integer @nBufferSize, string @cBuffer
declare integer RegEnumValue IN Win32API ;
	integer nKey, integer nValue, string @cSubKey, ;
	integer @nKeySize, integer nReserved, integer @nType, ;
	string @cValue, integer @nValSize

* Initialize the main key to the default HKEY_CURRENT_USER.

This.nMainKey = cnHKEY_CURRENT_USER

* Carry on with the base behavior.

dodefault()

ENDPROC
PROCEDURE openkey
lparameters tcSubKey, ;
	tnMainKey, ;
	tlCreate
local lnHandle, ;
	lcSubKey, ;
	lnResult, ;
	llReturn

* Try to create or open the registry key. If it succeeded, store the key handle
* in the nCurrentKey property; if not, zero nCurrentKey.

with This
	lnHandle = 0

* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
* backslash but Windows 95/98 do not).

	lcSubKey = iif(right(tcSubKey, 1) = '\', ;
		left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
	if tlCreate
		lnResult = RegCreateKey(tnMainKey, lcSubKey, @lnHandle)
	else
		lnResult = RegOpenKey(tnMainKey, lcSubKey, @lnHandle)
	endif tlCreate
	llReturn     = lnResult = cnSUCCESS
	.nCurrentKey = iif(llReturn, lnHandle, 0)
endwith
return llReturn

ENDPROC
PROCEDURE setvalue
lparameters Key as String, ;
	ValueName as String, ;
	Value as Variant
local lcType, ;
	lcValue, ;
	lnSize, ;
	lcValueName, ;
	lnResult, ;
	llReturn
with This

* Get the key and hive to use.

	if .GetKey(Key)

* Convert the value to a string if necessary. Terminate the string with a null
* and calculate the size.

		lcType = vartype(Value)
		do case
			case lcType = 'C'
				lcValue = Value
			case lcType $ 'NIFYB'
				lcValue = transform(Value)
			case lcType = 'D'
				lcValue = dtoc(Value)
			case lcType = 'T'
				lcValue = ttoc(Value)
			case lcType = 'L'
				lcValue = iif(Value, 'Y', 'N')
		endcase
		lcValue = lcValue + ccNULL
		lnSize  = len(lcValue)

* If the value name wasn't specified, initialize it to an empty string.

		lcValueName = iif(vartype(ValueName) = 'C', ValueName, '')

* Try to open or create the registry key. If we couldn't, return .F.

		if .OpenKey(.cCurrentKey, .nCurrentMainKey, .T.)

* Set the key value.

			lnResult = RegSetValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
				cnREG_SZ, lcValue, lnSize)
			llReturn = lnResult = cnSUCCESS

* Close the registry key and return the success flag.

			.CloseKey()
		endif .OpenKey(.cCurrentKey, .nCurrentMainKey, .T.)

* Give an error if the key wasn't specified properly.

	else
		error cnERR_ARGUMENT_INVALID
	endif .GetKey(Key)
endwith
return llReturn

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>ccurrentkey The key to use for the current access
ncurrentkey The current open key handle
ncurrentmainkey The current hive being accessed
nmainkey The default hive being accessed
*closekey Closes the current registry key
*deletekey Deletes the specified key
*deletekeyvalue Deletes the specified value from the specified key
*getkey Gets the hive and key from the specified key
*getvalue Gets the specified value from the specified key
*openkey Opens the specified key
*setvalue Sets the specified value in the specified registry key
*enumeratekeys Returns a collection of keys in the specified key
*enumeratekeyvalues Returns a collection of keys and values in the specified key
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides access to the Windows Registry</reserved7>
		<reserved8>myregistry.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>registry</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18M4ZG</uniqueid>
		<timestamp>883588256</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>filesystem</objname>
		<parent/>
		<properties>ofso = .NULL.
owsh = .NULL.
drives = .NULL.
cnamespace = My.Computer.FileSystem
_memberdata =     1189&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="copyfile" type="method" display="CopyFile"/&gt;
&lt;memberdata name="copydirectory" type="method" display="CopyDirectory"/&gt;
&lt;memberdata name="getdriveinfo" type="method" display="GetDriveInfo"/&gt;
&lt;memberdata name="getfileinfo" type="method" display="GetFileInfo"/&gt;
&lt;memberdata name="getdirectoryinfo" type="method" display="GetDirectoryInfo"/&gt;
&lt;memberdata name="ofso" type="method" display="oFSO"/&gt;
&lt;memberdata name="owsh" type="method" display="oWSH"/&gt;
&lt;memberdata name="getlongfilename" type="method" display="GetLongFileName"/&gt;
&lt;memberdata name="getshortfilename" type="method" display="GetShortFileName"/&gt;
&lt;memberdata name="movefile" type="method" display="MoveFile"/&gt;
&lt;memberdata name="movedirectory" type="method" display="MoveDirectory"/&gt;
&lt;memberdata name="drives" type="property" display="Drives"/&gt;
&lt;memberdata name="drives_access" type="method" display="Drives_Access"/&gt;
&lt;memberdata name="drives_assign" type="method" display="Drives_Assign"/&gt;
&lt;/VFPData&gt;
Name = "filesystem"
</properties>
		<protected>ofso
owsh
</protected>
		<methods>PROCEDURE copydirectory
* Copy the contents of the specified folder.

lparameters SourceFolder as String, ;
	DestinationFolder as String, ;
	Overwrite as Logical
local llReturn
do case
	case vartype(SourceFolder) &lt;&gt; 'C' or empty(SourceFolder) or ;
		vartype(DestinationFolder) &lt;&gt; 'C' or empty(DestinationFolder)
		error cnERR_ARGUMENT_INVALID
	case not directory(SourceFolder)
		error cnERR_FILE_NOT_FOUND
	otherwise
		This.oFSO.CopyFolder(SourceFolder, DestinationFolder, Overwrite)
		llReturn = directory(DestinationFolder)
endcase
return llReturn

ENDPROC
PROCEDURE copyfile
* Copy the specified file.

lparameters SourceFile as String, ;
	DestinationFile as String, ;
	Overwrite as Logical
local llReturn
do case
	case vartype(SourceFile) &lt;&gt; 'C' or empty(SourceFile) or ;
		vartype(DestinationFile) &lt;&gt; 'C' or empty(DestinationFile)
		error cnERR_ARGUMENT_INVALID
	case not file(SourceFile)
		error cnERR_FILE_NOT_FOUND
	otherwise
		This.oFSO.CopyFile(SourceFile, DestinationFile, Overwrite)
		llReturn = file(DestinationFile)
endcase
return llReturn

ENDPROC
PROCEDURE Destroy
* Nuke member objects and clear API functions we declared.

This.oWSH = .NULL.
This.oFSO = .NULL.
clear dlls GetLongPathName, GetShortPathName

ENDPROC
PROCEDURE drives_access
return This.oFSO.Drives

ENDPROC
PROCEDURE drives_assign
* Trow a "property is read-only" error.

lparameters tuValue
error cnERR_PROPERTY_READ_ONLY, 'Drives'

ENDPROC
PROCEDURE getdirectoryinfo
* Return a Folder object for the specified folder.

lparameters FolderName as String
local luReturn
luReturn = .NULL.
do case
	case vartype(FolderName) &lt;&gt; 'C' or empty(FolderName)
		error cnERR_ARGUMENT_INVALID
	case not directory(FolderName)
		error cnERR_FILE_NOT_FOUND
	otherwise
		luReturn = This.oFSO.GetFolder(FolderName)
endcase
return luReturn

ENDPROC
PROCEDURE getdriveinfo
* Return a Drive object for the specified drive.

lparameters DriveLetter as String
local luReturn, ;
	lcDrive, ;
	loException, ;
	llError
luReturn = .NULL.
if vartype(DriveLetter) = 'C' and not empty(DriveLetter)
	if right(DriveLetter, 1) = ':'
		lcDrive = left(DriveLetter, 1)
	else
		lcDrive = DriveLetter
	endif right(DriveLetter, 1) = ':'
	try
		luReturn = This.oFSO.GetDrive(lcDrive)
	catch to loException
		llError = .T.
	endtry
	if llError
		error cnERR_INVALID_PATH_OR_FILE
	endif llError
else
	error cnERR_ARGUMENT_INVALID
endif vartype(DriveLetter) = 'C' ...
return luReturn

ENDPROC
PROCEDURE getfileinfo
* Return a File object for the specified file.

lparameters FileName as String
local luReturn
luReturn = .NULL.
do case
	case vartype(FileName) &lt;&gt; 'C' or empty(FileName)
		error cnERR_ARGUMENT_INVALID
	case not file(FileName)
		error cnERR_FILE_NOT_FOUND
	otherwise
		luReturn = This.oFSO.GetFile(FileName)
endcase
return luReturn

ENDPROC
PROCEDURE getlongfilename
lparameters FileName as String
local lcFile, ;
	lnLength, ;
	lcBuffer
if vartype(FileName) = 'C' and not empty(FileName)
	declare integer GetLongPathName in Win32API ;
		string @lpszShortPath, string @lpszLongPath, integer cchBuffer
	lcFile   = FileName + ccNULL
	lnLength = 260
	lcBuffer = space(lnLength)
	GetLongPathName(@lcFile, @lcBuffer, lnLength)
	lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
else
	error cnERR_ARGUMENT_INVALID
endif vartype(FileName) = 'C' ...
return lcFile

ENDPROC
PROCEDURE getshortfilename
lparameters FileName as String
local lcFile, ;
	lnLength, ;
	lcBuffer
if vartype(FileName) = 'C' and not empty(FileName)
	declare integer GetShortPathName in Win32API ;
		string @lpszLongPath, string @lpszShortPath, integer cchBuffer
	lcFile   = FileName + ccNULL
	lnLength = 260
	lcBuffer = space(lnLength)
	GetShortPathName(@lcFile, @lcBuffer, lnLength)
	lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
else
	error cnERR_ARGUMENT_INVALID
endif vartype(FileName) = 'C' ...
return lcFile

ENDPROC
PROCEDURE Init
* Create instances of the Windows Script Host and File System Object.

This.oWSH = createobject('WScript.Shell')
This.oFSO = createobject('Scripting.FileSystemObject')
dodefault()

ENDPROC
PROCEDURE movedirectory
* Move the contents of the specified folder.

lparameters SourceFolder as String, ;
	DestinationFolder as String
local llReturn
do case
	case vartype(SourceFolder) &lt;&gt; 'C' or empty(SourceFolder) or ;
		vartype(DestinationFolder) &lt;&gt; 'C' or empty(DestinationFolder)
		error cnERR_ARGUMENT_INVALID
	case not directory(SourceFolder)
		error cnERR_FILE_NOT_FOUND
	otherwise
		try
			This.oFSO.MoveFolder(SourceFolder, DestinationFolder)
			llReturn = directory(DestinationFolder)
		catch to loException
		endtry
endcase
return llReturn

ENDPROC
PROCEDURE movefile
* Move the specified file.

lparameters SourceFile as String, ;
	DestinationFile as String
local llReturn
do case
	case vartype(SourceFile) &lt;&gt; 'C' or empty(SourceFile) or ;
		vartype(DestinationFile) &lt;&gt; 'C' or empty(DestinationFile)
		error cnERR_ARGUMENT_INVALID
	case not file(SourceFile)
		error cnERR_FILE_NOT_FOUND
	otherwise
		This.oFSO.MoveFile(SourceFile, DestinationFile)
		llReturn = file(DestinationFile)
endcase
return llReturn

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>ofso A reference to a FileSystemObject object
owsh A reference to a Windows Script Host object
drives A collection of Drive objects
*copyfile Copies the specified file(s)
*copydirectory Copies the contents of the specified folder(s)
*getdriveinfo Returns a drive object for the specified drive letter
*getfileinfo Returns a File object for the specified file name
*getdirectoryinfo Returns a Folder object for the specified folder
*getlongfilename Returns the long file name for a short (8.3) file name
*getshortfilename Returns the short (8.3) file name for a long file name
*movefile Moves the specified file(s)
*movedirectory Moves the contents of the specified folder(s)
*drives_access 
*drives_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides access to file system attributes and methods</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>filesystem</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IS0XWJBR</uniqueid>
		<timestamp>883589228</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>user</objname>
		<parent/>
		<properties>username = 
owsh = .NULL.
userdomain = 
displayname = 
oaduser = .NULL.
cnamespace = My.User
_memberdata =     1524&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="warning" type="method" display="Warning"/&gt;
&lt;memberdata name="ccaption" type="property" display="cCaption"/&gt;
&lt;memberdata name="errormessage" type="property" display="ErrorMessage"/&gt;
&lt;memberdata name="quietmode" type="property" display="QuietMode"/&gt;
&lt;memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/&gt;
&lt;memberdata name="username" type="property" display="UserName"/&gt;
&lt;memberdata name="username_access" type="property" display="UserName_Access"/&gt;
&lt;memberdata name="username_assign" type="property" display="UserName_Assign"/&gt;
&lt;memberdata name="owsh" type="property" display="oWSH"/&gt;
&lt;memberdata name="userdomain" type="property" display="UserDomain"/&gt;
&lt;memberdata name="userdomain_access" type="property" display="UserDomain_Access"/&gt;
&lt;memberdata name="userdomain_assign" type="property" display="UserDomain_Assign"/&gt;
&lt;memberdata name="displayname" type="property" display="DisplayName"/&gt;
&lt;memberdata name="displayname_access" type="property" display="DisplayName_Access"/&gt;
&lt;memberdata name="displayname_assign" type="property" display="DisplayName_Assign"/&gt;
&lt;memberdata name="getaduser" type="method" display="GetADUser"/&gt;
&lt;memberdata name="oaduser" type="property" display="oADUser"/&gt;
&lt;/VFPData&gt;

Name = "user"
</properties>
		<protected>owsh
oaduser
getaduser
</protected>
		<methods>PROCEDURE Destroy
* Nuke member objects.

This.oWSH    = .NULL.
This.oADUser = .NULL.
dodefault()

ENDPROC
PROCEDURE displayname_access
local lcReturn
if vartype(This.oADUser) = 'O'
	lcReturn = This.oADUser.DisplayName
else
	lcReturn = ''
endif vartype(This.oADUser) = 'O'
return lcReturn

ENDPROC
PROCEDURE displayname_assign
* Throw a "property is read-only" error.

lparameters tcValue
error cnERR_PROPERTY_READ_ONLY, 'DisplayName'

ENDPROC
PROCEDURE getaduser
* This code was adapted from code posted by Sergey Berezniker on the Universal
* Thread.

local loNameTrans, ;
	lcDN, ;
	loADUser
#define cnADS_NAME_INITTYPE_GC 3
#define cnADS_NAME_TYPE_NT4    3
#define cnADS_NAME_TYPE_1779   1
try
	loNameTrans = createobject('NameTranslate')
	loNameTrans.Init(cnADS_NAME_INITTYPE_GC, '')
	loNameTrans.Set(cnADS_NAME_TYPE_NT4, This.UserDomain + '\' + This.UserName)
	lcDN     = loNameTrans.Get(cnADS_NAME_TYPE_1779)
	loADUser = getobject('LDAP://' + lcDN)
catch to loException when loException.Errorno = 1426
	loADUser = .NULL.
endtry
return loADUser

ENDPROC
PROCEDURE Init
* Create a Windows Script Host object and get an Active Directory user object
* for the current Windows user.

with This
	.oWSH    = createobject('WScript.Network')
	.oADUser = .GetADUser()
endwith
dodefault()

ENDPROC
PROCEDURE userdomain_access
return This.oWSH.UserDomain

ENDPROC
PROCEDURE userdomain_assign
* Throw a "property is read-only" error.

lparameters tcValue
error cnERR_PROPERTY_READ_ONLY, 'UserDomain'

ENDPROC
PROCEDURE username_access
return This.oWSH.UserName

ENDPROC
PROCEDURE username_assign
* Throw a "property is read-only" error.

lparameters tcValue
error cnERR_PROPERTY_READ_ONLY, 'UserName'

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>username The name of the current Windows user
owsh A reference to a Windows Scripting Host object
userdomain The domain for the current Windows user
displayname The display name for the current user
oaduser A reference to an Active Directory user object
*username_access 
*username_assign 
*userdomain_access 
*userdomain_assign 
*displayname_access 
*displayname_assign 
*getaduser Returns an Active Directory user object for the current Windows user
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides information about the current user</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>user</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0MFOMK</uniqueid>
		<timestamp>883644182</timestamp>
		<class>form</class>
		<classloc/>
		<baseclass>form</baseclass>
		<objname>mybuilderform</objname>
		<parent/>
		<properties>DataSession = 2
Height = 514
Width = 514
DoCreate = .T.
ShowTips = .T.
AutoCenter = .T.
Caption = "My Registration Editor"
FontName = "Tahoma"
FontSize = 8
MaxButton = .F.
MinButton = .F.
MinHeight = 450
MinWidth = 350
WindowType = 1
BindControls = .F.
AllowOutput = .F.
_memberdata =      636&lt;VFPData&gt;
&lt;memberdata name="loadtree" type="method" display="LoadTree"/&gt;
&lt;memberdata name="oobject" type="property" display="oObject"/&gt;
&lt;memberdata name="getobjectreference" type="method" display="GetObjectReference"/&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="save" type="method" display="Save"/&gt;
&lt;memberdata name="cdescription" type="property" display="cDescription"/&gt;
&lt;memberdata name="lautoshow" type="property" display="lAutoShow"/&gt;
&lt;memberdata name="lautorelease" type="property" display="lAutoRelease"/&gt;
&lt;/VFPData&gt;

oobject = .NULL.
cnamespace = 
cdescription = 
lautoshow = .T.
lautorelease = .F.
Name = "mybuilderform"
</properties>
		<protected>loadtree
getobjectreference
openmytable
</protected>
		<methods>PROCEDURE Destroy
* Nuke member objects and close cursors.

This.oObject = .NULL.
use in select('__MY')
use in select('__MYCURSOR')

ENDPROC
PROCEDURE getobjectreference
local laObjects[1], ;
	lnObjects
lnObjects = aselobj(laObjects)
if lnObjects = 0
	lnObjects = aselobj(laObjects, 3)
endif lnObjects = 0
if lnObjects &gt; 0
	This.oObject = laObjects[1]
	This.tmrBuilder.Enabled = .T.
endif lnObjects &gt; 0
return vartype(This.oObject) = 'O'

ENDPROC
PROCEDURE Init
* Turn on debugging. Do this before declaring variables since that seems to
* mess them up.

sys(2030, 1)
local llError, ;
	lnLen, ;
	lcPath, ;
	llReturn
with This

* Get a reference to the selected object and open the My table.

	do case
		case not .GetObjectReference()
			messagebox(ccERR_NO_OBJECT_SELECTED_LOC, MB_ICONEXCLAMATION, ;
				.Caption)
			llError = .T.
		case .OpenMyTable()

* If the object has a cNameSpace property, fill a cursor with any records
* already registered and set the cNameSpace and cDescription properties.

			if pemstatus(.oObject, 'cNameSpace', 5) and ;
				not empty(.oObject.cNameSpace)
				.cNameSpace = .oObject.cNameSpace
				lnLen       = len(.cNameSpace) + 2
				select * from __MY ;
					where upper(MEMBER) = upper(.oObject.cNameSpace) and ;
						at('.', alltrim(substr(MEMBER, lnLen))) = 0 and ;
						(upper(MEMBER) = upper(.oObject.cNameSpace) + ' ' or ;
							TYPE &lt;&gt; 'C') and ;
						not deleted() ;
					into cursor __MYCURSOR readwrite

* If the object doesn't have a cNameSpace property, we'll create a namespace
* value and blank cursor.

			else
				select * from __MY where .F. into cursor __MYCURSOR readwrite
				.cNameSpace = 'My.' + proper(.oObject.Class)
			endif pemstatus(.oObject, 'cNameSpace', 5) ...
			index on upper(MEMBER) tag MEMBER

* Add a record for the class if there isn't one.

			locate for TYPE = 'C'
			if found()
				.cDescription = DESCRIP
			else
				lcPath = sys(2014, sys(1271, .oObject), .ClassLibrary)
				insert into __MYCURSOR (MEMBER, TYPE, CLASS, LIBRARY) ;
					values (.cNameSpace, 'C', .oObject.Class, lcPath)
			endif found()

* Load the TreeView, select the first node, and turn on data binding.

			.LoadTree()
			.oTree.NodeClick(.oTree.Nodes(1))
			.BindControls = .T.
		otherwise
			messagebox(ccERR_COULD_NOT_OPEN_MY_LOC, MB_ICONEXCLAMATION, ;
				.Caption)
			llError = .T.
	endcase
endwith

* If we have a problem, bug out now.

llReturn = .T.
do case
	case not llError
	case program(program(-1) - 1) = 'DOBUILDER'
		This.lAutoShow    = .F.
		This.lAutoRelease = .T.
	otherwise
		llReturn = .F.
endcase
return llReturn

ENDPROC
PROCEDURE Load
* Set up the environment.

set ansi       off
set deleted    on
set exact      off
set exclusive  off
set multilocks on
set near       off
set safety     off
set talk       off
set unique     off

ENDPROC
PROCEDURE loadtree
* Add records for public properties and methods to the My table.

local loNode, ;
	lcMemberData, ;
	laLines[1], ;
	lnLines, ;
	lnI, ;
	lcLine, ;
	lnPos, ;
	lcMember, ;
	lcDescription, ;
	laComments[1], ;
	laMembers[1], ;
	lnMembers, ;
	lnLine, ;
	lcMetaData, ;
	lcSignature, ;
	lcNameSpace

* Load the images for the ImageList control.

with This.oImageList
	.ImageHeight = 16
	.ImageWidth  = 16
	.ListImages.Add(1, 'Method', ;
		loadpicture(home() + 'ffc\graphics\method.bmp'))
	.ListImages.Add(2, 'Property', ;
		loadpicture(home() + 'ffc\graphics\propty.bmp'))
endwith

* Add "Methods" and "Properties" root nodes.

with This.oTree
	.Object.ImageList = This.oImageList
	loNode = .Nodes.Add(, 1, '__RootMethods', 'Methods', 'Method')
	loNode.Expanded = .T.
	loNode.Sorted   = .T.
	loNode = .Nodes.Add(, 1, '__RootProperties', 'Properties', 'Property')
	loNode.Expanded = .T.
	loNode.Sorted   = .T.
endwith
with This.oObject

* Get any MemberData for the object.

	if pemstatus(This.oObject, '_MemberData', 5)
		lcMemberData = ._MemberData
	else
		lcMemberData = ''
	endif pemstatus(This.oObject, '_MemberData', 5)

* Open the FOXCODE table so we can look for global MemberData.

	try
		use (_foxcode) again shared in 0 alias FOXCODE
	catch
	endtry

* Open the VCX and read descriptions.

	select 0
	try
		use (sys(1271, This.oObject)) again shared noupdate alias __VCX
	catch
	endtry
	if used('__VCX')
		locate for PLATFORM = 'WINDOWS' and OBJNAME = lower(.Class)
		lnLines = alines(laLines, RESERVED3)
		This.cDescription = iif(empty(This.cDescription), RESERVED7, ;
			This.cDescription)
		dimension laComments[lnLines, 2]
		use
		for lnI = 1 to lnLines
			lcLine = laLines[lnI]
			if left(lcLine, 1) = '*'
				lcLine = substr(lcLine, 2)
			endif left(lcLine, 1) = '*'
			lnPos              = at(' ', lcLine)
			lcMember           = left(lcLine, lnPos - 1)
			lcDescription      = substr(lcLine, lnPos + 1)
			laComments[lnI, 1] = lcMember
			laComments[lnI, 2] = lcDescription
		next lnI
	else
		laComments = ''
	endif used('__VCX')

* Get a list of public user-defined members and go through each of them.

	lnMembers = amembers(laMembers, This.oObject, 1, 'GUC+')
	for lnI = 1 to lnMembers
		lcMember = laMembers[lnI, 1]

* Get the description for the member.

		lnLine = ascan(laComments, lcMember, -1, -1, 1, 15)
		if lnLine &gt; 0
			lcDescription = laComments[lnLine, 2]
		else
			lcDescription = ''
		endif lnLine &gt; 0

* If we have MemberData for this member, get the display name since AMEMBERS()
* gives names in upper-case.

		lcMetaData = strextract(lcMemberData, 'name="' + lower(lcMember) + ;
			'"', '/&gt;')
		do case
			case not empty(lcMetaData)
				lcMember = evl(strextract(lcMetaData, 'display="', '"'), ;
					lcMember)
			case used('FOXCODE')
				lnSelect = select()
				select FOXCODE
				locate for TYPE = 'E' and upper(ABBREV) = lcMember
				if found()
					lcMember = evl(strextract(TIP, 'display="', '"'), ;
						lcMember)
				endif found()
				select (lnSelect)
		endcase
		do case

* If this is a method (we'll ignore certain methods that are public only
* because we need to call them and Access and Assign methods), create the
* signature for it by reading the code in the method. Then add it to the
* TreeView.

			case laMembers[lnI, 2] = 'Method' and ;
				not inlist(right(upper(lcMember), 7), '_ACCESS', '_ASSIGN')
				lcSignature = lcMember + '('
				lcCode      = .ReadMethod(lcMember)
				alines(laCode, lcCode)
				lnLine = ascan(laCode, 'lpara', -1, -1, 1, 9)
				do while lnLine &gt; 0
					lcLine = laCode[lnLine]
					if left(lower(lcLine), 5) = 'lpara'
						lcLine = substr(lcLine, at(' ', lcLine) + 1)
					endif left(lower(lcLine), 5) = 'lpara'
					lcLine      = alltrim(lcLine, 1, ' ', chr(9))
					lcSignature = lcSignature + lcLine
					if right(alltrim(lcLine, 1, ' ', chr(9)), 1) = ';'
						lcSignature = alltrim(left(lcSignature, ;
							len(lcSignature) - 1)) + ' '
						lnLine      = lnLine + 1
					else
						lnLine = 0
					endif right(alltrim(lcLine, 1, ' ', chr(9)), 1) = ';'
				enddo while lnLine &gt; 0
				lcSignature = lcSignature + ')'
				lcNameSpace = This.cNameSpace + '.' + lcMember
				loNode      = This.oTree.Nodes.Add('__RootMethods', 4, ;
					lcMember, lcMember, 'Method')
				loNode.Checked = .T.
				if not seek(padr(upper(lcNameSpace), len(__MY.MEMBER)), ;
					'__MYCURSOR')
					insert into __MYCURSOR ;
							(MEMBER, ;
							TYPE) ;
						values ;
							(lcNameSpace, ;
							'M')
				endif not seek(padr(upper(lcNameSpace) ...
				if empty(__MYCURSOR.TIP)
					replace TIP with lcSignature in __MYCURSOR
				endif empty(__MYCURSOR.TIP)
				if empty(__MYCURSOR.DESCRIP)
					replace DESCRIP with lcDescription in __MYCURSOR
				endif empty(__MYCURSOR.DESCRIP)

* If this is a property (we'll ignore certain properties that are public only
* because we need to access them), add or update a record for it in the My
* table.

			case laMembers[lnI, 2] = 'Property' and ;
				not inlist(upper(lcMember), 'CNAMESPACE', '_MEMBERDATA', ;
				'BUILDER', 'CCAPTION')
				lcNameSpace = This.cNameSpace + '.' + lcMember
				loNode      = This.oTree.Nodes.Add('__RootProperties', 4, ;
					lcMember, lcMember, 'Property')
				loNode.Checked = .T.
				if not seek(padr(upper(lcNameSpace), len(__MY.MEMBER)), ;
					'__MYCURSOR')
					insert into __MYCURSOR ;
							(MEMBER, ;
							TYPE) ;
						values ;
							(lcNameSpace, ;
							'P')
				endif not seek(padr(upper(lcNameSpace) ...
				if empty(__MYCURSOR.DESCRIP)
					replace DESCRIP with lcDescription in __MYCURSOR
				endif empty(__MYCURSOR.DESCRIP)
		endcase
	next lnI

* Close the FOXCODE table.

	use in select('FOXCODE')
endwith

ENDPROC
PROCEDURE openmytable
local lcDir, ;
	lcTable, ;
	llReturn
lcDir   = sys(16)
lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
lcTable = lcDir + 'my.dbf'
if used('__MY')
	llReturn = .T.
else
	try
		use (lcTable) again shared order MEMBER alias __MY in 0
		llReturn = .T.
	catch to loException
		llReturn = .F.
	endtry
endif used('__MY')
return llReturn

ENDPROC
PROCEDURE Refresh
* Enable or disable the controls appropriately.

with This
	do case
		case eof('__MYCURSOR')
			store .F. to .lblDescription.Enabled, .edtDescription.Enabled, ;
				.lblTip.Enabled, .edtTip.Enabled, ;
				.lblList.Enabled, .edtList.Enabled, ;
				.lblScript.Enabled, .edtScript.Enabled
		case __MYCURSOR.TYPE = 'P'
			store .T. to .lblDescription.Enabled, .edtDescription.Enabled
			store .F. to .lblTip.Enabled, .edtTip.Enabled, ;
				.lblList.Enabled, .edtList.Enabled, ;
				.lblScript.Enabled, .edtScript.Enabled
		otherwise
			store .T. to .lblDescription.Enabled, .edtDescription.Enabled, ;
				.lblTip.Enabled, .edtTip.Enabled, ;
				.lblList.Enabled, .edtList.Enabled, ;
				.lblScript.Enabled, .edtScript.Enabled
	endcase
endwith

ENDPROC
PROCEDURE save
* Save the changes.

local loData, ;
	lcMember, ;
	loNode, ;
	llSave, ;
	llExists, ;
	lnSelect, ;
	lcAlias, ;
	lcType
with This

* Save the namespace if the class has a property for it.

	if pemstatus(.oObject, 'cNameSpace', 5) and ;
		.oObject.cNameSpace &lt;&gt; alltrim(.cNameSpace)
		.oObject.cNameSpace = alltrim(.cNameSpace)
	endif pemstatus(.oObject, 'cNameSpace', 5) ...

* Save the member information.

	select __MYCURSOR
	set order to
	scan
		scatter memo name loData
		if TYPE &lt;&gt; 'C'
			lcMember = alltrim(substr(MEMBER, rat('.', MEMBER) + 1))
			if type('.oTree.Nodes(lcMember)') = 'O'
				loNode = .oTree.Nodes(lcMember)
				llSave = loNode.Checked
			else
				llSave = .F.
			endif type('.oTree.Nodes(lcMember)') = 'O'
		else
			llSave = .T.
			loData.Descrip = .cDescription
		endif TYPE &lt;&gt; 'C'
		llExists = seek(upper(loData.Member), '__MY')
		do case
			case not llExists and llSave
				insert into __MY from name loData
			case llExists and not llSave
				delete in __MY
			otherwise
				select __MY
				gather memo name loData
				select __MYCURSOR
		endcase
	endscan

*** NEED TO REMOVE RECORDS IF RENAMED NAMESPACE

* If this object isn't in the My namespace, add the necessary record to the
* IntelliSense table.

	if upper(left(.cNameSpace, 3)) &lt;&gt; 'MY.'
		lnSelect = select()
		select 0
		try
			use (_foxcode) again shared
			lcAlias = alias()
		catch
		endtry
		if not empty(lcAlias)

* Add the TYPE record if necessary.

			lcType = .cNameSpace
			locate for TYPE = 'T' and ;
				upper(ABBREV) = padr(upper(lcType), len(ABBREV)) and ;
				not deleted()
			if not found()
				insert into (lcAlias) ;
						(TYPE, ;
						ABBREV, ;
						CMD, ;
						DATA) ;
					values ;
						('T', ;
						lcType, ;
						'{MyScript}', ;
						lcType)
			endif not found()

* Clean up and exit.

			use in (lcAlias)
		endif not empty(lcAlias)
		select (lnSelect)
	endif upper(left(.cNameSpace, 3)) &lt;&gt; 'MY.'
endwith

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>20</reserved2>
		<reserved3>_memberdata XML Metadata for customizable properties
oobject A reference to the object being edited
cnamespace The namespace for the class
cdescription The description for the namespace
lautoshow .T. if we're supposed to be displayed
lautorelease .T. if we're supposed to auto-release
*loadtree Loads the TreeView with the members for the object
*getobjectreference Puts a reference to the object being edited into oObject
*openmytable Opens the My table
*save Saves the changes the user made
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>The builder for My namespace classes</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0PTVTM</uniqueid>
		<timestamp>883644182</timestamp>
		<class>shape</class>
		<classloc/>
		<baseclass>shape</baseclass>
		<objname>shpMembers</objname>
		<parent>mybuilderform</parent>
		<properties>Top = 94
Left = 6
Height = 381
Width = 500
Anchor = 15
BackStyle = 0
Style = 3
Name = "shpMembers"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0MRG9D</uniqueid>
		<timestamp>883644182</timestamp>
		<class>olecontrol</class>
		<classloc/>
		<baseclass>olecontrol</baseclass>
		<objname>oTree</objname>
		<parent>mybuilderform</parent>
		<properties>Top = 110
Left = 15
Height = 355
Width = 231
TabIndex = 6
Anchor = 135
Name = "oTree"
</properties>
		<protected/>
		<methods>PROCEDURE KeyPress
lparameters tnKeyASCII
if tnKeyASCII = 27
	Thisform.Release()
endif tnKeyASCII = 27

ENDPROC
PROCEDURE NodeClick
lparameters toNode
= seek(upper(alltrim(Thisform.cNameSpace) + '.' + toNode.Key), '__MYCURSOR')
Thisform.Refresh()

ENDPROC
</methods>
		<objcode/>
		<ole>REkR4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAF//CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAABf////AAAAAAAAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////95////X////1////8EAAAAX////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALBxIeEbdcYBAwAAAEACAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAO8AAAAAAAAABwAAAAIAAABf////BAAAAAUAAAAGAAAAX////wgAAABf//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAEFkKDYoIUM0EggAAADgFwAAsSQAALE8QWoBAAYAIgAAAPwANgDtAwAASQBQAMmVGgAB70mrXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTFvAGsAXABEAGEAdABhAFwAYQBkAGQAcgBlAHMAcwAgAGIAbwABAACADgAAAEhpZGVTZWxlY3Rpb24ABQAAAEwBAAAADAAAAEluZGVudGF0aW9uABEAAABODQAAAAcAAAAAAAAAAABDQAoAAABMYWJlbEVkaXQACQAAAEkKAAAAAQAAAA0AAABNb3VzZVBvaW50ZXIACQAAAEkKAAAAAAAAAA4AAABQYXRoU2VwYXJhdG9yAAoAAABIAAAAAAEAAABcDAAAAE9MRURyYWdNb2RlAAkAAABJCgAAAAAAAAAMAAAAT0xFRHJvcE1vZGUACQAAAEkKAAAAAAAAAAsAAABDaGVja2JveGVzAAUAAABMAQAAAABfkQAAAAAAAGQTAQAAAAAAAAAFAJiXGgAGAGMAAAAAAAUAAIBv6RIAAQAAAFwAH1/svQEABQDh6RIAA1JhC5GPSRGdYQCqAEssUQEAAACQAURCAQAGVGFob21hAQAgAAB4AxUAQYkdAICAAACAgAAAAAAAAEFBQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgIAAAAAAAAD///8AAAAAAP///wD///8AAAAAAP///wD///8A////AP///wD///8A////AP///wAAAAAAAP//AAD//wAAgIAAAAAAAP///wCAgIAAgICAAICAgAAAAAAAQUFBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAAAICAAAAAAAAA////AP///wAAAAAA////AP///wD///8A////AP///wD///8A////AP///wAAAAAAAP//AAD//wAAgIAAAAAAAP///wCAgIAAgICAAAAAAABBQUEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///wAAAAAA////AAAAAACAgAAAgIAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AAAAAAAA//8AAP//AACAgAAAAAAA////AP///wCAgIAAAAAAAEFBQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgIAAAAAAAAD///8AAAAAAP///wD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</ole>
		<ole2>OLEObject = C:\WINDOWS\system32\MSComCtl.ocx
</ole2>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0MRG9N</uniqueid>
		<timestamp>883644182</timestamp>
		<class>olecontrol</class>
		<classloc/>
		<baseclass>olecontrol</baseclass>
		<objname>oImageList</objname>
		<parent>mybuilderform</parent>
		<properties>Top = 109
Left = 211
Height = 100
Width = 100
Name = "oImageList"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole>REkR4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAF//CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAABf////AAAAAAAAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////95////X////1////9f/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBvIuEbdcYBAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAIAAABf////X////1////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8jfyQskYXREbFqAEFkKDYoIUM0EggAAADtAwAA7QMAAIB+4eYAAAYAIAAAAAAAAABBQUEA//8AAAHvSasAAAUAXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUCgaAAYAAAD/////BQAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</ole>
		<ole2>OLEObject = C:\WINDOWS\system32\MSComCtl.ocx
</ole2>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18BXHL</uniqueid>
		<timestamp>883644182</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>lblNameSpace</objname>
		<parent>mybuilderform</parent>
		<properties>AutoSize = .T.
FontName = "Tahoma"
FontSize = 8
BackStyle = 0
Caption = "Namespace"
Height = 15
Left = 7
Top = 9
Width = 57
TabIndex = 1
Name = "lblNameSpace"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0PTVU6</uniqueid>
		<timestamp>883644182</timestamp>
		<class>textbox</class>
		<classloc/>
		<baseclass>textbox</baseclass>
		<objname>txtNameSpace</objname>
		<parent>mybuilderform</parent>
		<properties>FontName = "Tahoma"
FontSize = 8
Anchor = 10
ControlSource = "Thisform.cNameSpace"
Format = "T"
Height = 23
Left = 77
TabIndex = 2
Top = 6
Width = 430
Name = "txtNameSpace"
</properties>
		<protected/>
		<methods>PROCEDURE GotFocus
This.Tag = Thisform.cNameSpace

ENDPROC
PROCEDURE Valid
local loObject, ;
	lcNameSpace, ;
	llValid, ;
	lnI, ;
	lcChar

* If the Valid method fired because the user clicked on the Cancel button or
* if we're closing the form, don't bother doing the rest of the validation.

loObject = sys(1270)
if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
	(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType &gt; 0)
	return .T.
endif (type('loObject.Cancel') = 'L' ...

* Don't allow illegal characters. This should be rewritten to use a regular
* expression; for now, it's a brute force method.

lcNameSpace = alltrim(This.Value)
llValid     = .T.
for lnI = 1 to len(lcNameSpace)
	lcChar = substr(lcNameSpace, lnI, 1)
	do case

* The namespace can only consist of letters, digits, underscores, and periods.

		case not isalpha(lcChar) and not isdigit(lcChar) and not lcChar $ '_.'
			messagebox(ccERR_INVALID_CHAR_IN_NAMESPACE_LOC, ;
				MB_ICONEXCLAMATION, Thisform.Caption)
			llValid = .F.
			exit

* The first character must be a letter.

		case not isalpha(lcChar) and lnI = 1
			messagebox(ccERR_FIRST_LETTER_LOC, MB_ICONEXCLAMATION, ;
				Thisform.Caption)
			llValid = .F.
			exit

* The first namespace must be more than one letter long to prevent VFP from
* thinking it's a workarea alias.

		case lcChar $ '_.' and lnI &lt; 3
			messagebox(ccERR_NAMESPACE_TOO_SHORT_LOC, MB_ICONEXCLAMATION, ;
				Thisform.Caption)
			llValid = .F.
			exit
	endcase
next lnI

* Rename all records if the namespace was changed.

if llValid and not lcNameSpace == This.Tag
	select __MYCURSOR
	replace all MEMBER with strtran(MEMBER, This.Tag, lcNameSpace)
endif llValid ...
return llValid

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18BXHL</uniqueid>
		<timestamp>883644182</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>lblDescription</objname>
		<parent>mybuilderform</parent>
		<properties>AutoSize = .T.
FontName = "Tahoma"
FontSize = 8
Anchor = 40
BackStyle = 0
Caption = "Description"
Height = 15
Left = 260
Top = 110
Width = 55
TabIndex = 8
ToolTipText = "Specify the description for this member"
Name = "lblDescription"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>883065639</timestamp>
		<class>editbox</class>
		<classloc/>
		<baseclass>editbox</baseclass>
		<objname>edtDescription</objname>
		<parent>mybuilderform</parent>
		<properties>FontName = "Tahoma"
FontSize = 8
Anchor = 40
Height = 55
Left = 260
TabIndex = 9
ToolTipText = "Specify the description for this member"
Top = 125
Width = 235
ControlSource = "__MyCursor.Descrip"
Name = "edtDescription"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18BXHL</uniqueid>
		<timestamp>883644182</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>lblTip</objname>
		<parent>mybuilderform</parent>
		<properties>AutoSize = .T.
FontName = "Tahoma"
FontSize = 8
Anchor = 40
BackStyle = 0
Caption = "Method Signature"
Height = 15
Left = 260
Top = 185
Width = 87
TabIndex = 10
ToolTipText = "Specify the signature for this method (e.g. MethodName(Parameter1 as String) as Boolean)"
Name = "lblTip"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>883065639</timestamp>
		<class>editbox</class>
		<classloc/>
		<baseclass>editbox</baseclass>
		<objname>edtTip</objname>
		<parent>mybuilderform</parent>
		<properties>FontName = "Tahoma"
FontSize = 8
Anchor = 40
Height = 55
Left = 260
TabIndex = 11
ToolTipText = "Specify the signature for this method (e.g. MethodName(Parameter1 as String) as Boolean)"
Top = 200
Width = 235
ControlSource = "__MyCursor.Tip"
Name = "edtTip"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0PTVU7</uniqueid>
		<timestamp>883644182</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>lblList</objname>
		<parent>mybuilderform</parent>
		<properties>AutoSize = .T.
FontName = "Tahoma"
FontSize = 8
Anchor = 40
BackStyle = 0
Caption = "Enumerated Parameter List"
Height = 15
Left = 260
Top = 260
Width = 132
TabIndex = 12
ToolTipText = "If the method accepts an enumerated parameter, specify the values and description for the values as comma-delimited pairs on individial lines"
Name = "lblList"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0PTVU8</uniqueid>
		<timestamp>883065672</timestamp>
		<class>editbox</class>
		<classloc/>
		<baseclass>editbox</baseclass>
		<objname>edtList</objname>
		<parent>mybuilderform</parent>
		<properties>FontName = "Tahoma"
FontSize = 8
Anchor = 105
Height = 85
Left = 260
TabIndex = 13
ToolTipText = "If the method accepts an enumerated parameter, specify the values and description for the values as comma-delimited pairs on individial lines"
Top = 275
Width = 235
ControlSource = "__MyCursor.List"
Name = "edtList"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0QRTXN</uniqueid>
		<timestamp>883644182</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>lblMembers</objname>
		<parent>mybuilderform</parent>
		<properties>AutoSize = .T.
FontName = "Tahoma"
FontSize = 8
Caption = " Members "
Height = 15
Left = 21
Top = 87
Width = 51
TabIndex = 5
Style = 3
Name = "lblMembers"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18BXHL</uniqueid>
		<timestamp>883065382</timestamp>
		<class>commandbutton</class>
		<classloc/>
		<baseclass>commandbutton</baseclass>
		<objname>cmdOK</objname>
		<parent>mybuilderform</parent>
		<properties>Top = 484
Left = 350
Height = 23
Width = 75
FontName = "Tahoma"
FontSize = 8
Anchor = 12
Caption = "OK"
Default = .F.
TabIndex = 14
Name = "cmdOK"
</properties>
		<protected/>
		<methods>PROCEDURE Click
Thisform.Save()
Thisform.Release()

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0QY1Y1</uniqueid>
		<timestamp>883065382</timestamp>
		<class>commandbutton</class>
		<classloc/>
		<baseclass>commandbutton</baseclass>
		<objname>cmdCancel</objname>
		<parent>mybuilderform</parent>
		<properties>Top = 484
Left = 430
Height = 23
Width = 75
FontName = "Tahoma"
FontSize = 8
Anchor = 12
Cancel = .T.
Caption = "Cancel"
TabIndex = 15
Name = "cmdCancel"
</properties>
		<protected/>
		<methods>PROCEDURE Click
Thisform.Release()

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0S5018</uniqueid>
		<timestamp>883644182</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>lblNameSpaceDescrip</objname>
		<parent>mybuilderform</parent>
		<properties>AutoSize = .T.
FontName = "Tahoma"
FontSize = 8
Anchor = 40
BackStyle = 0
Caption = "Description"
Height = 15
Left = 6
Top = 30
Width = 55
TabIndex = 3
Name = "lblNameSpaceDescrip"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0S5019</uniqueid>
		<timestamp>850618614</timestamp>
		<class>editbox</class>
		<classloc/>
		<baseclass>editbox</baseclass>
		<objname>edtNameSpaceDescrip</objname>
		<parent>mybuilderform</parent>
		<properties>FontName = "Tahoma"
FontSize = 8
Anchor = 10
Height = 50
Left = 76
TabIndex = 4
Top = 30
Width = 430
ControlSource = "Thisform.cDescription"
Name = "edtNameSpaceDescrip"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IU0VKQ9R</uniqueid>
		<timestamp>883644182</timestamp>
		<class>timer</class>
		<classloc/>
		<baseclass>timer</baseclass>
		<objname>tmrBuilder</objname>
		<parent>mybuilderform</parent>
		<properties>Top = 155
Left = 225
Height = 23
Width = 23
Enabled = .F.
Interval = 1000
Name = "tmrBuilder"
</properties>
		<protected/>
		<methods>PROCEDURE Timer
* Close the builder if the class was closed.

if vartype(Thisform.oObject) &lt;&gt; 'O'
	Thisform.Release()
endif vartype(Thisform.oObject) &lt;&gt; 'O'

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1SK0YWP5D</uniqueid>
		<timestamp>883644182</timestamp>
		<class>label</class>
		<classloc/>
		<baseclass>label</baseclass>
		<objname>lblScript</objname>
		<parent>mybuilderform</parent>
		<properties>AutoSize = .T.
FontName = "Tahoma"
FontSize = 8
Anchor = 104
BackStyle = 0
Caption = "Script"
Height = 15
Left = 260
Top = 365
Width = 29
TabIndex = 12
ToolTipText = "If the method accepts an enumerated parameter, specify the values and description for the values as comma-delimited pairs on individial lines"
Name = "lblScript"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1SK0YWP5E</uniqueid>
		<timestamp>883065657</timestamp>
		<class>editbox</class>
		<classloc/>
		<baseclass>editbox</baseclass>
		<objname>edtScript</objname>
		<parent>mybuilderform</parent>
		<properties>FontName = "Tahoma"
FontSize = 8
Anchor = 120
Height = 85
Left = 260
TabIndex = 13
ToolTipText = "If the method accepts an enumerated parameter, specify the values and description for the values as comma-delimited pairs on individial lines"
Top = 380
Width = 235
ControlSource = "__MyCursor.Script"
Name = "edtScript"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>mybuilderform</objname>
		<parent/>
		<properties>Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18E034</uniqueid>
		<timestamp>883644592</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>app</objname>
		<parent/>
		<properties>cnamespace = My.App
_memberdata =      701&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="warning" type="method" display="Warning"/&gt;
&lt;memberdata name="ccaption" type="property" display="cCaption"/&gt;
&lt;memberdata name="errormessage" type="property" display="ErrorMessage"/&gt;
&lt;memberdata name="quietmode" type="property" display="QuietMode"/&gt;
&lt;memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/&gt;
&lt;memberdata name="execute" type="method" display="Execute"/&gt;
&lt;/VFPData&gt;

Name = "app"
</properties>
		<protected/>
		<methods>PROCEDURE execute
lparameters FileName as String, Operation as String, WorkingFolder as String, ;
	OtherParameters as String
local lcFileName, ;
	lcWorkDir, ;
	lcOperation, ;
	lcParameters, ;
	lnShow
if empty(FileName)
	return -1
endif empty(FileName)
lcFileName   = alltrim(FileName)
lcWorkDir    = iif(vartype(WorkingFolder) = 'C', alltrim(WorkingFolder), '')
lcOperation  = iif(vartype(Operation) = 'C' and not empty(Operation), ;
	alltrim(Operation), 'Open')
lcParameters = iif(vartype(OtherParameters) = 'C', alltrim(OtherParameters), ;
	'')
lnShow       = iif(upper(lcOperation) = 'Print', 0, 1)
declare integer ShellExecute in SHELL32.DLL ;
	integer nWinHandle, ;	&amp;&amp; handle of parent window
	string cOperation, ;	&amp;&amp; operation to perform
	string cFileName, ;		&amp;&amp; filename
	string cParameters, ;	&amp;&amp; parameters for the executable
	string cDirectory, ;	&amp;&amp; default directory
	integer nShowWindow		&amp;&amp; window state
* Returns:			-1: if no filename was passed
*					2:  bad association
*					29: failure to load application
*					30: application is busy
*					31: no application association
*					Values over 32 indicate success and return an instance
*						handle for the application
return ShellExecute(0, lcOperation, lcFilename, lcParameters, lcWorkDir, ;
	lnShow)

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>*execute Executes the specified file
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>The Application namespace</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>app</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1SK11QNEJ</uniqueid>
		<timestamp>883644604</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>clock</objname>
		<parent/>
		<properties>timezonedescription = 
timezoneoffset = 0
localtime = (/:}
gmttime = {}
_memberdata =     1592&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="warning" type="method" display="Warning"/&gt;
&lt;memberdata name="ccaption" type="property" display="cCaption"/&gt;
&lt;memberdata name="errormessage" type="property" display="ErrorMessage"/&gt;
&lt;memberdata name="quietmode" type="property" display="QuietMode"/&gt;
&lt;memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/&gt;
&lt;memberdata name="timezonedescription" type="property" display="TimeZoneDescription"/&gt;
&lt;memberdata name="timezoneoffset" type="property" display="TimeZoneOffset"/&gt;
&lt;memberdata name="timezonedescription_assign" type="method" display="TimeZoneDescription_Assign"/&gt;
&lt;memberdata name="timezoneoffset_assign" type="method" display="TimeZoneOffset_Assign"/&gt;
&lt;memberdata name="localtime" type="property" display="LocalTime"/&gt;
&lt;memberdata name="localtime_access" type="method" display="LocalTime_Access"/&gt;
&lt;memberdata name="localtime_assign" type="method" display="LocalTime_Assign"/&gt;
&lt;memberdata name="gmttime" type="property" display="GMTTime"/&gt;
&lt;memberdata name="gmttime_access" type="method" display="GMTTime_Access"/&gt;
&lt;memberdata name="gmttime_assign" type="method" display="GMTTime_Assign"/&gt;
&lt;memberdata name="convertlocaltogmt" type="method" display="ConvertLocalToGMT"/&gt;
&lt;memberdata name="convertgmttolocal" type="method" display="ConvertGMTToLocal"/&gt;
&lt;/VFPData&gt;

cnamespace = My.Computer.Clock
Name = "clock"
</properties>
		<protected/>
		<methods>PROCEDURE convertgmttolocal
lparameters GMTTime as DateTime
local ltGMTTime, ;
	ltLocalTime
do case
	case vartype(GMTTime) = 'D'
		ltGMTTime = dtot(GMTTime)
	case vartype(GMTTime) = 'T'
		ltGMTTime = GMTTime
	otherwise
		error 11
		return .NULL.
endcase
ltLocalTime = ltGMTTime - This.TimeZoneOffset
return ltLocalTime

ENDPROC
PROCEDURE convertlocaltogmt
lparameters LocalTime as DateTime
local ltLocalTime, ;
	ltGMTTime
do case
	case vartype(LocalTime) = 'D'
		ltLocalTime = dtot(LocalTime)
	case vartype(LocalTime) = 'T'
		ltLocalTime = LocalTime
	otherwise
		error 11
		return .NULL.
endcase
ltGMTTime = ltLocalTime + This.TimeZoneOffset
return ltGMTTime

ENDPROC
PROCEDURE gmttime_access
return This.ConvertLocalToGMT(datetime())

ENDPROC
PROCEDURE gmttime_assign
* Throw a "property is read-only" error.

lparameters tuValue
error cnERR_PROPERTY_READ_ONLY, 'GMTTime'

ENDPROC
PROCEDURE Init
local lcTimeZone, ;
	lnID, ;
	lnStandardOffset, ;
	lnDaylightOffset

* Declare the time zone information API function and get the time zone
* information.

#define TIME_ZONE_SIZE  172
declare integer GetTimeZoneInformation in kernel32 ;
	string @lpTimeZoneInformation
lcTimeZone = replicate(chr(0), TIME_ZONE_SIZE)
lnID       = GetTimeZoneInformation(@lcTimeZone)

* Determine the standard and daylight time offset.

lnStandardOffset = ctobin(substr(lcTimeZone,   1, 4), '4RS')
lnDaylightOffset = ctobin(substr(lcTimeZone, 169, 4), '4RS')

* Determine the total offset based on whether the computer is on daylight time
* or not. Get the description for the time zone.

if lnID = 2  &amp;&amp; daylight time
	This.TimeZoneDescription = strtran(strconv(substr(lcTimeZone, 89, 64), ;
		6), chr(0), '')
	This.TimeZoneOffset = (lnStandardOffset + lnDaylightOffset) * 60
else   &amp;&amp; standard time
	This.TimeZoneDescription = strtran(strconv(substr(lcTimeZone,  5, 64), ;
		6), chr(0), '')
	This.TimeZoneOffset = lnStandardOffset * 60
endif lnID = 2

ENDPROC
PROCEDURE localtime_access
return datetime()

ENDPROC
PROCEDURE localtime_assign
* Throw a "property is read-only" error.

lparameters tuValue
error cnERR_PROPERTY_READ_ONLY, 'LocalTime'

ENDPROC
PROCEDURE timezonedescription_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tuValue
if This.CalledFromThisClass()
	This.TimeZoneDescription = tuValue
else
	error cnERR_PROPERTY_READ_ONLY, 'TimeZoneDescription'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE timezoneoffset_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tuValue
if This.CalledFromThisClass()
	This.TimeZoneOffset = tuValue
else
	error cnERR_PROPERTY_READ_ONLY, 'TimeZoneOffset'
endif This.CalledFromThisClass()

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>timezonedescription The description for the current time zone
timezoneoffset The offset from the current time zone to GMT in seconds
localtime The current local date and time
gmttime The current date and time as GMT
*timezonedescription_assign 
*timezoneoffset_assign 
*localtime_access 
*localtime_assign 
*gmttime_access 
*gmttime_assign 
*convertlocaltogmt Converts the specified local date and time to GMT
*convertgmttolocal Converts the specified GMT date and time to local
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides properties and methods to handle local and GMT date and time</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>clock</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18DBCE</uniqueid>
		<timestamp>883644612</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>computer</objname>
		<parent/>
		<properties>computername = 
owsh = .NULL.
cnamespace = My.Computer
_memberdata =      940&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="warning" type="method" display="Warning"/&gt;
&lt;memberdata name="ccaption" type="property" display="cCaption"/&gt;
&lt;memberdata name="errormessage" type="property" display="ErrorMessage"/&gt;
&lt;memberdata name="quietmode" type="property" display="QuietMode"/&gt;
&lt;memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/&gt;
&lt;memberdata name="computername" type="property" display="ComputerName"/&gt;
&lt;memberdata name="computername_access" type="method" display="ComputerName_Access"/&gt;
&lt;memberdata name="computername_assign" type="method" display="ComputerName_Assign"/&gt;
&lt;memberdata name="owsh" type="property" display="oWSH"/&gt;
&lt;/VFPData&gt;

Name = "computer"
</properties>
		<protected>owsh
</protected>
		<methods>PROCEDURE computername_access
return This.oWSH.ComputerName

ENDPROC
PROCEDURE computername_assign
* Throw a "property is read-only" error.

lparameters tcValue
error cnERR_PROPERTY_READ_ONLY, 'ComputerName'

ENDPROC
PROCEDURE Destroy
* Nuke member objects.

This.oWSH = .NULL.
dodefault()

ENDPROC
PROCEDURE Init
* Create a Windows Script Host object.

This.oWSH = createobject('WScript.Network')
dodefault()

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>computername The computer name
owsh A reference to a Windows Scripting Host object
*computername_access 
*computername_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>The Computer namespace</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>computer</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18BXHL</uniqueid>
		<timestamp>883644625</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>my</objname>
		<parent/>
		<properties>cnamespace = My
Name = "my"
</properties>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>The My namespace</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>my</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1/>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IA11QYWI</uniqueid>
		<timestamp>883644634</timestamp>
		<class>collection</class>
		<classloc/>
		<baseclass>collection</baseclass>
		<objname>mycollection</objname>
		<parent/>
		<properties>Height = 23
Width = 23
Name = "mycollection"
</properties>
		<protected/>
		<methods>PROCEDURE Add
* Handle case-insensitive and duplicate keys.

lparameters tuItem, ;
	tcKey, ;
	tuBefore, ;
	tuAfter
local lcKey
do case
	case pcount() = 1
		dodefault(tuItem)
	case vartype(tcKey) = 'C'
		lcKey = upper(tcKey)
		do case
			case This.GetKey(lcKey) &gt; 0
			case pcount() = 2
				dodefault(tuItem, lcKey)
			case pcount() = 3
				dodefault(tuItem, lcKey, tuBefore)
			case pcount() = 4
				dodefault(tuItem, lcKey, tuBefore, tuAfter)
		endcase
	case pcount() = 3
		dodefault(tuItem, tcKey, tuBefore)
	case pcount() = 4
		dodefault(tuItem, tcKey, tuBefore, tuAfter)
endcase
nodefault

ENDPROC
PROCEDURE GetKey
* Handle case-insensitive keys.

lparameters tuIndex
local lcIndex, ;
	luReturn
if vartype(tuIndex) = 'C'
	lcIndex  = upper(tuIndex)
	luReturn = dodefault(lcIndex)
else
	luReturn = dodefault(tuIndex)
endif vartype(tuIndex) = 'C'
nodefault
return luReturn

ENDPROC
PROCEDURE Item
* Handle case-insensitive and non-existent keys.

lparameters tuIndex
local lcIndex, ;
	luReturn
if vartype(tuIndex) = 'C'
	lcIndex = upper(tuIndex)
	if This.GetKey(lcIndex) = 0
		luReturn = .NULL.
	else
		luReturn = dodefault(lcIndex)
	endif This.GetKey(lcIndex) = 0
else
	luReturn = dodefault(tuIndex)
endif vartype(tuIndex) = 'C'
nodefault
return luReturn

ENDPROC
PROCEDURE Remove
* Handle case-insensitive keys.

lparameters tuIndex
local lcIndex, ;
	luReturn
if vartype(tuIndex) = 'C'
	lcIndex = upper(tuIndex)
	dodefault(lcIndex)
else
	dodefault(tuIndex)
endif vartype(tuIndex) = 'C'
nodefault

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>A case-insensitive Collection class</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>mycollection</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18L6DH</uniqueid>
		<timestamp>883644654</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>printer</objname>
		<parent/>
		<properties>availableprinters = .NULL.
defaultvfpprinter = 
defaultwindowsprinter = 
cnamespace = My.Computer.Printer
_memberdata =     1209&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="availableprinters" type="property" display="AvailablePrinters"/&gt;
&lt;memberdata name="availableprinters_access" type="property" display="AvailablePrinters_Access"/&gt;
&lt;memberdata name="availableprinters_assign" type="property" display="AvailablePrinters_Assign"/&gt;
&lt;memberdata name="defaultvfpprinter" type="property" display="DefaultVFPPrinter"/&gt;
&lt;memberdata name="defaultvfpprinter_access" type="property" display="DefaultVFPPrinter_Access"/&gt;
&lt;memberdata name="defaultvfpprinter_assign" type="property" display="DefaultVFPPrinter_Assign"/&gt;
&lt;memberdata name="defaultwindowsprinter" type="property" display="DefaultWindowsPrinter"/&gt;
&lt;memberdata name="defaultwindowsprinter_access" type="property" display="DefaultWindowsPrinter_Access"/&gt;
&lt;memberdata name="defaultwindowsprinter_assign" type="property" display="DefaultWindowsPrinter_Assign"/&gt;
&lt;memberdata name="pagesetup" type="method" display="PageSetup"/&gt;
&lt;/VFPData&gt;

Name = "printer"
</properties>
		<protected/>
		<methods>PROCEDURE availableprinters_access
local laPrinters[1], ;
	lnI, ;
	loPrinter

* Clear the collection if we already have one or instantiate it if not.

if vartype(This.AvailablePrinters) = 'O'
	This.AvailablePrinters.Remove(-1)
else
	This.AvailablePrinters = newobject('MyCollection', 'My.vcx')
endif vartype(This.AvailablePrinters) = 'O'

* Fill the collection with objects containing information about the available
* printers.

for lnI = 1 to aprinters(laPrinters, 1)
	loPrinter = createobject('Empty')
	addproperty(loPrinter, 'PrinterName', laPrinters[lnI, 1])
	addproperty(loPrinter, 'Port',        laPrinters[lnI, 2])
	addproperty(loPrinter, 'Driver',      laPrinters[lnI, 3])
	addproperty(loPrinter, 'Comment',     laPrinters[lnI, 4])
	addproperty(loPrinter, 'Location',    laPrinters[lnI, 5])
	This.AvailablePrinters.Add(loPrinter, laPrinters[lnI, 1])
next lnI
return This.AvailablePrinters

ENDPROC
PROCEDURE availableprinters_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tuValue
if This.CalledFromThisClass()
	This.AvailablePrinters = tuValue
else
	error cnERR_PROPERTY_READ_ONLY, 'AvailablePrinters'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE defaultvfpprinter_access
* Because SET('PRINTER', 3) returns the default VFP printer in upper-case,
* we'll check the AvailablePrinters collection so we can return the name in the
* correct case.

local lcName, ;
	loPrinter
lcName    = set('PRINTER', 3)
loPrinter = This.AvailablePrinters.Item(lcName)
if vartype(loPrinter) = 'O'
	lcName = loPrinter.PrinterName
endif vartype(loPrinter) = 'O'
return lcName

ENDPROC
PROCEDURE defaultvfpprinter_assign
* Set the default printer to the specified one if it exists (the string
* "default" can be used to set the printer to the default Windows printer).

lparameters tcPrinterName
do case
	case not vartype(tcPrinterName) = 'C' and not empty(tcPrinterName)
		error cnERR_ARGUMENT_INVALID
	case upper(tcPrinterName) = 'DEFAULT'
		set printer to default
	otherwise
		loPrinter = This.AvailablePrinters.Item(tcPrinterName)
		if vartype(loPrinter) = 'O'
			set printer to name (tcPrinterName)
		endif vartype(loPrinter) = 'O'
endcase

ENDPROC
PROCEDURE defaultwindowsprinter_access
* Because SET('PRINTER', 2) returns the default Windows printer in upper-case,
* we'll check the AvailablePrinters collection so we can return the name in the
* correct case.

local lcName, ;
	loPrinter
lcName = set('PRINTER', 2)
loPrinter = This.AvailablePrinters.Item(lcName)
if vartype(loPrinter) = 'O'
	lcName = loPrinter.PrinterName
endif vartype(loPrinter) = 'O'
return lcName

ENDPROC
PROCEDURE defaultwindowsprinter_assign
* Throw a "property is read-only" error.

lparameters tuValue
error cnERR_PROPERTY_READ_ONLY, 'DefaultWindowsPrinter'

ENDPROC
PROCEDURE Destroy
* Nuke member objects.

This.AvailablePrinters = .NULL.
dodefault()

ENDPROC
PROCEDURE pagesetup
local llReturn
llReturn = sys(1037, 0) = '1'
return llReturn

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>availableprinters A collection of objects containing information about the available printers
defaultvfpprinter The name of the default VFP printer
defaultwindowsprinter The name of the default Windows printer
*availableprinters_access 
*availableprinters_assign 
*defaultvfpprinter_access 
*defaultvfpprinter_assign 
*defaultwindowsprinter_access 
*defaultwindowsprinter_assign 
*pagesetup Displays the Page Setup dialog
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides information about printers</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>printer</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IG0V0WYP</uniqueid>
		<timestamp>884965140</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>info</objname>
		<parent/>
		<properties>comments = 
companyname = 
copyright = 
description = 
internalname = 
version = 
trademarks = 
originalfilename = 
privatebuild = 
productversion = 
specialbuild = 
oleselfregister = 
language = 
translationcode = 
productname = 
directorypath = 
cnamespace = My.App.ApplicationInfo
_memberdata =     1827&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="getapplicationinformation" type="method" display="GetApplicationInformation"/&gt;
&lt;memberdata name="getcurrentapplicationinformation" type="method" display="GetCurrentApplicationInformation"/&gt;
&lt;memberdata name="comments" type="property" display="Comments"/&gt;
&lt;memberdata name="companyname" type="property" display="CompanyName"/&gt;
&lt;memberdata name="copyright" type="property" display="Copyright"/&gt;
&lt;memberdata name="description" type="property" display="Description"/&gt;
&lt;memberdata name="internalname" type="property" display="InternalName"/&gt;
&lt;memberdata name="version" type="property" display="Version"/&gt;
&lt;memberdata name="trademarks" type="property" display="Trademarks"/&gt;
&lt;memberdata name="originalfilename" type="property" display="OriginalFileName"/&gt;
&lt;memberdata name="privatebuild" type="property" display="PrivateBuild"/&gt;
&lt;memberdata name="productversion" type="property" display="ProductVersion"/&gt;
&lt;memberdata name="specialbuild" type="property" display="SpecialBuild"/&gt;
&lt;memberdata name="oleselfregister" type="property" display="OLESelfRegister"/&gt;
&lt;memberdata name="language" type="property" display="Language"/&gt;
&lt;memberdata name="translationcode" type="property" display="TranslationCode"/&gt;
&lt;memberdata name="productname" type="property" display="ProductName"/&gt;
&lt;memberdata name="directorypath" type="property" display="DirectoryPath"/&gt;
&lt;memberdata name="directorypath_access" type="property" display="DirectoryPath_Access"/&gt;
&lt;memberdata name="directorypath_assign" type="property" display="DirectoryPath_Assign"/&gt;
&lt;/VFPData&gt;

Name = "info"
</properties>
		<protected/>
		<methods>PROCEDURE directorypath_access
local lcProgram, ;
	lcPath, ;
	loFSO, ;
	loFolder
with This
	do case

* We already have it.

		case not empty(.DirectoryPath)

* We're running in development mode, so get the path of the running program.
* Note this is returned in upper-case, so use the Scripting.FileSystemObject to
* get the correct case.

		case version(2) = 2
			lcProgram = sys(16)
			lcPath    = justpath(lcProgram)
			if atc('PROCEDURE', lcPath) &gt; 0
				lcPath = substr(lcPath, rat(':', lcPath) - 1)
			endif atc('PROCEDURE', lcPath) &gt; 0
			loFSO          = createobject('Scripting.FileSystemObject')
			loFolder       = loFSO.GetFolder(addbs(lcPath))
			.DirectoryPath = loFolder.Path

* We're running in the runtime.

		otherwise
			.DirectoryPath = addbs(justpath(_vfp.ServerName))
	endcase
endwith
return This.DirectoryPath

ENDPROC
PROCEDURE directorypath_assign
* Save the value if we're doing so from this class. Otherwise, throw a
* "property is read-only" error.

lparameters tcValue
if This.CalledFromThisClass()
	This.DirectoryPath = tcValue
else
	error cnERR_PROPERTY_READ_ONLY, 'DirectoryPath'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE getapplicationinformation
lparameters EXEPath as String
local laFileInfo[1], ;
	lnElements
with This

* Ensure a filename was specified and that the file exists.

	do case
		case vartype(EXEPath) &lt;&gt; 'C' or empty(EXEPath)
			error cnERR_ARGUMENT_INVALID
		case not file(EXEPath)
			error cnERR_FILE_NOT_FOUND

* Get the version information.

		otherwise
			lnElements = agetfileversion(laFileInfo, EXEPath)
			if lnElements &gt; 0
				.Comment          = laFileInfo[ 1]
				.CompanyName      = laFileInfo[ 2]
				.Description      = laFileInfo[ 3]
				.Version          = laFileInfo[ 4]
				.InternalName     = laFileInfo[ 5]
				.Copyright        = laFileInfo[ 6]
				.Trademarks       = laFileInfo[ 7]
				.OriginalFileName = laFileInfo[ 8]
				.PrivateBuild     = laFileInfo[ 9]
				.ProductName      = laFileInfo[10]
				.ProductVersion   = laFileInfo[11]
				.SpecialBuild     = laFileInfo[12]
				.OLESelfRegister  = not empty(laFileInfo[13])
				.Language         = laFileInfo[14]
				.TranslationCode  = laFileInfo[15]
			else
				store '' to .Comment, .CompanyName, .Description, .Version, ;
					.InternalName, .Copyright, .Trademarks, ;
					.OriginalFileName, .PrivateBuild, .ProductName, ;
					.ProductVersion, .SpecialBuild, .Language, .TranslationCode
				.OLESelfRegister = .F.
			endif lnElements &gt; 0
	endcase
endwith

ENDPROC
PROCEDURE getcurrentapplicationinformation
local lcEXE
if version(2) = 2
	lcEXE = sys(16)
	if atc('PROCEDURE', lcEXE) &gt; 0
		lcEXE = substr(lcEXE, rat(':', lcEXE) - 1)
	endif atc('PROCEDURE', lcEXE) &gt; 0
else
	lcEXE = _vfp.ServerName
endif version(2) = 2
This.GetApplicationInformation(lcEXE)

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>comments The application comments
companyname The company name
copyright The copyright
description The application description
internalname The internal name of the application
version The application version number
trademarks The trademarks
originalfilename The original file name
privatebuild The private build
productversion The product version
specialbuild The special build
oleselfregister .T. if the EXE is self-registering
language The language
translationcode The translation code
productname The product name
directorypath The directory the application is running from
*getapplicationinformation Gets information about the specified application
*getcurrentapplicationinformation Gets information about the current application
*directorypath_access 
*directorypath_assign 
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Contains application-specific properties</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>info</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IS0UTJNN</uniqueid>
		<timestamp>884965212</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>data</objname>
		<parent/>
		<properties>cnamespace = My.Data
_memberdata =     1114&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="warning" type="method" display="Warning"/&gt;
&lt;memberdata name="ccaption" type="property" display="cCaption"/&gt;
&lt;memberdata name="errormessage" type="property" display="ErrorMessage"/&gt;
&lt;memberdata name="quietmode" type="property" display="QuietMode"/&gt;
&lt;memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/&gt;
&lt;memberdata name="opencursorsnapshot" type="method" display="OpenCursorSnapshot"/&gt;
&lt;memberdata name="acursors" type="property" display="aCursors"/&gt;
&lt;memberdata name="closeopenedcursors" type="method" display="CloseOpenedCursors"/&gt;
&lt;memberdata name="goto" type="method" display="GoTo"/&gt;
&lt;memberdata name="closeallinstances" type="method" display="CloseAllInstances"/&gt;
&lt;memberdata name="closeallinstancesindatasession" type="method" display="CloseAllInstancesInDataSession"/&gt;
&lt;/VFPData&gt;

Name = "data"
</properties>
		<protected>acursors
closeallinstancesindatasession
</protected>
		<methods>PROCEDURE closeallinstances
lparameters TableName as String
local lcFile, ;
	laSessions[1], ;
	lnSessions, ;
	lnI
if vartype(TableName) = 'C' and not empty(TableName)
	with This
		lcFile     = upper(TableName)
		lnSessions = asessions(laSessions)
		for lnI = lnSessions to 1 step -1
			.CloseAllInstancesInDataSession(lcFile, laSessions[lnI])
		next lnI
	endwith
else
	error cnERR_ARGUMENT_INVALID
endif vartype(TableName) = 'C' ...
return

ENDPROC
PROCEDURE closeallinstancesindatasession
lparameters tcFile, ;
	tnDataSession
local lnDataSession, ;
	lcFullPath, ;
	laTables[1], ;
	lnTables, ;
	lcAlias, ;
	lnI, ;
	lcTable
lnDataSession = set('DATASESSION')
set datasession to tnDataSession
lcFullPath = set('FULLPATH')
set fullpath on
lnTables = aused(laTables)
lcAlias  = strtran(juststem(tcFile), ' ', '_')
for lnI = 1 to lnTables
	lcTable = laTables[lnI, 1]
	if dbf(lcTable) == tcFile or lcTable == tcFile or lcTable == lcAlias
		use in (lcTable)
	endif dbf(lcTable) == tcFile ...
next lnI
if lcFullPath = 'OFF'
	set fullpath off
endif lcFullPath = 'OFF'
set datasession to lnDataSession
return

ENDPROC
PROCEDURE closeopenedcursors
lparameters DataSessionID as Integer
local lnSessions, ;
	laSessions[1], ;
	lnDataSession, ;
	llError, ;
	llDataSession, ;
	laCursors[1], ;
	lnCursors, ;
	lnI, ;
	lcCursor

* If the datasession was passed, save the current one and set the datasession
* to it.

lnSessions    = asessions(laSessions)
lnDataSession = set('DATASESSION')
do case
	case alen(This.aCursors, 2) = 0
		error 'You must call OpenCursorSnapshot before calling CloseOpenedCursors.'
	case pcount() = 1 and (vartype(DataSessionID) &lt;&gt; 'N' or ;
		not between(DataSessionID, 1, lnSessions))
		llError = .T.
		error cnERR_ARGUMENT_INVALID
	case pcount() = 1 and DataSessionID &lt;&gt; lnDataSession
		set datasession to DataSessionID
		llDataSession = .T.
endcase
if not llError

* Get an array of currently open tables and go through them one at a time. If
* the table wasn't open before, close it.

	lnCursors = aused(laCursors)
	for lnI = 1 to lnCursors
		lcCursor = laCursors[lnI, 1]
		if not empty(lcCursor) and ;
			ascan(This.aCursors, lcCursor, -1, -1, 1, 7) = 0
			use in (lcCursor)
		endif not empty(lcCursor) ...
	next lnI

* Restore the former datasession if necessary.

	if llDataSession
		set datasession to DataSessionID
	endif llDataSession
endif not llError
return

ENDPROC
PROCEDURE goto
lparameters RecordNumber as Integer, ;
	Alias as String, ;
	DataSessionID as Integer
local lnSessions, ;
	laSessions[1], ;
	lnDataSession, ;
	llError, ;
	llDataSession, ;
	lcAlias
lnSessions    = asessions(laSessions)
lnDataSession = set('DATASESSION')
do case
	case vartype(RecordNumber) &lt;&gt; 'N'
		llError = .T.
		error cnERR_ARGUMENT_INVALID
	case pcount() = 3 and (vartype(DataSessionID) &lt;&gt; 'N' or ;
		not between(DataSessionID, 1, lnSessions))
		llError = .T.
		error cnERR_ARGUMENT_INVALID
	case pcount() = 3 and DataSessionID &lt;&gt; lnDataSession
		set datasession to DataSessionID
		llDataSession = .T.
	otherwise
		lnDataSession = set('DATASESSION')
endcase
if not llError

* If no alias was passed, use the alias in the current workarea.

	do case
		case vartype(Alias) &lt;&gt; 'C' or empty(Alias)
			lcAlias = alias()
		case not used(Alias)
			error cnERR_ALIAS_NOTFOUND, Alias
			lcAlias = ''
		otherwise
			lcAlias = Alias
	endcase

* Move the record pointer.

	do case
		case empty(lcAlias)
		case RecordNumber &lt; 0 or between(RecordNumber, 1, reccount(lcAlias))
			go RecordNumber in (lcAlias)
		otherwise
			go bottom in (lcAlias)
			if not eof(lcAlias)
				skip in (lcAlias)
			endif not eof(lcAlias)
	endcase

* Restore the former datasession if necessary.

	if llDataSession
		set datasession to DataSessionID
	endif llDataSession
endif not llError
return

ENDPROC
PROCEDURE opencursorsnapshot
lparameters DataSessionID as Integer
local lnSessions, ;
	laSessions[1], ;
	llError, ;
	lnDataSession, ;
	lnCursors, ;
	laCursors[1]
lnSessions = asessions(laSessions)
do case
	case pcount() = 1 and (vartype(DataSessionID) &lt;&gt; 'N' or ;
		not between(DataSessionID, 1, lnSessions))
		llError = .T.
		error cnERR_ARGUMENT_INVALID
	case pcount() = 1
		lnDataSession = DataSessionID
	otherwise
		lnDataSession = set('DATASESSION')
endcase
if not llError
	lnCursors = aused(laCursors, lnDataSession)
	if lnCursors = 0
		dimension This.aCursors[1, 2]
	else
		dimension This.aCursors[lnCursors, 2]
	endif lnCursors = 0
	acopy(laCursors, This.aCursors)
endif not llError

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>*opencursorsnapshot Takes a snapshot of all open cursors so CloseOpenedCursors knows what to close
^acursors[1,0] An array of open cursors
*closeopenedcursors Closes any cursors opened since OpenCursorSnapshot was called
*goto Performs a "safe" GOTO
*closeallinstances Closes all open copies of a given table in all datasessions
*closeallinstancesindatasession Closes all open copies of a given table in the specified datasession
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides data-handling features</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>data</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF18KPWO</uniqueid>
		<timestamp>884966112</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>audio</objname>
		<parent/>
		<properties>cnamespace = My.Computer.Audio
_memberdata =      358&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="playsystemsound" type="method" display="PlaySystemSound"/&gt;
&lt;memberdata name="play" type="method" display="Play"/&gt;
&lt;/VFPData&gt;

Name = "audio"
</properties>
		<protected/>
		<methods>PROCEDURE Destroy
* Remove any API functions we declared.

clear dlls MessageBeep, sndPlaySound
dodefault()

ENDPROC
PROCEDURE play
lparameters SoundFile as String
#define SND_SYNC       0
#define SND_ASYNC      1
#define SND_NODEFAULT  2
#define SND_LOOP       8
#define SND_NOSTOP    16
declare integer sndPlaySound in WinMM.dll string lpszSoundName, integer uFlags
sndPlaySound(SoundFile, SND_ASYNC)

ENDPROC
PROCEDURE playsystemsound
lparameters Sound as String
local lcSound, ;
	lnSound
lcSound = iif(vartype(Sound) = 'C', upper(Sound), '')
do case
	case lcSound = 'QUESTION'
		lnSound = MB_ICONQUESTION
	case lcSound = 'EXCLAMATION'
		lnSound = MB_ICONEXCLAMATION
	case inlist(lcSound, 'INFORMATION', 'ASTERISK')
		lnSound = MB_ICONINFORMATION
	case inlist(lcSound, 'STOP', 'HAND')
		lnSound = MB_ICONSTOP
	otherwise
		lnSound = MB_OK
endcase
declare integer MessageBeep in Win32API integer wType
MessageBeep(lnSound)

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>*playsystemsound Plays the specified system sound
*play Plays the specified WAV file
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Handles the computer's sound system</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>audio</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IF17OBBC</uniqueid>
		<timestamp>896682228</timestamp>
		<class>custom</class>
		<classloc/>
		<baseclass>custom</baseclass>
		<objname>mybase</objname>
		<parent/>
		<properties>Width = 17
_memberdata =      640&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="warning" type="method" display="Warning"/&gt;
&lt;memberdata name="ccaption" type="property" display="cCaption"/&gt;
&lt;memberdata name="errormessage" type="property" display="ErrorMessage"/&gt;
&lt;memberdata name="quietmode" type="property" display="QuietMode"/&gt;
&lt;memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/&gt;
&lt;/VFPData&gt;

cnamespace = 
builder = My.vcx,MyBuilderForm
ccaption = My Framework
errormessage = 
quietmode = .F.
Name = "mybase"
</properties>
		<protected>openmytable
addmembers
warning
calledfromthisclass
Width
Destroy
Init
ClassLibrary
AddObject
AddProperty
BaseClass
Class
CloneObject
Comment
ControlCount
Controls
Error
Height
HelpContextID
NewObject
Objects
ParentClass
Picture
RemoveObject
ResetToDefault
SaveAsClass
ShowWhatsThis
Tag
WhatsThisHelpID
WriteExpression
WriteMethod
</protected>
		<methods>PROCEDURE addmembers
* Add all member objects registered in the My table.

local lnSelect, ;
	lcNameSpace, ;
	lnLen, ;
	lcCursor, ;
	lcANSI, ;
	lcMember, ;
	lcLibrary

* Create a cursor of all objects in this namespace.

lnSelect    = select()
lcNameSpace = upper(This.cNameSpace) + '.'
lnLen       = len(lcNameSpace) + 1
lcCursor    = sys(2015)
lcANSI      = set('ANSI')
set ansi off
select * from __MY where upper(MEMBER) = lcNameSpace and not empty(CLASS) and ;
	not deleted() into cursor (lcCursor)
set ansi &amp;lcAnsi

* Go through the members, adding any that are directly within this namespace
* (for example, if this is "My", we'll add "My.Computers" but not
* "My.Computers.Audio").

scan
	lcMember  = alltrim(substr(MEMBER, lnLen))
	lcLibrary = fullpath(alltrim(LIBRARY), This.ClassLibrary)
	if at('.', lcMember) = 0 and file(lcLibrary)
		This.NewObject(lcMember, alltrim(CLASS), lcLibrary)
	endif at('.', lcMember) = 0 ...
endscan
use
select (lnSelect)

ENDPROC
PROCEDURE calledfromthisclass
*==============================================================================
* Method:			CalledFromThisClass
* Status:			Protected
* Purpose:			Determines if the method that called this method was called
*						from a method of this class or an ancestor
* Parameters:		none
* Returns:			.T. if the method that called this method was called from a
*						method of this class or an ancestor
* Environment in:	none
* Environment out:	none
* Notes:			The reason we want to know if the method that called this
*						method was called from a method of this class or not is
*						to permit "read-only" properties to be changed only by
*						methods of this class. This would typically be called
*						from an Assign method, such as:
*
*					lparameters tuNewValue
*					if This.CalledFromThisClass()
*						This.&lt;property&gt; = tuNewValue
*					else
*						error 1743, '&lt;property&gt;'   &amp;&amp; property is read-only
*					endif This.CalledFromThisClass()
*==============================================================================

local lnLevel, ;
	lcProgram, ;
	lcObject, ;
	loParent, ;
	laClasses[1], ;
	lnClasses, ;
	lnI, ;
	llReturn, ;
	lcThisName

* Get the name of the program that called us, and get the object name from it.
* Set loParent to our parent if there is one.

lnLevel   = program(-1)
lcProgram = iif(lnLevel &gt; 2, upper(program(lnLevel - 2)), '')
lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)

* Check our class hierarchy to see if we were called from ourselves or an
* ancester method.

lnClasses = aclass(laClasses, This)
for lnI = 1 to lnClasses
	if lcObject == upper(laClasses[lnI])
		llReturn = .T.
		exit
	endif lcObject == upper(laClasses[lnI])
next lnI

* If we didn't come from ourselves or an ancestor and we have a parent, our
* name may not match our class, so check the containership hierarchy.

if not llReturn and not isnull(loParent)
	lcThisName = This.Name
	do while vartype(loParent) = 'O'
		lcThisName = loParent.Name + '.' + lcThisName
		loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
			.NULL.)
	enddo while vartype(loParent) = 'O'
	llReturn = upper(lcObject) == upper(lcThisName)
endif not llReturn ...
return llReturn

ENDPROC
PROCEDURE Destroy
* Close the My table.

use in select('__MY')

ENDPROC
PROCEDURE Init
local llReturn
with This

* Set our QuietMode flag based on whether we're in development mode or not.

	.QuietMode = version(2) = 0

* Open the My table. If we succeeded, add all members registered in it.

	llReturn = .OpenMyTable()
	if llReturn
		.AddMembers()
	endif llReturn
endwith
return llReturn

ENDPROC
PROCEDURE openmytable
* Open the My table and return whether we succeeded or not.

local lcDir, ;
	lcTable, ;
	llReturn, ;
	loException as Exception
lcDir   = sys(16)
lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
lcTable = lcDir + 'My.DBF'
if used('__MY')
	llReturn = .T.
else
	try
		use (lcTable) again shared order MEMBER alias __MY in 0
		llReturn = .T.
	catch to loException
		This.Warning('Cannot open ' + lcTable + '. The error message is:' + ;
			ccCR + ccCR + loException.Message)
		llReturn = .F.
	endtry
endif used('__MY')
return llReturn

ENDPROC
PROCEDURE warning
* Display a warning message.

lparameters tcMessage
if not This.QuietMode
	messagebox(tcMessage, MB_ICONEXCLAMATION, This.cCaption)
endif not This.QuietMode
This.ErrorMessage = tcMessage

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>_memberdata XML Metadata for customizable properties
cnamespace The name space for this object
builder The builder to use
ccaption The title for any MESSAGEBOX dialogs
errormessage The text of any error that occurred
quietmode .T. if we should not display any error messages
*openmytable Opens the My table
*addmembers Adds the member objects specified in the My table
*warning Gives a warning message
*calledfromthisclass Determines if a method was called from another method in this class or not
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>The base class for My namespace classes</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>mybase</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_0C41E56MK</uniqueid>
		<timestamp>911774742</timestamp>
		<class>custom</class>
		<classloc/>
		<baseclass>custom</baseclass>
		<objname>myfoxcode</objname>
		<parent/>
		<properties>Width = 17
_memberdata =      674&lt;VFPData&gt;
&lt;memberdata name="main" type="method" display="Main"/&gt;
&lt;memberdata name="getmembers" type="method" display="GetMembers"/&gt;
&lt;memberdata name="getmymember" type="method" display="GetMyMember"/&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="handlelocal" type="method" display="HandleLOCAL"/&gt;
&lt;memberdata name="displaymembers" type="method" display="DisplayMembers"/&gt;
&lt;memberdata name="displayenumeratedvalues" type="method" display="DisplayEnumeratedValues"/&gt;
&lt;memberdata name="openintellisense" type="method" display="OpenIntelliSense"/&gt;
&lt;memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/&gt;
&lt;/VFPData&gt;

lerroroccurred = .F.
Name = "myfoxcode"
</properties>
		<protected>getmymember
openmytable
handlelocal
displaymembers
displayenumeratedvalues
openintellisense
</protected>
		<methods>PROCEDURE Destroy
* Close the tables we opened.

use in select('__MY')
use in select('__FOXCODE')

ENDPROC
PROCEDURE displayenumeratedvalues
lparameters toFoxCode, ;
	toData
local laLines[1], ;
	lnLines, ;
	lnI, ;
	lcLine, ;
	lnPos, ;
	lcDescrip
with toFoxCode
	lnLines = alines(laLines, toData.List)
	dimension .Items[lnLines, 2]
	for lnI = 1 to lnLines
		lcLine = laLines[lnI]
		lnPos  = at(',', lcLine)
		if lnPos &gt; 0
			lcDescrip = alltrim(substr(lcLine, lnPos + 1))
			lcLine    = alltrim(left(lcLine, lnPos - 1))
		else
			lcDescrip = ''
		endif lnPos &gt; 0
		.Items[lnI, 1] = lcLine
		.Items[lnI, 2] = lcDescrip
	next lnI
	.ValueType  = 'L'
	.ItemScript = 'funcmenu'
endwith

ENDPROC
PROCEDURE displaymembers
* Builds a list of members for IntelliSense to display.

lparameters toFoxCode, ;
	toData
local loMembers, ;
	lcPath, ;
	lnI, ;
	loMember
with toFoxCode

* Get a collection of members for the current class.

	loMembers = This.GetMembers(alltrim(toData.Member))
	if loMembers.Count &gt; 0

* Add each member to the Items array of the FoxCode object.

		dimension .Items[loMembers.Count, 2]
		lcPath = iif(file('propty.bmp'), '', home() + 'FFC\Graphics\')
		for lnI = 1 to loMembers.Count
			loMember       = loMembers.Item(lnI)
			.Items[lnI, 1] = loMember.Name
			.Items[lnI, 2] = loMember.Description
			if loMember.Type = 'P'
				.Icon = lcPath + 'propty.bmp'
			else
				.Icon = lcPath + 'method.bmp'
			endif loMember.Type = 'P'
		next loMember

* Set the FoxCode object's ValueType property to "L", meaning display a listbox
* containing the items defined in the Items array.

		.ValueType = 'L'
	endif loMembers.Count &gt; 0
endwith

ENDPROC
PROCEDURE Error
lparameters tnError, ;
	tcMethod, ;
	tnLine
local laError[1], ;
	lcMessage
aerror(laError)
This.lErrorOccurred = .T.
lcMessage = ccERR_ERROR_MESSAGE_LOC
lcMessage = strtran(lcMessage, '{1}', transform(tnError))
lcMessage = strtran(lcMessage, '{2}', laError[2])
lcMessage = strtran(lcMessage, '{3}', transform(tnLine))
lcMessage = strtran(lcMessage, '{4}', tcMethod)
messagebox(lcMessage, MB_ICONEXCLAMATION, ccCAP_MY_FOXCODE_LOC)

ENDPROC
PROCEDURE getmembers
* Fill a collection with the members of the namespace found in the My registry
* table.

lparameters tcNameSpace
local loCollection, ;
	lnSelect, ;
	lcNameSpace, ;
	lnLen, ;
	lcCursor, ;
	lcMember, ;
	loMember
loCollection = createobject('Collection')
lnSelect     = select()
lcNameSpace  = upper(tcNameSpace) + '.'
lnLen        = len(lcNameSpace) + 1
lcCursor     = sys(2015)
select * from __My where upper(MEMBER) = lcNameSpace and not deleted() ;
	into cursor (lcCursor)
scan
	lcMember = alltrim(substr(MEMBER, lnLen))
	if at('.', lcMember) = 0
		loMember = createobject('Empty')
		addproperty(loMember, 'Name',        lcMember)
		addproperty(loMember, 'Description', alltrim(DESCRIP))
		addproperty(loMember, 'Type',        TYPE)
		loCollection.Add(loMember)
	endif at('.', lcMember) = 0
endscan
use
select (lnSelect)
return loCollection

ENDPROC
PROCEDURE getmymember
* Determine which member of the namespace the user typed and return a SCATTER
* NAME object from the appropriate record in the FFI table.

lparameters tcUserTyped, ;
	tcNameSpace
local loReturn, ;
	lcUserTyped, ;
	llFound, ;
	lnPos, ;
	lcMember, ;
	lnSelect

* Grab what the user typed. If it ends with an opening parenthesis, strip that
* off.

loReturn    = .NULL.
lcUserTyped = alltrim(tcUserTyped)
if right(lcUserTyped, 1) = '('
	lcUserTyped = substr(lcUserTyped, len(lcUserTyped) - 1)
endif right(lcUserTyped, 1) = '('

* Find the record for the class in the My table. If there's a period in the
* typed text, try to find a record for the member.

if seek(upper(padr(tcNameSpace, len(__My.CLASS))), '__My', 'MEMBER')
	llFound = .T.
	lnPos   = at('.', lcUserTyped)
	if lnPos &gt; 0
		lcMember = alltrim(__My.MEMBER) + substr(lcUserTyped, lnPos)
		llFound  = seek(upper(padr(lcMember, len(__My.MEMBER))), '__My', ;
			'MEMBER')
	endif lnPos &gt; 0

* If we found the desired record, create a SCATTER NAME object for it.

	if llFound
		lnSelect = select()
		select __My
		scatter memo name loReturn
		select (lnSelect)
	endif llFound
endif seek(upper(padr(tcNameSpace ...
return loReturn

ENDPROC
PROCEDURE handlelocal
* Handle being triggered from the LOCAL AS statement.

lparameters toFoxCode, ;
	tcNameSpace, ;
	tcClass, ;
	tcLibrary
local lcCode, ;
	lcCase, ;
	lcVariable, ;
	lcReturn
with toFoxCode
	lcCode = 'NEWOBJECT'
	lcCase = ''

* Open the IntelliSense table and find the record for the NEWOBJECT function.
* If we did, get the case we're supposed to use. If it specifies the default
* IntelliSense case, get that from the V record.

	if This.OpenIntelliSense() and seek('FNEWO', '__FOXCODE', 1)
		lcCase = __FOXCODE.CASE
		lcCode = alltrim(__FOXCODE.EXPANDED)
		if empty(lcCase) and seek('V', '__FOXCODE', 1)
			lcCase = __FOXCODE.CASE
		endif empty(lcCase) ...
	endif This.OpenIntelliSense() ...

* Handle the case as specified.

	do case
		case lcCase = 'U'
			lcCode = upper(lcCode)
		case lcCase = 'L'
			lcCode = lower(lcCode)
		case lcCase = 'P'
			lcCode = proper(lcCode)
	endcase

* Get the variable name the user typed in the LOCAL VariableName AS statement,
* then construct the code we want inserted and set the ValueType property of
* the FoxCode object to "V" so it inserts this string.

	lcVariable = substr(.FullLine, rat(' ', .FullLine) + 1)
*** Note: we'll use KEYBOARD rather than including the code to add in lcReturn
*** so the code is indented properly if necessary
***	lcReturn   = tcNameSpace + chr(13) + lcVariable + ' = ' + lcCode + "('" + ;
		tcClass + "', '" + tcLibrary + "')" + chr(13)
	lcReturn   = tcNameSpace
	if not This.lErrorOccurred
		keyboard chr(13) + lcVariable + ' = ' + lcCode + "('" + ;
			tcClass + "', '" + tcLibrary + "')" + chr(13) plain
	endif not This.lErrorOccurred
	.ValueType = 'V'
endwith
return lcReturn

ENDPROC
PROCEDURE Init
* Turn debugging on.

sys(2030, 1)

* Open the My table.

local llReturn
llReturn = This.OpenMyTable()
if not llReturn
	messagebox(ccERR_COULD_NOT_OPEN_MY_LOC, MB_ICONEXCLAMATION, ;
		ccCAP_MY_FOXCODE_LOC)
endif not llReturn
return llReturn

ENDPROC
PROCEDURE main
* This is main routine that gets called from the IntelliSense script for My.

lparameters toFoxCode
local lcNameSpace, ;
	loData, ;
	lcReturn, ;
	lcTrigger
with toFoxCode
	.ValueType = 'V'

* Get the namespace and an object from the My table for that namespace.

	lcNameSpace = .Data
	loData      = This.GetMyMember(.UserTyped, lcNameSpace)
	lcReturn    = ''
	do case

* We couldn't figure out which member was specified.

		case vartype(loData) &lt;&gt; 'O'

* If we're on the LOCAL statement, handle that by returning text we want
* inserted.

		case atc(lcNameSpace, .MenuItem) &gt; 0
			lcReturn = This.HandleLOCAL(toFoxCode, lcNameSpace, ;
				trim(loData.Class), trim(loData.Library))

* Other IntelliSense. Start by getting the character that triggered
* IntelliSense.

		otherwise
			lcTrigger = right(.FullLine, 1)
			do case

* If we were triggered by a ".", display a list of members.

				case lcTrigger = '.'
					This.DisplayMembers(toFoxCode, loData)

* If we were triggered by a "(" (to start a method parameter list) and the
* method accepts enumerated values specified in the LIST memo, display them.

				case lcTrigger = '(' and not empty(loData.List)
					This.DisplayEnumeratedValues(toFoxCode, loData)

* If we were triggered by a "(" (to start a method parameter list), an "="
* (for a property), or "," (to enter a new parameter) and we have a script,
* execute it.

				case inlist(lcTrigger, '=', '(', ',') and ;
					not empty(loData.Script)
					lcReturn = execscript(loData.Script, toFoxCode, loData)

* If we were triggered by a "(" (to start a method parameter list) or "," (to
* enter a new parameter), display the parameters for the method.

				case inlist(lcTrigger, '(', ',') and not empty(loData.Tip)
					.ValueTip  = loData.Tip
					.ValueType = 'T'
			endcase
	endcase
endwith
return lcReturn

ENDPROC
PROCEDURE openintellisense
local lcDir, ;
	lcTable, ;
	llReturn
if used('__FOXCODE')
	llReturn = .T.
else
	try
		use (_foxcode) again shared alias __FOXCODE in 0
		llReturn = .T.
	catch to loException
		llReturn = .F.
	endtry
endif used('__FOXCODE')
return llReturn

ENDPROC
PROCEDURE openmytable
local lcDir, ;
	lcTable, ;
	llReturn
lcDir   = sys(16)
lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
lcTable = lcDir + 'my.dbf'
if used('__MY')
	llReturn = .T.
else
	try
		use (lcTable) again shared alias __MY in 0
		llReturn = .T.
	catch to loException
		llReturn = .F.
	endtry
endif used('__MY')
return llReturn

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>_memberdata XML Metadata for customizable properties
lerroroccurred .T. if an error occurred
*getmembers This code returns methods used for Intellisense
*main Main routine that gets called by IntelliSense engine.
*getmymember Finds the record in the My table matching the member or method the user typed so far
*openmytable Opens the My table
*handlelocal Called when we were triggered in IntelliSense from the LOCAL AS statement
*displaymembers Builds a list of members for IntelliSense to display
*displayenumeratedvalues Builds a list of enumerated values for IntelliSense to display
*openintellisense Opens the IntelliSense table
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>The IntelliSense handler for the My namespace</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>myfoxcode</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
	<record>
		<platform>WINDOWS</platform>
		<uniqueid>_1IG0W04T0</uniqueid>
		<timestamp>925195054</timestamp>
		<class>mybase</class>
		<classloc>my.vcx</classloc>
		<baseclass>custom</baseclass>
		<objname>settings</objname>
		<parent/>
		<properties>osettings = .NULL.
_memberdata =      578&lt;VFPData&gt;
&lt;memberdata name="openmytable" type="method" display="OpenMyTable"/&gt;
&lt;memberdata name="addmembers" type="method" display="AddMembers"/&gt;
&lt;memberdata name="cnamespace" type="property" display="cNameSpace"/&gt;
&lt;memberdata name="builder" type="property" display="Builder"/&gt;
&lt;memberdata name="load" type="method" display="Load"/&gt;
&lt;memberdata name="save" type="method" display="Save"/&gt;
&lt;memberdata name="osettings" type="property" display="oSettings"/&gt;
&lt;memberdata name="add" type="method" display="Add"/&gt;
&lt;memberdata name="exists" type="method" display="Exists"/&gt;
&lt;/VFPData&gt;

cnamespace = My.Settings
Name = "settings"
</properties>
		<protected>osettings
</protected>
		<methods>PROCEDURE add
* Add a new setting to our collection and as a property.

lparameters SettingName as String, Value as Variant
local loException as Exception
if vartype(SettingName) &lt;&gt; 'C' or empty(SettingName) or vartype(Value) = 'O'
	error cnERR_ARGUMENT_INVALID
else
	try
		This.oSettings.Add(SettingName, SettingName)
		This.AddProperty(SettingName, Value)
	catch to loException when loException.ErrorNo = cnERR_KEY_EXISTS
		store Value to ('This.' + SettingName)
	catch to loException
		throw
	endtry
endif vartype(SettingName) &lt;&gt; 'C' ...

ENDPROC
PROCEDURE Destroy
* Nuke member objects.

This.oSettings = .NULL.
dodefault()

ENDPROC
PROCEDURE exists
* Return .T. if the specified setting exists.

lparameters SettingName as String
local llReturn
if vartype(SettingName) &lt;&gt; 'C' or empty(SettingName)
	error cnERR_ARGUMENT_INVALID
	llReturn = .F.
else
	llReturn = This.oSettings.GetKey(SettingName) &gt; 0
endif vartype(SettingName) &lt;&gt; 'C' ...
return llReturn

ENDPROC
PROCEDURE Init
* Create a collection of setting names.

This.oSettings = newobject('MyCollection', 'My.vcx')
dodefault()

ENDPROC
PROCEDURE load
* Load the specified settings file.

lparameters SettingsFile as String
local loDOM, ;
	loNodes, ;
	loNode, ;
	lcName, ;
	lcType, ;
	loValue, ;
	lcValue, ;
	lnPos, ;
	lnDigits, ;
	lnDec, ;
	llReturn
do case

* We weren't passed a valid file name, so give an error and exit.

	case vartype(SettingsFile) &lt;&gt; 'C' or empty(SettingsFile)
		error cnERR_ARGUMENT_INVALID
	case not file(SettingsFile)
		error cnERR_FILE_NOT_FOUND, SettingsFile
	otherwise

* Create an MSXML DOMDocument object and load the XML.

		try
			loDOM = createobject('MSXML2.DOMDocument.3.0')
			loDOM.async = .F.
			loDOM.load(SettingsFile)
		catch to loException
			loDOM = .NULL.
		endtry
		do case

* We couldn't create the object.

			case vartype(loDOM) &lt;&gt; 'O'
				error 'Could not create MSXML DOMDocument object'

* The XML was loaded, so parse it into individual settings.

			case loDOM.parseError.errorCode = 0
				loNodes = loDOM.selectNodes('/SettingsFile/Settings/Setting')
				for each loNode in loNodes
					lcName  = loNode.getAttribute('Name')
					lcType  = loNode.getAttribute('Type')
					loValue = loNode.selectSingleNode('Value')
					lcValue = loValue.text
					do case
						case lcType = ccSTRING
							lcType = 'C(' + transform(len(lcValue)) + ')'
						case lcType = ccINTEGER
							lcType = 'I'
						case lcType = ccBOOLEAN
							lcType = 'L'
						case lcType = ccDOUBLE
							lnPos    = at('.', lcValue)
							lnDigits = len(lcValue)
							lnDec    = iif(lnPos &gt; 0, len(lcValue) - lnPos, 0)
							lcType   = 'N(' + transform(lnDigits) + ',' + ;
								transform(lnDec) + ')'
						case lcType = ccCURRENCY
							lcType = 'Y'
					endcase
					try
						luValue = cast(lcValue as &amp;lcType)
						This.Add(lcName, luValue)
					catch to loException
						throw
					endtry
				next loNode
				llReturn = .T.
		endcase
endcase
return llReturn

ENDPROC
PROCEDURE save
lparameters SettingsFile as String
local loDOM, ;
	loInstruction, ;
	loRoot, ;
	loBlank, ;
	loProfiles, ;
	loSettings, ;
	lcName, ;
	luValue, ;
	lcType, ;
	loSetting, ;
	lcValue

* We weren't passed a valid file name, so give an error and exit.

if vartype(SettingsFile) &lt;&gt; 'C' or empty(SettingsFile)
	error cnERR_ARGUMENT_INVALID
else

* Create an MSXML DOMDocument object.

	try
		loDOM = createobject('MSXML2.DOMDocument.3.0')
	catch to loException
		loDOM = .NULL.
	endtry
	if vartype(loDOM) = 'O'

* Create the root and other nodes.

		loDOM.preserveWhiteSpace = .T.
		loInstruction = loDOM.createProcessingInstruction('xml', ;
			'version="1.0" encoding="utf-8"')
		loDOM.appendChild(loInstruction)
		loRoot = loDOM.createElement('SettingsFile')
		loRoot.setAttribute('xmlns', ;
			'http://schemas.microsoft.com/VisualStudio/2004/01/settings')
		loRoot.setAttribute('CurrentProfile', '(Default)')
		loRoot.setAttribute('GeneratedClassNamespace', '')
		loRoot.setAttribute('GeneratedClassName', 'Settings')
		loDOM.appendChild(loRoot)
		loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9))
		loRoot.appendChild(loBlank)
		loProfiles = loDOM.createElement('Profiles')
		loRoot.appendChild(loProfiles)
		loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9))
		loRoot.appendChild(loBlank)
		loSettings = loDOM.createElement('Settings')
		loRoot.appendChild(loSettings)
		loBlank = loDOM.createTextNode(chr(13) + chr(10))
		loRoot.appendChild(loBlank)

* Create nodes for each setting.

		for each lcName in This.oSettings
			luValue   = evaluate('This.' + lcName)
			lcType    = vartype(luValue)
			loSetting = loDOM.createElement('Setting')
			loSetting.setAttribute('Name', lcName)
			do case
				case lcType = 'C'
					lcType  = ccSTRING
					lcValue = luValue
				case lcType = 'N' and '.' $ transform(luValue)
					lcType  = ccDOUBLE
					lcValue = transform(luValue)
				case lcType = 'N'
					lcType  = ccINTEGER
					lcValue = transform(luValue)
				case lcType = 'L'
					lcType  = ccBOOLEAN
					lcValue = iif(luValue, 'True', 'False')
				case lcType = 'Y'
					lcType  = ccCURRENCY
					lcValue = transform(luValue)
			endcase
			loSetting.setAttribute('Type',  lcType)
			loSetting.setAttribute('Scope', 'User')
			loValue = loDOM.createElement('Value')
			loValue.setAttribute('Profile', '(Default)')
			loValue.text = lcValue
			loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9) + ;
				chr(9) + chr(9))
			loSetting.appendChild(loBlank)
			loSetting.appendChild(loValue)
			loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9) + chr(9))
			loSetting.appendChild(loBlank)
			loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9) + chr(9))
			loSettings.appendChild(loBlank)
			loSettings.appendChild(loSetting)
		next lcName

* Add some additional formatting.

		loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9))
		loSettings.appendChild(loBlank)

* Save the XML to the settings file.

		loDOM.Save(SettingsFile)
	endif vartype(loDOM) = 'O'
endif vartype(SettingsFile) &lt;&gt; 'C' ...

ENDPROC
</methods>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1>Class</reserved1>
		<reserved2>1</reserved2>
		<reserved3>osettings A collection of settings
*load Loads the settings from the specified file
*save Saves the settings to the specified file
*add Adds a new setting
*exists Returns .T. if the specified setting exists
</reserved3>
		<reserved4/>
		<reserved5/>
		<reserved6>Pixels</reserved6>
		<reserved7>Provides application settings</reserved7>
		<reserved8>myconstants.h</reserved8>
		<user/>
	</record>
	<record>
		<platform>COMMENT</platform>
		<uniqueid>RESERVED</uniqueid>
		<timestamp>0</timestamp>
		<class/>
		<classloc/>
		<baseclass/>
		<objname>settings</objname>
		<parent/>
		<properties/>
		<protected/>
		<methods/>
		<objcode/>
		<ole/>
		<ole2/>
		<reserved1></reserved1>
		<reserved2/>
		<reserved3/>
		<reserved4/>
		<reserved5/>
		<reserved6/>
		<reserved7/>
		<reserved8/>
		<user/>
	</record>
</VFPData>
