****** * D:\DEVELOP\WORK\BASIS\STARTUP.PRG
*:******************************************************************************
*:
*: Procedure File D:\DEVELOP\WORK\BASIS\STARTUP.PRG
*:
*:	ГлуховВ.ВовкО.БоярскихВ.АлдушинД.
*:	Система. Бизнес. Автоматизация.
*:	
*:	Екатеринбург
*:	
*:	620100
*:	Россия
*:	
*:	
*:	
*:	
*:	
*:	
*:
*: Documented using Visual FoxPro Formatting wizard version  .05
*:******************************************************************************
*:   STARTUP
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: BASIS.PRG
* Module/Procedure: BASIS()
* Called by.......: <NA>
* Parameters......: <none>
* Returns.........: <none>
* Notes...........: Главная программа
*-------------------------------------------------------
Lparameters luParamString

*01.05.2004 20:00 ->Для определения запускаемого приложения используем константы
#Define cnAPPLICATION_NAME	BASIS
*------------------------------------------------------------------------------
*SYS(2800 ,3 )

*01.05.2004 19:51 ->Объявление и инициализация переменных
Local	lcExecuteProgram, ;
	lcExecuteProgramExtension, ;
	lcExecuteProgramPath, ;
	lcApplicationNM, ;
	lcApplicationClassLib, ;
	lcApplicationIniFNM, ;
	llDebugModeFlg, ;
	llLibLoad
***
lcExecuteProgram = Sys(16)
lcExecuteProgramExtension = Upper(Right(lcExecuteProgram,3))
lcExecuteProgramPath = Upper(Substr(lcExecuteProgram,1,Rat([\],lcExecuteProgram)))
***
lcApplicationNM = [cnAPPLICATION_NAME]
lcApplicationClassLib = lcApplicationNM + [.VCX]
lcApplicationIniFNM = lcExecuteProgramPath + lcApplicationNM + [.INI]
*------------------------------------------------------------------------------

*14.08.2006 11:18 ->Распахнем окно на весь экран
_Screen.WindowState = 2
*------------------------------------------------------------------------------
*PUBLIC llDebugModeFlg
*02.05.2004 15:00 ->Проверим режим запуска
If Inlist(lcExecuteProgramExtension,[EXE],[APP],[DLL])
	llDebugModeFlg = .F.
Else
	llDebugModeFlg = .T.
Endif
*------------------------------------------------------------------------------

*02.05.2004 15:47 ->Перейдем в каталог приложения и установим необходимые пути
If lcExecuteProgramPath # Fullpath(Curdir())
	Cd (lcExecuteProgramPath)
Endif
***
If !llDebugModeFlg
	Set Path To [Tmp;ImgBmp;ImgIco;Resource;Data;Drivers]
Else
	Set Path To [Tmp;ImgBmp;ImgIco;Resource;Graphic;Library;Menu;Program;Data;Drivers]
	Close Databases All
Endif
*------------------------------------------------------------------------------

*02.05.2004 15:47 ->Создадим объект для работы с окружением
If !([GENERAL_V1.VCX]$Set([CLASSLIB]))
	Set Classlib To GENERAL_V1.vcx Alias GENERAL_V1 Additive
	llLibLoad = .T.
Else
	llLibLoad = .F.
Endif
oEnv = Createobject([environment],llDebugModeFlg)
If llLibLoad
	Release Classlib Alias GENERAL_V1
Endif
*------------------------------------------------------------------------------

*02.05.2004 15:48 ->Создадим объект для работы с INI файлами
If !([GENERAL_V1.VCX]$Set([CLASSLIB]))
	Set Classlib To GENERAL_V1.vcx Alias GENERAL_V1 Additive
	llLibLoad = .T.
Else
	llLibLoad = .F.
Endif
oRes = Createobject([resource],lcApplicationIniFNM)
If llLibLoad
	Release Classlib Alias GENERAL_V1
Endif
*------------------------------------------------------------------------------

*02.05.2004 15:48 ->Создадим объект для работы с параметрами выборок
If !([QUERYPARAMIO_V1.VCX]$Set([CLASSLIB]))
	Set Classlib To QUERYPARAMIO_V1.vcx Alias QUERYPARAMIO_V1 Additive
	llLibLoad = .T.
Else
	llLibLoad = .F.
Endif
oQryParMgr = Createobject([QueryParamMgr])
If llLibLoad
	Release Classlib Alias QUERYPARAMIO_V1
Endif
*------------------------------------------------------------------------------

*14.09.2005 10:08 -> Создадим объект для работы со штрих-кодами
If !([TOVARLOOKUP_V1.VCX]$Set([CLASSLIB]))
	Set Classlib To TOVARLOOKUP_V1.vcx Alias TOVARLOOKUP_V1 Additive
	llLibLoad = .T.
Else
	llLibLoad = .F.
Endif
oTLU = Createobject([TovarLookUp])
If llLibLoad
	Release Classlib Alias TOVARLOOKUP_V1
Endif
*------------------------------------------------------------------------------

*02.05.2004 15:52 ->Создаем объект приложения
If !(lcApplicationClassLib$Set([CLASSLIB]))
	Set Classlib To (lcApplicationClassLib) Alias (lcApplicationNM) Additive
	llLibLoad = .T.
Else
	llLibLoad = .F.
Endif
oApp = Createobject(lcApplicationNM,llDebugModeFlg)
If llLibLoad
	Release Classlib Alias (lcApplicationNM)
Endif
*------------------------------------------------------------------------------

*19.01.2005 15:39 -> Создаем объекты менеджеры
If Type([oApp]) == [O]
	oMgrClient   = oApp.Createobject([interface;client_v1;client.app])
	oMgrTovar    = oApp.Createobject([interface;tovar_v1;tovar.app])
	oMgrPD 	     = oApp.Createobject([interface;primarydoc_v1;primarydoc.app])
	oMgrRpt      = oApp.Createobject([interface;report_v1;report.app])
	oMgrFormType = oApp.Createobject([interface;formtype_v1;formtype.app])
	oMgrOrgUnit  = oApp.Createobject([interface;orgunit_v1;orgunit.app])
	oMgrQryPar   = oApp.Createobject([interface;queryparam_v1;queryparam.app])
	oMgrScrFrm   = oApp.Createobject([interface;screenform_v1;screenform.app])
	oMgrDevice	 = oApp.Createobject([interface;device_v1;device.app])
	oMgrCash	 = oApp.Createobject([interface;cash_v1;cash.app])
	oMgrDisc	 = oApp.Createobject([interface;discount_v1;discount.app])
	oMgrUser	 = oApp.Createobject([interface;user_v1;user.app])
	oMgrPOS		 = oApp.Createobject([interface;poscfg_v1;poscfg.app])
	oMgrCoupon	 = oApp.Createobject([interface;coupon_v1;coupon.app])
	oMgrPBook	 = oApp.Createobject([interface;pbook_v1;pbook.app])
	oMgrAdmin	 = oApp.Createobject([interface;admin;admin.app])
	oMgrCard	 = oApp.Createobject([interface;card_v1;card.app])
	oSession	 = Newobject([WorkSession],[Messenger.prg])
Endif
*------------------------------------------------------------------------------

*02.05.2004 16:02 ->Запускаем приложение
If Type([oApp]) == [O]
	oApp.STARTUP()
Endif
*------------------------------------------------------------------------------

*******************************************************************************
*После того, как приложение отработало удаляем объекты в нужной нам последовательности
*******************************************************************************
Release oSession
Release oMgrAdmin
Release oMgrPBook
Release oMgrClient
Release oMgrTovar
Release oMgrPD
Release oMgrRpt
Release oMgrFormType
Release oMgrOrgUnit
Release oMgrQryPar
Release oMgrScrFrm
Release oMgrDevice
Release oMgrCash
Release oMgrDisc
Release oMgrUser
Release oMgrPOS
Release oMgrCoupon
Release oApp
Release oTLU
Release oQryParMgr
Release oRes
Release oEnv
*------------------------------------------------------------------------------
Sys(2800 ,0 )

*02.05.2004 16:03 ->Очистим память занимаемую всеми другими объектами
Clear All
*------------------------------------------------------------------------------

************************************************************************************
**********************************  END PROCEDURE **********************************
************************************************************************************
****** * D:\БАЗЫ КЛИЕНТОВ\БАЗЫ УРАЛЬСКОЙ ФАКТОРИИ\UNION PROV_ALL.PRG
*:******************************************************************************
*:
*: Procedure File D:\БАЗЫ КЛИЕНТОВ\БАЗЫ УРАЛЬСКОЙ ФАКТОРИИ\UNION PROV_ALL.PRG
*:
*:	ГлуховВ.ВовкО.БоярскихВ.АлдушинД.
*:	Система. Бизнес. Автоматизация.
*:	
*:	Екатеринбург
*:	
*:	620100
*:	Россия
*:	
*:	
*:	
*:	
*:	
*:	
*:
*: Documented using Visual FoxPro Formatting wizard version  .05
*:******************************************************************************
*:   UNION PROV_ALL
Set Path To Data;Forms;LIBS;Menu;PROGS;REPORTS;QUERIES;;
	LABELS;Other;Tmp;\\Server\Base\INTELL.VID\BASIS\Data;;
	"d:\базы уральской фактории"









**************************
**************************
**************************
**** Замена в форм типа


***TOP 10






Insert Into BASIS!Form (FrmTypeId, FrmDate, FrmDateAcc, FrmReason, FrmNote, ;
	FrmNum, PointEmiCltID, PointIspCltID, ContrCltID, ID_,  ;
	FrmStatusID, FrmIsPayed, FrmAttribute ) ;
	SELECT 35, Dat_pr, Dat_pr, Alltrim(Text), Alltrim(id_docum), ;
	ALLTRIM(Str(Summa,16,2)), Client.cltid, Client.cltid, Client.cltid, Kkey,  ;
	2, .T., 0 From bu_all ;
	INNER Join BASIS!Client On  bu_all.kod_k = Client.ID_ ;
	ORDER By Dat_pr

Requery('form')

Insert Into BASIS!PracticalBook (PBookFrmId, PBookSum, DebetID, CreditID, PBookNote) ;
	SELECT Form.frmid, prov_all_deno.Summ, prov_all_deno.DebetID, prov_all_deno.CreditID,;
	prov_all_deno.Note ;
	FROM BASIS!Form ;
	LEFT Outer Join prov_all_deno On  Form.ID_ = prov_all_deno.Kkey ;
	WHERE Form.FrmTypeId = 35 And Form.ID_<>0

****** * D:\DEVELOP\WORK\DEMO\KOLCOVO\BASIS.DBC
#Define	pcvCONNECTIONNAME	[SQLBASISCONNECTION]
#Define	pcvLOCKTIMEOUT		[10000]
#Define	pcvERRORHEADMSG		"[Microsoft][ODBC SQL Server Driver][SQL Server]"

*02.08.2005 16:58 ->Константы для маркированнных списков (наборов)
#Define	NOT_CHILD_MARKED		0
#Define	ALL_CHILD_MARKED		1
#Define	PART_CHILD_MARKED		2
*------------------------------------------------------------------------------

*12.07.2005 14:39 ->Константы - заполнители полей
#Define	__INTEGER	00000000000
#Define __FLOAT		00000000000.000
*------------------------------------------------------------------------------

*-------------------------------------------------------
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: dbc_AfterOpenTable()
* Called by.......: <DBC Event>
* Parameters......: <tcTableName>
* Returns.........: <none>
* Notes...........:
*------------------------------------------------------------------------------
Procedure dbc_AfterOpenTable(tcTableName)

	*31.03.2006 16:50 ->Объявление и инициализация переменных
	Local	lnConnHandler, ;
		lnSqlExeResult, lcTbl4
	lcTbl4 = Upper(Substr(Alltrim(tcTableName),1,4))
	If lcTbl4 = 'EDEL' Or lcTbl4 = 'BOLI'
		Return
	Endif
	lnConnHandler = -1
	*------------------------------------------------------------------------------
	**WAIT WINDOW 1
	*31.03.2006 16:51 -> Получим номер Connection
	If CursorGetProp([SourceType],tcTableName) = 2 && Remote View
		lnConnHandler = CursorGetProp([ConnectHandle],tcTableName)
	Endif
	*------------------------------------------------------------------------------

	*31.03.2006 16:52 -> Создадим временную таблицу для хранения ID
	If lnConnHandler > 0
		lnSqlExeResult = 0
		Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
			lnSqlExeResult = SQLExec(lnConnHandler, ;
				[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
				[IF OBJECT_ID('tempdb..#LastIncrID') IS NULL CREATE TABLE #LastIncrID (TableNM varchar(40), LastID INT)])
		Enddo
		***
		If lnSqlExeResult = -1
			spHandleODBCError()
			Return
		Endif
	Endif
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: GetServerDate()
* Called by.......: <>
* Parameters......: <none>
* Returns.........: <none>
* Notes...........: <Получение даты с сервера>
*------------------------------------------------------------------------------
Procedure GetServerDate
	*31.03.2006 16:50 ->Объявление и инициализация переменных
	Local	lnConnectHandle, ;
		lnSqlExeResult, ;
		ltServerDate As Datetime
	*------------------------------------------------------------------------------

	*28.03.2007 12:10 ->Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*28.03.2007 12:10 ->Получаем дату с сервера
	If lnConnectHandle > 0
		lnSqlExeResult = 0
		Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
			lnSqlExeResult = SQLExec(lnConnectHandle, ;
				[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
				[SELECT GETDATE() AS GetDate],[curGetDate])
		Enddo
		***
		If lnSqlExeResult = -1
			spHandleODBCError()
			SQLDisconnect(lnConnectHandle)
			Return Ctot([])
		Endif

		ltServerDate = curGetDate.GetDate
		Use In Select([curGetDate])
	Endif
	*------------------------------------------------------------------------------

	*28.03.2007 12:13 ->Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	Return ltServerDate

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: LockEnter()
* Called by.......: <>
* Parameters......: <none>
* Returns.........: <none>
* Notes...........: <Проверка возможности запуска программы>
*------------------------------------------------------------------------------
Procedure LockEnter

	*02.04.2007 09:42 ->Объявление и инициализация переменных
	Local	lnConnectHandle As Integer, ;
		lnSqlExeResult	As Integer, ;
		llResult		As Boolean
	*------------------------------------------------------------------------------

	*02.04.2007 09:42 ->Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*28.03.2007 12:10 ->Проверяем возможность запуска программы
	If lnConnectHandle > 0	And lnSqlExeResult = 0

		Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
			lnSqlExeResult = SQLExec(lnConnectHandle, ;
				[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
				[SELECT COUNT(*) FROM EventJrn WHERE EventJrn.EventJrnCode = 1],[curEventJrn])
		Enddo
		***
		If lnSqlExeResult = -1
			SQLDisconnect(lnConnectHandle)
			Return .F.
		Endif

		llResult = (Reccount([curEventJrn]) = 0)
		Use In Select([curEventJrn])
	Endif
	*------------------------------------------------------------------------------

	*28.03.2007 12:13 ->Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	Return llResult

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spAccChangePrc()
* Called by.......: <NA>
* Parameters......: <tnTvrID, tnNewPrcBuy>
* Returns.........: <none>
* Notes...........: Изменение цены во всех калькуляциях
*------------------------------------------------------------------------------
Procedure spAccChangePrc
	Lparameters tnTvrID, tnNewPrcBuy

	*24.08.2005 14:15 -> Объявление и инициализация переменных
	Local	lnSqlExeResult, ;
		llResult
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Меняем цену во всех калькуляциях
	lnSqlExeResult = 0
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[UPDATE ] + ;
			[FrmPartTvr ] + ;
			[SET TvrPrcBuy = ?tnNewPrcBuy ] + ;
			[WHERE FrmPartTvr.TvrID = ?tnTvrID AND FrmPartTvr.FrmID IN (SELECT Form.FrmID FROM Form WHERE Form.FrmTypeID = 19)])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spAccountingView()
* Called by.......: <Form Data Request>
* Parameters......: <tcExecVar[,tuParam1,tuParam2]>
*					<[NODATA]>
*					<[BYFRMID],tnScrFrmID,tnFrmID>
*					<[BYFILTER],tnScrFrmID,tcQryParSID>
* Returns.........: <lcUniqueFileName>
* Notes...........: Получение данных для просмотра калькуляционных карт
*------------------------------------------------------------------------------
Procedure spAccountingView
	Lparameters tcExecVar,tuParam1,tuParam2

	*21.04.2004 12:31 -> Объявление и инициализация переменных
	Local	lcOldDate, ;
		lcOldCentury, ;
		lcOldMark, ;
		lcUniqueName, ;
		lcUniqueFilePath, ;
		lcFilterExpr, ;
		lcValueList, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate, ;
		luQryParCltEnabled, ;
		luQryParCltIDTableNM, ;
		luQryParOUEnabled, ;
		luQryParOUIDTableNM, ;
		luQryParFrmTypeEnabled, ;
		luQryParFrmTypeIDTableNM, ;
		luQryParFrmStatEnabled, ;
		luQryParFrmStatIDTableNM, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])
	lcUniqueName = [_d] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------

	*21.04.2004 12:33 -> Формируем фильтры в зависимости от типа запроса
	Do Case

	Case Type([tcExecVar])==[C] And tcExecVar==[NODATA]

		*21.04.2004 12:34 -> Формируем фильтр, для формирования пустой выборки
		lcFilterExpr = [WHERE 0=1]
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[11QUEUE]

		*21.04.2004 12:34 -> Формируем фильтр, для формирования пустой выборки
		lcFilterExpr = [WHERE Form.FrmID IN (SELECT Frmpayqueue.frmid FROM frmpayqueue)]
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFRMID]

		*21.04.2004 12:32 -> Формируем фильтр для выбора одного документа
		lcFilterExpr = [WHERE 0<>1] + ;
			[ AND ScrFrmViewObj.ScrFrmID = ] + Alltrim(Str(tuParam1)) + ;
			[ AND Form.FrmID = ]+Alltrim(Str(tuParam2))
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And (tcExecVar==[BYFILTER] Or tcExecVar==[QUEUE])

		*********************************************************************************
		*Формируем выражения для отбора документов, соответствующих всем фильтрам		*
		*********************************************************************************

		*26.05.2004 21:08 -> Основное условие, для отбора документов по ЭФ
		If tcExecVar==[QUEUE]
			lcFilterExpr = [WHERE Form.FrmID IN (SELECT Frmpayqueue.frmid FROM frmpayqueue) ] + ;
				[ AND ScrFrmViewObj.ScrFrmID = ] + Alltrim(Str(tuParam1))
		Else
			lcFilterExpr = [WHERE 0<>1] + ;
				[ AND ScrFrmViewObj.ScrFrmID = ] + Alltrim(Str(tuParam1))
		Endif
		*------------------------------------------------------------------------------

		*26.05.2004 21:20 -> Дальнейшие параметры обрабатываем, если существует менеджер параметров
		If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

			*26.05.2004 21:18 -> Формируем фильтр по дате
			luQryParDateEnabled = oQryParMgr.ParamGet(tuParam2,[qplDateEnabled])
			***
			If !Isnull(luQryParDateEnabled) And Type([luQryParDateEnabled])==[L] And luQryParDateEnabled

				*26.05.2004 21:33 -> Получим дату стартовую и конечную
				luQryParDateStartDate = oQryParMgr.ParamGet(tuParam2,[qpdDateStart])
				luQryParDateEndDate = oQryParMgr.ParamGet(tuParam2,[qpdDateEnd])
				*------------------------------------------------------------------------------

				*21.04.2006 10:33 -> Установим формат даты YMD и CENTURY ON
				Set Date YMD
				***
				Set Century On
				***
				Set Mark To "/"
				*------------------------------------------------------------------------------

				*26.05.2004 21:27 -> Формируем условие
				Do Case
				Case	!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
						!Isnull(luQryParDateEndDate) And Type([luQryParDateEndDate])==[D] And !Empty(luQryParDateEndDate)
					*{
					lcFilterExpr = lcFilterExpr + [ AND Form.FrmDate >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[' AND Form.FrmDate < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
					*}
				Case	!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate)
					*{
					lcFilterExpr = lcFilterExpr + [ AND Form.FrmDate >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[']
					*}
				Case	!Isnull(luQryParDateEndDate) And Type([luQryParDateEndDate])==[D] And !Empty(luQryParDateEndDate)
					*{
					lcFilterExpr = lcFilterExpr + [ AND Form.FrmDate < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
					*}
				Endcase
				*------------------------------------------------------------------------------

				*21.04.2006 10:33 -> Восстановим старый формат даты
				Set Date (lcOldDate)
				***
				Set Century &lcOldCentury
				***
				Set Mark To lcOldMark
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*27.05.2004 00:29 -> Формируем фильтр (Выбор клиента (EMI))
			luQryParCltEnabled = oQryParMgr.ParamGet(tuParam2,[qplCltEmiEnabled])
			***
			If !Isnull(luQryParCltEnabled) And Type([luQryParCltEnabled])==[L] And luQryParCltEnabled

				*27.05.2004 00:32 -> Получим имя временной таблицы с идентификаторами клиентов
				luQryParCltIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcCltEmiIDTableNM])
				***
				If !Isnull(luQryParCltIDTableNM) And Type([luQryParCltIDTableNM])==[C] And File([tmp\]+luQryParCltIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcFilterExpr = lcFilterExpr + ;
						[ AND Form.PointEmiCltID IN (] + spGetTmpValueList(luQryParCltIDTableNM) + [)]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*23.04.2006 00:29 ->Формируем фильтр (Выбор товаров)
			luQryParTvrEnabled = oQryParMgr.ParamGet(tuParam2,[qplTvrEnabled])
			***
			If !Isnull(luQryParTvrEnabled) And Type([luQryParTvrEnabled])==[L] And luQryParTvrEnabled

				*23.04.2006 00:32 ->Получим имя временной таблицы с идентификаторами товАРОВ
				luQryParTvrIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcTvrIDTableNM])
				***
				If !Isnull(luQryParTvrIDTableNM) And Type([luQryParTvrIDTableNM])==[C] And File([tmp\]+luQryParTvrIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcFilterExpr = lcFilterExpr + ;
						[ AND FrmPartTvr.TvrId IN (] + spGetTmpValueList(luQryParTvrIDTableNM) + [)]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*27.05.2004 00:29 ->Формируем фильтр (Выбор клиента (ISP))
			luQryParCltEnabled = oQryParMgr.ParamGet(tuParam2,[qplCltIspEnabled])
			***
			If !Isnull(luQryParCltEnabled) And Type([luQryParCltEnabled])==[L] And luQryParCltEnabled

				*27.05.2004 00:32 ->Получим имя временной таблицы с идентификаторами клиентов
				luQryParCltIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcCltIspIDTableNM])
				***
				If !Isnull(luQryParCltIDTableNM) And Type([luQryParCltIDTableNM])==[C] And File([tmp\]+luQryParCltIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcFilterExpr = lcFilterExpr + ;
						[ AND Form.PointIspCltID IN (] + spGetTmpValueList(luQryParCltIDTableNM) + [)]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*27.05.2004 00:29 ->Формируем фильтр (Выбор клиента (EMI OR ISP))
			luQryParCltEnabled = oQryParMgr.ParamGet(tuParam2,[qplCltEnabled])
			***
			If !Isnull(luQryParCltEnabled) And Type([luQryParCltEnabled])==[L] And luQryParCltEnabled

				*27.05.2004 00:32 ->Получим имя временной таблицы с идентификаторами клиентов
				luQryParCltIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcCltIDTableNM])
				***
				If !Isnull(luQryParCltIDTableNM) And Type([luQryParCltIDTableNM])==[C] And File([tmp\]+luQryParCltIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcValueList = spGetTmpValueList(luQryParCltIDTableNM)
					***
					lcFilterExpr = lcFilterExpr + ;
						[ AND (Form.PointEmiCltID IN (] + lcValueList + [)] + ;
						[ OR Form.PointIspCltID IN (] + lcValueList + [))]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*28.05.2004 03:01 ->Формируем фильтр (Выбор отдела (EMI))
			luQryParOUEnabled = oQryParMgr.ParamGet(tuParam2,[qplOUEmiEnabled])
			***
			If !Isnull(luQryParOUEnabled) And Type([luQryParOUEnabled])==[L] And luQryParOUEnabled

				*28.05.2004 00:37 ->Получим имя таблицы с идентификаторами подразделений
				luQryParOUIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcOUEmiIDTableNM])
				***
				If !Isnull(luQryParOUIDTableNM) And Type([luQryParOUIDTableNM])==[C] And File([tmp\]+luQryParOUIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcFilterExpr = lcFilterExpr + ;
						[ AND Form.PointEmiOUID IN (] + spGetTmpValueList(luQryParOUIDTableNM) + [)]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*28.05.2004 03:01 ->Формируем фильтр (Выбор отдела (ISP))
			luQryParOUEnabled = oQryParMgr.ParamGet(tuParam2,[qplOUIspEnabled])
			***
			If !Isnull(luQryParOUEnabled) And Type([luQryParOUEnabled])==[L] And luQryParOUEnabled

				*28.05.2004 00:37 ->Получим имя таблицы с идентификаторами подразделений
				luQryParOUIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcOUIspIDTableNM])
				***
				If !Isnull(luQryParOUIDTableNM) And Type([luQryParOUIDTableNM])==[C] And File([tmp\]+luQryParOUIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcFilterExpr = lcFilterExpr + ;
						[ AND Form.PointIspOUID IN (] + spGetTmpValueList(luQryParOUIDTableNM) + [)]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*28.05.2004 00:32 ->Формируем фильтр (Выбор отдела (EMI OR ISP))
			luQryParOUEnabled = oQryParMgr.ParamGet(tuParam2,[qplOUEnabled])
			***
			If !Isnull(luQryParOUEnabled) And Type([luQryParOUEnabled])==[L] And luQryParOUEnabled

				*28.05.2004 00:37 ->Получим имя таблицы с идентификаторами подразделений
				luQryParOUIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcOUIDTableNM])
				***
				If !Isnull(luQryParOUIDTableNM) And Type([luQryParOUIDTableNM])==[C] And File([tmp\]+luQryParOUIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcValueList = spGetTmpValueList(luQryParOUIDTableNM)
					***
					lcFilterExpr = lcFilterExpr + ;
						[ AND (Form.PointEmiOUID IN (] + lcValueList + [)] + ;
						[ OR Form.PointIspOUID IN (] + lcValueList + [))]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*19.01.2005 17:07 -> Формируем фильтр (Выбор типа документа)
			luQryParFrmTypeEnabled = oQryParMgr.ParamGet(tuParam2,[qplFrmTypeEnabled])
			***
			If !Isnull(luQryParFrmTypeEnabled) And Type([luQryParFrmTypeEnabled])==[L] And luQryParFrmTypeEnabled

				*19.01.2005 17:08 -> Получим имя таблицы с идентификаторами типов документов
				luQryParFrmTypeIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcFrmTypeIDTableNM])
				***
				If !Isnull(luQryParFrmTypeIDTableNM) And Type([luQryParFrmTypeIDTableNM])==[C] And File([tmp\]+luQryParFrmTypeIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcFilterExpr = lcFilterExpr + ;
						[ AND Form.FrmTypeID IN (] + spGetTmpValueList(luQryParFrmTypeIDTableNM) + [)]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*22.02.2006 16:55 -> Формируем фильтр (Выбор статуса документа)
			luQryParFrmStatEnabled = oQryParMgr.ParamGet(tuParam2,[qplFrmStatEnabled])
			***
			If !Isnull(luQryParFrmStatEnabled) And Type([luQryParFrmStatEnabled])==[L] And luQryParFrmStatEnabled

				*22.02.2006 16:55 -> Получим имя таблицы с идентификаторами статусов документов
				luQryParFrmStatIDTableNM = oQryParMgr.ParamGet(tuParam2,[qpcFrmStatIDTableNM])
				***
				If !Isnull(luQryParFrmStatIDTableNM) And Type([luQryParFrmStatIDTableNM])==[C] And File([tmp\]+luQryParFrmStatIDTableNM+[.dbf])

					*10.04.2006 11:35 -> Сформируем фильтр
					lcFilterExpr = lcFilterExpr + ;
						[ AND Form.FrmStatusID IN (] + spGetTmpValueList(luQryParFrmStatIDTableNM) + [)]
					*------------------------------------------------------------------------------

				Endif
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

			*10.01.2006 17:07 -> Формируем фильтр (Выбор типа документа)
			luQryParFrmTypeEnabled = oQryParMgr.ParamGet(tuParam2,[qplQueue])
			***
			If !Isnull(luQryParFrmTypeEnabled) And Type([luQryParFrmTypeEnabled])==[L] And luQryParFrmTypeEnabled

				lcFilterExpr = lcFilterExpr + ;
					[ AND Form.FrmID IN (SELECT Frmpayqueue.frmid FROM frmpayqueue)]

			Endif
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

	Endcase
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spAccountingView ?lcFilterExpr],lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1

		*11.08.2006 15:26 ->Вызовем процедуру обработки ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		*11.08.2006 15:19 ->Создадим пустой курсор для возврата
		Create Cursor (lcUniqueName) ( ;
			_mark L, frmid I, FrmTypeId I, FrmDate T, FrmNum C(1), FrmNote C(1), StatusID I, FrmIsPayed L, ;
			FTShortNM C(1), PEmiNM C(1), PIspNM C(1), FrmSum I, FrmVatSum I, FrmSumSale I, FrmSumBuy I, ;
			FrmVatSale I, FrmVatBuy I, AccFrmID I, AccTvrId I, AccQnt I, AccExit C(1), AccIsActiv F, ;
			AccColor C(1), AccAppr C(1), AccTaste C(1), AccSmell C(1), AccState C(1), AccTech C(1), ;
			AccCaloric C(1), AccFiber C(1), AccFat C(1), AccCarb C(1), AccNote C(1), AccTCard C(1), ;
			AccNetto I, AccPrice I, TvrNm C(1), FrmSign I ;
			)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	***
	Copy To (lcUniqueFilePath)
	***
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 -> Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spAppendAccount()
* Parameters......: <tnTvrId, tnTvrTypeID>
* Returns.........: <NA>
* Notes...........: Добавляет калькуляцию в базу данных
*------------------------------------------------------------------------------
Procedure spAppendAccount
	Lparameters tnTvrID, tnTvrTypeID

	*01.06.2006 16:44 -> VG
	If tnTvrTypeID = 5 Or tnTvrTypeID = 6

		*31.05.2006 10:05 -> Объявление и инициализация переменных
		Local   lnConnectHandle, ;
			lnSqlExeResult
		*------------------------------------------------------------------------------

		*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
		lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
		*------------------------------------------------------------------------------

		*07.04.2006 16:45 -> Выполняем запрос
		lnSqlExeResult = 0
		***
		Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
			lnSqlExeResult = SQLExec(lnConnectHandle, ;
				[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
				[EXECUTE spAppendAccount ?tnTvrId])
		Enddo
		***
		If lnSqlExeResult = -1
			spHandleODBCError()
			Return .F.
		Endif
		*------------------------------------------------------------------------------

		*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
		SQLDisconnect(lnConnectHandle)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spBindDisc()
* Called by.......: <NA>
* Parameters......: <tnCheckID,tnDiscCardID>
* Returns.........: <none>
* Notes...........:	Привязка дисконтной карты к чеку
*------------------------------------------------------------------------------
Procedure spBindDisc
	Lparameters tnCheckID,tnDiscCardID

	*31.05.2006 10:05 -> Объявление и инициализация переменных
	Local   lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Привязываем
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[UPDATE CheckSale ] + ;
			[SET DiscCardID = ?tnDiscCardID ] + ;
			[WHERE CheckID = ?tnCheckID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spBookBuyReport()
* Called by.......: <When Document Printed>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати книги покупок
*-------------------------------------------------------
Procedure spBookBuyReport
	Lparameters tcQryParSID

	*21.04.2004 12:31 -> Объявление и инициализация переменных
	Local	lcFilterExpr, ;
		lcJoinExpr, ;
		lcAliasListToClose, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate
	***
	lcAliasListToClose = []
	lcFilterExpr = [WHERE Form.FrmTypeID IN (1, 2) ]
	lcJoinExpr = []
	*------------------------------------------------------------------------------

	*02.06.2005 15:47 -> Создаем таблицу с окружением для отчёта
	Create Table Tmp\RptEnv Free (QryParSID C(10))
	Insert Into RptEnv (QryParSID) Values (tcQryParSID)
	*------------------------------------------------------------------------------

	*08.07.2005 14:35 -> Сформируем условия выбора по дате
	luQryParDateEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
	luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
	luQryParDateEndDate   = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
	***
	If !Isnull(luQryParDateEnabled)   And Type([luQryParDateEnabled])==[L]   And luQryParDateEnabled And ;
			!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
			!Isnull(luQryParDateEndDate)   And Type([luQryParDateEndDate])==[D]   And !Empty(luQryParDateEndDate)

		*08.07.2005 14:38 -> Сформируем условия выбора
		lcFilterExpr = lcFilterExpr + [ AND TTOD(Form.FrmDate) BETWEEN {]+Dtoc(luQryParDateStartDate)+[} AND {]+Dtoc(luQryParDateEndDate)+[}]
		*------------------------------------------------------------------------------

	Else

		*08.07.2005 14:40 -> Выведем сообщение о необходимости указать стартовую и конечную дату для построения отчёта
		Messagebox([Для построения данного отчёта необходимо указать стартовую и конечную дату отчётного периода],48,[Предупреждение])
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*17.10.2005 11:02 -> Выберем все счета-фактуры за отчётный период
	Select ;
		Form.frmid, ;
		Form.FrmParID, ;
		Form.FrmDate, ;
		FormReceipt.FrmDate As DtReceipt, ;
		Form.FrmNum, ;
		OrgUnit.cltid As OwnCltID, ;
		Form.PointEmiCltID As cltid ;
		FROM Form ;
		LEFT Join Form FormReceipt	On FormReceipt.frmid = Form.FrmParID And FormReceipt.FrmTypeId = 1 ;
		LEFT Join OrgUnit			On OrgUnit.Ouid = Form.PointIspOUID ;
		&lcFilterExpr ;
		INTO Table Tmp\tmpInvoice
	*------------------------------------------------------------------------------

	*17.10.2005 11:22 -> Выбираем идентификаторы родителей документов-родителей
	Select Distinct ;
		tmpInvoice.FrmParID As frmid, ;
		Form.FrmParID ;
		FROM tmpInvoice ;
		INNER Join Form On Form.frmid = tmpInvoice.FrmParID And Form.FrmParID # 0 ;
		INTO Cursor curPrevParentID NOFILTER
	*------------------------------------------------------------------------------

	*17.10.2005 12:14 -> Найдем родителей самого верхнего уровня (нас интересуют полученные счета)
	Do While _Tally > 0

		*17.10.2005 12:26 -> Выбираем родителей следующего уровня
		Select ;
			curPrevParentID.frmid, ;
			Form.FrmParID ;
			FROM curPrevParentID ;
			INNER Join Form On Form.frmid = curPrevParentID.FrmParID And Form.FrmParID # 0 ;
			INTO Cursor curNextParentID
		*------------------------------------------------------------------------------

		*17.10.2005 12:26 -> Производим маппинг родителей (для достигших самого верхнего уровня)
		Select ;
			curPrevParentID.frmid, ;
			curPrevParentID.FrmParID ;
			FROM curPrevParentID ;
			INNER Join Form On Form.frmid = curPrevParentID.FrmParID And Form.FrmParID = 0 ;
			INTO Cursor curNewParent
		***
		Select curNewParent
		***
		Scan All
			Replace FrmParID With curNewParent.FrmParID For FrmParID = curNewParent.frmid In tmpInvoice
		Endscan
		*------------------------------------------------------------------------------

		*17.10.2005 12:28 -> Подготавливаем данные для следующей итерации
		Select * From curNextParentID Into Cursor curPrevParentID NOFILTER
		*------------------------------------------------------------------------------

	Enddo
	*------------------------------------------------------------------------------

	*20.10.2005 11:40 -> Закроем курсоры
	Use In Select([curPrevParentID])
	Use In Select([curNextParentID])
	Use In Select([curNewParent])
	*------------------------------------------------------------------------------

	*17.10.2005 11:02 -> Выберем все суммовые позиции по оплате счетов, связанных со счетами-фактурами
	Select ;
		FrmPartFrm.frmid, ;
		FrmPartFrm.CntFrmId, ;
		Form.FrmDate As DtPayment, ;
		SUM(Iif(FrmPartFrmSum.FrmPartFrmSumVATRate>10,FrmPartFrmSum.FrmPartFrmSum,Ntom(0))) As FrmSum18, ;
		SUM(Iif(FrmPartFrmSum.FrmPartFrmSumVATRate>0 And FrmPartFrmSum.FrmPartFrmSumVATRate<14,FrmPartFrmSum.FrmPartFrmSum,Ntom(0))) As FrmSum10, ;
		SUM(Iif(FrmPartFrmSum.FrmPartFrmSumVATRate=0, FrmPartFrmSum.FrmPartFrmSum,Ntom(0))) As FrmSum0 ;
		FROM FrmPartFrm ;
		INNER Join Form			 On Form.frmid = FrmPartFrm.frmid ;
		INNER Join FrmPartFrmSum On FrmPartFrmSum.FrmPartFrmID = FrmPartFrm.FrmPartFrmID ;
		WHERE FrmPartFrm.CntFrmId In (Select FrmParID From tmpInvoice) ;
		GROUP By FrmPartFrm.frmid ;
		INTO Table Tmp\tmpPayment
	*------------------------------------------------------------------------------

	*17.10.2005 11:02 -> Формируем итоговую выборку
	Select ;
		tmpInvoice.frmid, ;
		tmpInvoice.FrmDate, ;
		tmpPayment.DtPayment, ;
		tmpInvoice.DtReceipt, ;
		tmpInvoice.FrmNum, ;
		tmpInvoice.OwnCltID, ;
		tmpInvoice.cltid, ;
		NVL(tmpPayment.FrmSum18,Ntom(0)) As FrmSum18, ;
		NVL(tmpPayment.FrmSum10,Ntom(0)) As FrmSum10, ;
		NVL(tmpPayment.FrmSum0, Ntom(0)) As FrmSum0 ;
		FROM tmpInvoice ;
		LEFT Join tmpPayment On tmpPayment.CntFrmId = tmpInvoice.FrmParID ;
		ORDER By tmpInvoice.OwnCltID,tmpInvoice.FrmDate ;
		INTO Table Tmp\RptItog
	*------------------------------------------------------------------------------

	*20.10.2005 11:50 ->Закроем и удалим временную таблицу
	Use In Select([tmpInvoice])
	***
	If File([tmp\tmpInvoice.dbf])
		Erase Tmp\tmpInvoice.Dbf
	Endif
	*------------------------------------------------------------------------------

	*20.10.2005 11:50 ->Закроем и удалим временную таблицу
	Use In Select([tmpPayment])
	***
	If File([tmp\tmpPayment.dbf])
		Erase Tmp\tmpPayment.Dbf
	Endif
	*------------------------------------------------------------------------------

	*04.02.2005 11:17 -> Составим список идентификаторов клиентов, упоминающихся в документе
	Select ;
		RptItog.cltid As Id;
		FROM RptItog ;
		UNION ;
		SELECT ;
		RptItog.OwnCltID As Id ;
		FROM RptItog ;
		INTO Cursor tmpCltIdList
	*------------------------------------------------------------------------------

	*04.02.2005 11:17 -> Получим подробные данные по клиентам
	spClientInfoExpand([tmpCltIdList],[RptCltInfo])
	*------------------------------------------------------------------------------

	*26.01.2005 19:10 -> Вернем имя временных файлов, созданных для отчета
	Return [RptItog.dbf;RptCltInfo.dbf;RptCltInfo.cdx;RptEnv.dbf]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spBookSaleReport()
* Called by.......: <When Document Printed>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати книги покупок
*-------------------------------------------------------
Procedure spBookSaleReport
	Lparameters tcQryParSID

	*21.04.2004 12:31 -> Объявление и инициализация переменных
	Local	lcFilterExpr, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate
	***
	lcFilterExpr = [WHERE Form.FrmTypeID IN (4,3) ]
	*------------------------------------------------------------------------------

	*02.06.2005 15:47 -> Создаем таблицу с окружением для отчёта
	Create Table Tmp\RptEnv Free (QryParSID C(10))
	Insert Into RptEnv (QryParSID) Values (tcQryParSID)
	*------------------------------------------------------------------------------

	*08.07.2005 14:35 -> Сформируем условия выбора по дате
	luQryParDateEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
	luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
	luQryParDateEndDate   = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
	***
	If !Isnull(luQryParDateEnabled)   And Type([luQryParDateEnabled])==[L]   And luQryParDateEnabled And ;
			!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
			!Isnull(luQryParDateEndDate)   And Type([luQryParDateEndDate])==[D]   And !Empty(luQryParDateEndDate)

		*08.07.2005 14:38 -> Сформируем условия выбора
		lcFilterExpr = lcFilterExpr + [ AND TTOD(Form.FrmDate) BETWEEN {]+Dtoc(luQryParDateStartDate)+[} AND {]+Dtoc(luQryParDateEndDate)+[}]
		*------------------------------------------------------------------------------

	Else

		*08.07.2005 14:40 -> Выведем сообщение о необходимости указать стартовую и конечную дату для построения отчёта
		Messagebox([Для построения данного отчёта необходимо указать стартовую и конечную дату отчётного периода],48,[Предупреждение])
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*17.10.2005 11:02 -> Выберем все счета-фактуры за отчётный период
	Select ;
		Form.frmid, ;
		Form.FrmParID, ;
		Form.FrmDate, ;
		Form.FrmNum, ;
		OrgUnit.cltid As OwnCltID, ;
		Form.PointIspCltID As cltid ;
		FROM Form ;
		LEFT Join OrgUnit On OrgUnit.Ouid = Form.PointEmiOUID ;
		&lcFilterExpr ;
		INTO Table Tmp\tmpInvoice
	*------------------------------------------------------------------------------

	*17.10.2005 11:22 -> Выбираем идентификаторы родителей документов-родителей
	Select Distinct ;
		tmpInvoice.FrmParID As frmid, ;
		Form.FrmParID ;
		FROM tmpInvoice ;
		INNER Join Form On Form.frmid = tmpInvoice.FrmParID And Form.FrmParID # 0 ;
		INTO Cursor curPrevParentID NOFILTER
	*------------------------------------------------------------------------------

	*17.10.2005 12:14 -> Найдем родителей самого верхнего уровня (нас интересуют полученные счета)
	Do While _Tally > 0

		*17.10.2005 12:26 -> Выбираем родителей следующего уровня
		Select ;
			curPrevParentID.frmid, ;
			Form.FrmParID ;
			FROM curPrevParentID ;
			INNER Join Form On Form.frmid = curPrevParentID.FrmParID And Form.FrmParID # 0 ;
			INTO Cursor curNextParentID
		*------------------------------------------------------------------------------

		*17.10.2005 12:26 -> Производим маппинг родителей (для достигших самого верхнего уровня)
		Select ;
			curPrevParentID.frmid, ;
			curPrevParentID.FrmParID ;
			FROM curPrevParentID ;
			INNER Join Form On Form.frmid = curPrevParentID.FrmParID And Form.FrmParID = 0 ;
			INTO Cursor curNewParent
		***
		Select curNewParent
		***
		Scan All
			Replace FrmParID With curNewParent.FrmParID For FrmParID = curNewParent.frmid In tmpInvoice
		Endscan
		*------------------------------------------------------------------------------

		*17.10.2005 12:28 -> Подготавливаем данные для следующей итерации
		Select * From curNextParentID Into Cursor curPrevParentID NOFILTER
		*------------------------------------------------------------------------------

	Enddo
	*------------------------------------------------------------------------------

	*20.10.2005 11:40 -> Закроем курсоры
	Use In Select([curPrevParentID])
	Use In Select([curNextParentID])
	Use In Select([curNewParent])
	*------------------------------------------------------------------------------

	*17.10.2005 11:02 -> Выберем все суммовые позиции по оплате счетов, связанных со счетами-фактурами
	Select ;
		FrmPartFrm.frmid, ;
		FrmPartFrm.CntFrmId, ;
		Form.FrmDate As DtPayment, ;
		SUM(Iif(FrmPartFrmSum.FrmPartFrmSumVATRate>10,FrmPartFrmSum.FrmPartFrmSum,Ntom(0))) As FrmSum18, ;
		SUM(Iif(FrmPartFrmSum.FrmPartFrmSumVATRate>0 And FrmPartFrmSum.FrmPartFrmSumVATRate<14,FrmPartFrmSum.FrmPartFrmSum,Ntom(0))) As FrmSum10, ;
		SUM(Iif(FrmPartFrmSum.FrmPartFrmSumVATRate=0, FrmPartFrmSum.FrmPartFrmSum,Ntom(0))) As FrmSum0 ;
		FROM FrmPartFrm ;
		INNER Join Form			 On Form.frmid = FrmPartFrm.frmid ;
		INNER Join FrmPartFrmSum On FrmPartFrmSum.FrmPartFrmID = FrmPartFrm.FrmPartFrmID ;
		WHERE FrmPartFrm.CntFrmId In (Select FrmParID From tmpInvoice) ;
		GROUP By FrmPartFrm.frmid ;
		INTO Table Tmp\tmpPayment
	*------------------------------------------------------------------------------

	*17.10.2005 11:02 -> Формируем итоговую выборку
	Select ;
		tmpInvoice.frmid, ;
		tmpInvoice.FrmDate, ;
		tmpPayment.DtPayment, ;
		tmpInvoice.FrmNum, ;
		tmpInvoice.OwnCltID, ;
		tmpInvoice.cltid, ;
		NVL(tmpPayment.FrmSum18,Ntom(0)) As FrmSum18, ;
		NVL(tmpPayment.FrmSum10,Ntom(0)) As FrmSum10, ;
		NVL(tmpPayment.FrmSum0, Ntom(0)) As FrmSum0 ;
		FROM tmpInvoice ;
		LEFT Join tmpPayment On tmpPayment.CntFrmId = tmpInvoice.FrmParID ;
		ORDER By tmpInvoice.OwnCltID,tmpInvoice.FrmDate ;
		INTO Table Tmp\RptItog
	*------------------------------------------------------------------------------

	*20.10.2005 11:50 ->Закроем и удалим временную таблицу
	Use In Select([tmpInvoice])
	***
	If File([tmp\tmpInvoice.dbf])
		Erase Tmp\tmpInvoice.Dbf
	Endif
	*------------------------------------------------------------------------------

	*20.10.2005 11:50 ->Закроем и удалим временную таблицу
	Use In Select([tmpPayment])
	***
	If File([tmp\tmpPayment.dbf])
		Erase Tmp\tmpPayment.Dbf
	Endif
	*------------------------------------------------------------------------------

	*04.02.2005 11:17 -> Составим список идентификаторов клиентов, упоминающихся в документе
	Select ;
		RptItog.cltid As Id;
		FROM RptItog ;
		UNION ;
		SELECT ;
		RptItog.OwnCltID As Id ;
		FROM RptItog ;
		INTO Cursor tmpCltIdList
	*------------------------------------------------------------------------------

	*04.02.2005 11:17 -> Получим подробные данные по клиентам
	spClientInfoExpand([tmpCltIdList],[RptCltInfo])
	*------------------------------------------------------------------------------

	*26.01.2005 19:10 -> Вернем имя временных файлов, созданных для отчета
	Return [RptItog.dbf;RptCltInfo.dbf;RptCltInfo.cdx;RptEnv.dbf]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCardAccessSale()
* Called by.......: <When Document Printed>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати отчёта по продажам карт доступа на подьемник
*-----------------------------------------------------------------------------------
Procedure spCardAccessSale
	Lparameters tcQryParSID

	*21.04.2004 12:31 -> Объявление и инициализация переменных
	Local	lcOldDate, ;
		lcOldCentury, ;
		lcOldMark, ;
		lcFilterExpr, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate, ;
		luQryCltEnabled, ;
		luQryCltTableNM, ;
		lcValueList, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])
	lcFilterExpr = [WHERE 1 <> 272]
	*------------------------------------------------------------------------------
	*****************************************************************************
	* 1. Сохраним идентификатор сессии параметров для использования в отчёте	*
	*****************************************************************************

	*02.06.2005 15:47 -> Создаем таблицу с окружением для отчёта
	Create Table Tmp\RptEnv Free (QryParSID C(10))
	Insert Into RptEnv (QryParSID) Values (tcQryParSID)
	*------------------------------------------------------------------------------

	*****************************************************************************
	* 2. Сформируем условия выбора данных										*
	*****************************************************************************

	*08.07.2005 14:35 -> Сформируем условия выбора по дате
	luQryParDateEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
	luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
	luQryParDateEndDate   = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
	***
	If !Isnull(luQryParDateEnabled)   And Type([luQryParDateEnabled])==[L]   And luQryParDateEnabled And ;
			!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
			!Isnull(luQryParDateEndDate)   And Type([luQryParDateEndDate])==[D]   And !Empty(luQryParDateEndDate)

		*21.04.2006 10:33 -> Установим формат даты YMD и CENTURY ON
		Set Date YMD
		***
		Set Century On
		***
		Set Mark To "/"
		*------------------------------------------------------------------------------

		*06.12.2007 14:38 -> Сформируем условия выбора
		lcFilterExpr = lcFilterExpr + [  AND AccessTvrSum.AccesDate >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[]);
			+[' AND AccessTvrSum.AccesDate <= ']+Strtran(Dtoc(luQryParDateEndDate),[/],[])+[']
		*------------------------------------------------------------------------------

		*21.04.2006 10:33 -> Восстановим старый формат даты
		Set Date (lcOldDate)
		***
		Set Century &lcOldCentury
		***
		Set Mark To lcOldMark
		*------------------------------------------------------------------------------

	Else

		*08.07.2005 14:40 -> Выведем сообщение о необходимости указать стартовую и конечную дату для построения отчёта
		spHandleODBCError()
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*28.05.2004 00:32 -> Формируем условие выбора по владельцу карты
	luQryCltEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplCltEnabled])
	luQryCltTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCltIDTableNM])
	***
	If !Isnull(luQryCltEnabled)   And Type([luQryCltEnabled])==[L]   And luQryCltEnabled And ;
			!Isnull(luQryCltTableNM) And Type([luQryCltTableNM])==[C]

		*08.12.2007 14:38 -> Сформируем условия выбора
		lcValueList = spGetTmpValueList(luQryCltTableNM)
		***
		lcFilterExpr = lcFilterExpr + [ AND AccessTvrSum.CardOwnerID IN (] + lcValueList + [)]

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.T.)
	*------------------------------------------------------------------------------
	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spCardAccessSale ?lcFilterExpr],[RptItog])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------


	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItog
	Copy To Tmp\RptItog.Dbf
	***
	Use In Select([RptItog])



	*26.01.2005 19:10 -> Вернем список файлов созданных для отчета
	Return [RptItog.dbf]  &&;RptItog.cdx]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCardAccessStat()
* Called by.......: <When Document Printed>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати отчёта по картам доступа
*-------------------------------------------------------
Procedure spCardAccessStat
	Lparameters tcQryParSID

	*21.04.2004 12:31 -> Объявление и инициализация переменных
	Local	lcOldDate, ;
		lcOldCentury, ;
		lcOldMark, ;
		lcFilterExpr, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate, ;
		luQryCltEnabled, ;
		luQryCltTableNM, ;
		lcValueList, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])
	lcFilterExpr = [WHERE 1 <> 272]
	*------------------------------------------------------------------------------

	*****************************************************************************
	* 1. Сохраним идентификатор сессии параметров для использования в отчёте	*
	*****************************************************************************

	*02.06.2005 15:47 -> Создаем таблицу с окружением для отчёта
	Create Table Tmp\RptEnv Free (QryParSID C(10))
	Insert Into RptEnv (QryParSID) Values (tcQryParSID)
	*------------------------------------------------------------------------------

	*****************************************************************************
	* 2. Сформируем условия выбора данных										*
	*****************************************************************************

	*08.07.2005 14:35 -> Сформируем условия выбора по дате
	luQryParDateEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
	luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
	luQryParDateEndDate   = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
	***
	If !Isnull(luQryParDateEnabled)   And Type([luQryParDateEnabled])==[L]   And luQryParDateEnabled And ;
			!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
			!Isnull(luQryParDateEndDate)   And Type([luQryParDateEndDate])==[D]   And !Empty(luQryParDateEndDate)

		*21.04.2006 10:33 -> Установим формат даты YMD и CENTURY ON
		Set Date YMD
		***
		Set Century On
		***
		Set Mark To "/"
		*------------------------------------------------------------------------------

		*06.12.2007 14:38 -> Сформируем условия выбора
		lcFilterExpr = lcFilterExpr + [  AND CardStatTime.AccesDate >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[]);
			+[' AND CardStatTime.AccesDate <= ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
		*------------------------------------------------------------------------------

		*21.04.2006 10:33 -> Восстановим старый формат даты
		Set Date (lcOldDate)
		***
		Set Century &lcOldCentury
		***
		Set Mark To lcOldMark
		*------------------------------------------------------------------------------

	Else

		*08.07.2005 14:40 -> Выведем сообщение о необходимости указать стартовую и конечную дату для построения отчёта
		spHandleODBCError()
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*28.05.2004 00:32 -> Формируем условие выбора по владельцу карты
	luQryCltEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplCltEnabled])
	luQryCltTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCltIDTableNM])
	***
	If !Isnull(luQryCltEnabled)   And Type([luQryCltEnabled])==[L]   And luQryCltEnabled And ;
			!Isnull(luQryCltTableNM) And Type([luQryCltTableNM])==[C]

		*08.12.2007 14:38 -> Сформируем условия выбора
		lcValueList = spGetTmpValueList(luQryCltTableNM)
		***
		lcFilterExpr = lcFilterExpr + [ AND CardStatTime.CardOwnerID IN (] + lcValueList + [)]

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.T.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spCardAccessStat ?lcFilterExpr],[RptItog])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------


	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItog
	Copy To Tmp\RptItog.Dbf
	***
	Use In Select([RptItog])



	*26.01.2005 19:10 -> Вернем список файлов созданных для отчета
	Return [RptItog.dbf]  &&;RptItog.cdx]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCheckReset()
* Called by.......: <NA>
* Parameters......: <tnCheckID>
* Returns.........: <none>
* Notes...........: Сброс чека
*------------------------------------------------------------------------------
Procedure spCheckReset
	Lparameters tnCheckID

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Сбрасываем чек
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[UPDATE CheckSale ] + ;
			[SET CheckTypeID = ABS(CheckTypeID) + 3 ] + ;
			[WHERE CheckID = ?tnCheckID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCheckReset_old() резервный вариант
* Called by.......: <NA>
* Parameters......: <tnCheckID>
* Returns.........: <none>
* Notes...........: Сброс чека
*------------------------------------------------------------------------------
Procedure spCheckReset_old
	Lparameters tnCheckID

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Сбрасываем чек
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[UPDATE CheckSale ] + ;
			[SET CheckTypeID = CheckTypeID + 3 ] + ;
			[WHERE CheckID = ?tnCheckID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCheckSaleSucces()
* Called by.......: <NA>
* Parameters......: <tnCheckID>
* Returns.........: <none>
* Notes...........: Фиксирование нормального завершения чека
*------------------------------------------------------------------------------
Procedure spCheckSaleSucces
	Lparameters tnCheckID

	*10.10.2006 16:26 ->Объявление и инициализация переменных
	Local   lnConnectHandle, ;
		lnSqlExeResult, ;
		llResult
	*------------------------------------------------------------------------------

	*10.10.2006 16:26 ->Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*10.10.2006 16:26 ->Отмечаем чек
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[UPDATE CheckSale ] + ;
			[SET CheckAttributeID = CheckAttributeID & (~4) ] + ;
			[WHERE CheckID = ?tnCheckID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*10.10.2006 16:26 ->Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCheckView()
* Called by.......: <NA>
* Parameters......: <tcQryParSID>
* Returns.........: <none>
* Notes...........: Список чеков
*------------------------------------------------------------------------------
Procedure spCheckView
	Lparameters tcQryParSID

	*28.02.2006 12:16 ->Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lcOldDate, ;
		lcOldCentury, ;
		lcOldMark, ;
		lcUniqueName, ;
		lcUniqueFilePath, ;
		lcFilterExpr, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate, ;
		luQryParCashEnabled, ;
		luQryParCashTableNM, ;
		luQryParCashierEnabled, ;
		luQryParCashierTableNM, ;
		luQryParTvrEnabled, ;
		luQryParTvrIDTableNM, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])
	lcFilterExpr   = []
	lcUniqueName = [_sl]+Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------

	*07.07.2006 16:38 -> Вывод сообщения пользователю
	Set Message To [Идет подготовка данных...]
	Wait Window [Идет подготовка данных...] Nowait Noclear
	*------------------------------------------------------------------------------

	*28.02.2006 14:52 ->Дальнейшие параметры обрабатываем, если существует менеджер параметров
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*07.12.2005 11:37 ->Формируем фильтр по дате
		luQryParDateEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
		***
		If !Isnull(luQryParDateEnabled) And Type([luQryParDateEnabled])==[L] And luQryParDateEnabled

			*26.05.2004 21:33 ->Получим дату стартовую и конечную
			luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
			luQryParDateEndDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
			*------------------------------------------------------------------------------

			*21.04.2006 10:33 -> Установим формат даты YMD и CENTURY ON
			Set Date YMD
			***
			Set Century On
			***
			Set Mark To "/"
			*------------------------------------------------------------------------------

			*26.05.2004 21:27 ->Формируем условие
			Do Case
			Case	!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
					!Isnull(luQryParDateEndDate) And Type([luQryParDateEndDate])==[D] And !Empty(luQryParDateEndDate)
				*{
				lcFilterExpr = lcFilterExpr + [ AND CheckStamp >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[' AND CheckStamp < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
				*}
			Case	!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate)
				*{
				lcFilterExpr = lcFilterExpr + [ AND CheckStamp >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[']
				*}
			Case	!Isnull(luQryParDateEndDate) And Type([luQryParDateEndDate])==[D] And !Empty(luQryParDateEndDate)
				*{
				lcFilterExpr = lcFilterExpr + [ AND CheckStamp < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
				*}
			Endcase
			*------------------------------------------------------------------------------

			*21.04.2006 10:33 -> Восстановим старый формат даты
			Set Date (lcOldDate)
			***
			Set Century &lcOldCentury
			***
			Set Mark To lcOldMark
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

		*02.06.2006 11:34 ->Формируем фильтр по кассе
		luQryParCashEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCashEnabled])
		***
		If !Isnull(luQryParCashEnabled) And Type([luQryParCashEnabled])==[L] And luQryParCashEnabled
			luQryParCashTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCashTableNM])
			If !Isnull(luQryParCashTableNM) And Type([luQryParCashTableNM])==[C] And File(luQryParCashTableNM+[.dbf])

				*10.04.2006 11:35 -> Сформируем фильтр
				lcFilterExpr = lcFilterExpr+[ AND CheckCashID IN (] + spGetTmpValueList(luQryParCashTableNM) + [)]
				*------------------------------------------------------------------------------

			Endif
		Endif
		*------------------------------------------------------------------------------

		*02.06.2006 11:34 ->Формируем фильтр по кассиру
		luQryParCashierEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCashierEnabled])
		***
		If !Isnull(luQryParCashierEnabled) And Type([luQryParCashierEnabled])==[L] And luQryParCashierEnabled
			luQryParCashierTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCashierTableNM])
			If !Isnull(luQryParCashierTableNM) And Type([luQryParCashierTableNM])==[C] And File(luQryParCashierTableNM+[.dbf])

				*10.04.2006 11:35 -> Сформируем фильтр
				lcFilterExpr = lcFilterExpr+[ AND CheckCashierID IN (] + spGetTmpValueList(luQryParCashierTableNM) + [)]
				*------------------------------------------------------------------------------

			Endif
		Endif
		*------------------------------------------------------------------------------

		*02.06.2006 11:38 ->Формируем фильтр (Выбор товаров)
		luQryParTvrEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplTvrEnabled])
		***
		If !Isnull(luQryParTvrEnabled) And Type([luQryParTvrEnabled])==[L] And luQryParTvrEnabled

			*23.04.2006 00:32 ->Получим имя временной таблицы с идентификаторами товАРОВ
			luQryParTvrIDTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcTvrIDTableNM])
			***
			If !Isnull(luQryParTvrIDTableNM) And Type([luQryParTvrIDTableNM])==[C] And File([tmp\]+luQryParTvrIDTableNM+[.dbf])

				*10.04.2006 11:35 -> Сформируем фильтр
				lcFilterExpr = lcFilterExpr + ;
					[ AND CheckID IN (SELECT CheckID FROM CheckTrans WHERE CheckTrans.CheckTransTvrId IN (]+spGetTmpValueList(luQryParTvrIDTableNM)+[))]
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------
	If Empty(tcQryParSID)
		Set Date YMD
		Set Century On
		Set Mark To "/"
		lcFilterExpr = [ AND CheckStamp BETWEEN ']+Strtran(Dtoc(Date()),[/],[])+[' AND ']+Strtran(Dtoc(Date()),[/],[])+[']
		Set Date (lcOldDate)
		Set Century &lcOldCentury
		Set Mark To lcOldMark
	Endif
	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spCheckView ?lcFilterExpr],lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1

		*11.08.2006 17:00 ->Вызовем обработчик ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		*11.08.2006 17:01 ->Сформируем пустой курсор
		Create Cursor (lcUniqueName) ( ;
			CheckID I, BranchID I, BranchNM C(1), ChkTypeNM C(1), CheckNo I, CashNM C(1), ;
			CashierNM C(1), CheckStamp T, DiscCardNo C(1),CheckSum I;
			)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	***
	Copy To (lcUniqueFilePath)
	***
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*02.06.2006 12:24 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*07.07.2006 16:39 -> Очистим сообщение
	Wait Clear
	Set Message To []
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 -> Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spClientInfoExpand()
* Called by.......: <NA>
* Parameters......: <tcCltIdListTable, tcCltListTable>
* Returns.........: <none>
* Notes...........: Выборка информации о клиентах
*-------------------------------------------------------
Procedure spClientInfoExpand
	Lparameters	tcCltIdListTable, tcCltListTable

	*24.04.2006 12:49 ->Объявление и инициализация переменных
	Local	lcFilterExpr, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*21.04.2006 16:14 -> Сформируем строку со списком идентификаторов клиентов
	lcFilterExpr = spGetTmpValueList(tcCltIdListTable)
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос (получим подробные данные по клиентам)
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spClientInfoExpand ?lcFilterExpr],[curCltList])
	Enddo
	***
	If lnSqlExeResult = -1

		*11.08.2006 16:02 ->Вазовем обработчик ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		Return
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*15.09.2004 11:53 -> Cделаем конкатенацию
	Select ;
		curCltList.cltid, ;
		curCltList.CltNM, ;
		LTRIM(Alltrim(curCltList.CltLTAbbr) + ;
		[ ]+Alltrim(curCltList.CltJrdNM) + ;
		ALLTRIM(curCltList.CltFIO)) As CltFullNM, ;
		LTRIM(Alltrim(curCltList.CltLTAbbr) + ;
		[ ]+Alltrim(curCltList.CltJrdNM) + ;
		ALLTRIM(curCltList.CltFIO_)) As CltFullNM_, ;
		SUBSTR(Padr(Iif(!Empty(curCltList.CltFullINN),[, ]+Alltrim(curCltList.CltFullINN),[]) + ;
		IIF(!Empty(curCltList.CltFullKpp),[, ]+Alltrim(curCltList.CltFullKpp),[]),254),3) As CltInnKpp, ;
		SUBSTR(Padr(Iif(curCltList.CltAddrZIP>0, [, ]+Alltrim(Str(curCltList.CltAddrZIP)), []) + ;
		IIF(!Empty(curCltList.CltAddrReg), [, ]+Alltrim(curCltList.CltAddrReg), []) + ;
		IIF(!Empty(curCltList.CltAddrStl), [, ]+Alltrim(curCltList.CltAddrStl), []) + ;
		IIF(!Empty(curCltList.CltAddrStr), [, ]+Alltrim(curCltList.CltAddrStr), []) + ;
		IIF(!Empty(curCltList.CltAddrHs), [, ]+Alltrim(curCltList.CltAddrHs), []) + ;
		IIF(!Empty(curCltList.CltAddrRm), [, ]+Alltrim(curCltList.CltAddrRm), []) + ;
		IIF(!Empty(curCltList.CltTel), [, ]+Alltrim(curCltList.CltTel), []), 254),3) As CltFullAdr, ;
		PADR(Ltrim(Iif(!Empty(curCltList.CltPhPSer), [ серия ]+Alltrim(curCltList.CltPhPSer), []) + ;
		IIF(!Empty(curCltList.CltPhPNum), [ номер ]+Alltrim(curCltList.CltPhPNum), []) + ;
		IIF(!Empty(curCltList.CltPhPID) Or !Empty(curCltList.CltPhPIB), [ выдан], []) + ;
		IIF(!Empty(curCltList.CltPhPIB), [ ]+Alltrim(curCltList.CltPhPIB), []) + ;
		IIF(!Empty(curCltList.CltPhPID), [ ]+Dtoc(Ttod(curCltList.CltPhPID)), [])), 254) As CltFullPh, ;
		curCltList.CltTypeID, ;
		curCltList.CltINN, ;
		curCltList.CltFullINN, ;
		curCltList.CltAddrZIP, ;
		curCltList.CltAddrReg, ;
		curCltList.CltAddrStl, ;
		curCltList.CltAddrStr, ;
		curCltList.CltAddrHs, ;
		curCltList.CltAddrRm, ;
		curCltList.CltTel, ;
		curCltList.CltJrdNM, ;
		curCltList.CltJrdKpp, ;
		curCltList.CltFullKPP, ;
		curCltList.CltLTAbbr, ;
		curCltList.CltLTNM, ;
		curCltList.CltPhysFNM, ;
		curCltList.CltPhysINM, ;
		curCltList.CltPhysONM, ;
		curCltList.CltFIO, ;
		curCltList.CltFIO_, ;
		curCltList.CltPhBDate, ;
		curCltList.CltPhPSer, ;
		curCltList.CltPhPNum, ;
		curCltList.CltPhPID, ;
		curCltList.CltPhPIB, ;
		curCltList.CltPhPDate ;
		FROM curCltList ;
		INTO Table ([tmp\]+tcCltListTable)
	*------------------------------------------------------------------------------

	*16.09.2004 15:55 ->Создадим индекс для Relation-а
	Select (tcCltListTable)
	Index On cltid Tag cltid &&OF ([tmp\]+tcCltListTable)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spClientInfoExpandVFP()
* Called by.......: <NA>
* Parameters......: <tcCltIdListTable, tcCltListTable>
* Returns.........: <none>
* Notes...........: Выборка информации о клиентах
*-------------------------------------------------------
Procedure spClientInfoExpandVFP
	Lparameters	tcCltIdListTable, tcCltListTable

	*25.08.2004 11:44 -> Выберем информацию о клиентах
	Select ;
		CltIdList.cltid, ;
		Client.CltNM, ;
		Client.CltTypeID, ;
		Client.CltINN, ;
		PADR(Iif(Client.CltINN>0,[ИНН ]+Alltrim(Str(Client.CltINN,12,0)),[]),254) As CltFullINN, ;
		NVL(CltAddress.CltAddrZIP, 000000) As CltAddrZIP, ;
		NVL(CltAddress.CltAddrRegNM, Space(40)) As CltAddrReg, ;
		NVL(CltAddress.CltAddrAreaNM, Space(40)) As CltAddrAr, ;
		NVL(CltAddress.CltAddrSettlNM, Space(40)) As CltAddrStl, ;
		NVL(CltAddress.CltAddrStreetNM, Space(40)) As CltAddrStr, ;
		NVL(CltAddress.CltAddrHouseNM, Space(40)) As CltAddrHs, ;
		NVL(CltAddress.CltAddrRoom, Space(40)) As CltAddrRm, ;
		NVL(CltTel.CltTelNumber, Space(20)) As CltTel, ;
		NVL(CltJuridical.CltJrdNM, Space(40)) As CltJrdNM, ;
		NVL(CltJuridical.CltJrdKpp, 000000000)  As CltJrdKpp, ;
		PADR(Iif(!Isnull(CltJuridical.CltJrdKpp) And CltJuridical.CltJrdKpp>0,[КПП ] + Alltrim(Str(CltJuridical.CltJrdKpp)),[]),254) As CltFullKPP, ;
		NVL(CltLegalType.CltLegalTypeAbbr, Space(20)) As CltLTAbbr, ;
		NVL(CltLegalType.CltLegalTypeNM, Space(40)) As CltLTNM, ;
		NVL(CltPhysical.CltPhysFNM, Space(40)) As CltPhysFNM, ;
		NVL(CltPhysical.CltPhysINM, Space(40)) As CltPhysINM, ;
		NVL(CltPhysical.CltPhysONM, Space(40)) As CltPhysONM, ;
		PADR(Ltrim(Iif(!Isnull(CltPhysical.CltPhysFNM) And !Empty(CltPhysical.CltPhysFNM),[ ]+Alltrim(CltPhysical.CltPhysFNM),[]) + ;
		IIF(!Isnull(CltPhysical.CltPhysINM) And !Empty(CltPhysical.CltPhysINM),[ ]+Alltrim(CltPhysical.CltPhysINM),[]) + ;
		IIF(!Isnull(CltPhysical.CltPhysONM) And !Empty(CltPhysical.CltPhysONM),[ ]+Alltrim(CltPhysical.CltPhysONM),[])),254) As CltFIO, ;
		PADR(Ltrim(Iif(!Isnull(CltPhysical.CltPhysFNM) And !Empty(CltPhysical.CltPhysFNM),[ ]+Alltrim(CltPhysical.CltPhysFNM),[]) + ;
		IIF(!Isnull(CltPhysical.CltPhysINM) And !Empty(CltPhysical.CltPhysINM),[ ]+Left(Ltrim(CltPhysical.CltPhysINM),1)+[.],[]) + ;
		IIF(!Isnull(CltPhysical.CltPhysONM) And !Empty(CltPhysical.CltPhysONM),[ ]+Left(Ltrim(CltPhysical.CltPhysONM),1)+[.],[])),254) As CltFIO_, ;
		NVL(CltPhysical.CltPhysBirthDate, Ctot([])) As CltPhBDate, ;
		NVL(CltPhysPassp.CltPhysPasspSeries, Space(20)) As CltPhPSer, ;
		NVL(CltPhysPassp.CltPhysPasspNumber, Space(20)) As CltPhPNum, ;
		NVL(CltPhysPassp.CltPhysPasspIssueDate, Ctot([])) As CltPhPID, ;
		NVL(CltPhysPassp.CltPhysPasspIssueBy, Space(100)) As CltPhPIB, ;
		NVL(CltPhysPassp.CltPhysPasspExpDate,Ctot([])) As CltPhPDate ;
		FROM (tcCltIdListTable) CltIdList;
		INNER Join Client On CltIdList.cltid = Client.cltid ;
		LEFT Join CltAddress On CltIdList.cltid = CltAddress.cltid And CltAddress.CltAddrIsMain ;
		LEFT Join CltTel On CltIdList.cltid = CltTel.cltid And CltTel.CltTelIsMain ;
		LEFT Join CltPhysical On CltIdList.cltid = CltPhysical.cltid ;
		LEFT Join CltJuridical On CltIdList.cltid = CltJuridical.cltid ;
		LEFT Join CltPhysPassp On CltIdList.cltid = CltPhysPassp.cltid ;
		LEFT Join CltLegalType On CltJuridical.CltLegalTypeID = CltLegalType.CltLegalTypeID ;
		INTO Cursor curCltList NOFILTER
	*------------------------------------------------------------------------------

	*15.09.2004 11:53 -> Cделаем конкатенацию
	Select ;
		curCltList.cltid, ;
		curCltList.CltNM, ;
		LTRIM(Alltrim(curCltList.CltLTAbbr) + ;
		[ ]+Alltrim(curCltList.CltJrdNM) + ;
		ALLTRIM(curCltList.CltFIO)) As CltFullNM, ;
		LTRIM(Alltrim(curCltList.CltLTAbbr) + ;
		[ ]+Alltrim(curCltList.CltJrdNM) + ;
		ALLTRIM(curCltList.CltFIO_)) As CltFullNM_, ;
		SUBSTR(Padr(Iif(!Empty(curCltList.CltFullINN),[, ]+Alltrim(curCltList.CltFullINN),[]) + ;
		IIF(!Empty(curCltList.CltFullKpp),[, ]+Alltrim(curCltList.CltFullKpp),[]),254),3) As CltInnKpp, ;
		SUBSTR(Padr(Iif(curCltList.CltAddrZIP>0, [, ]+Alltrim(Str(curCltList.CltAddrZIP)), []) + ;
		IIF(!Empty(curCltList.CltAddrReg), [, ]+Alltrim(curCltList.CltAddrReg), []) + ;
		IIF(!Empty(curCltList.CltAddrStl), [, ]+Alltrim(curCltList.CltAddrStl), []) + ;
		IIF(!Empty(curCltList.CltAddrStr), [, ]+Alltrim(curCltList.CltAddrStr), []) + ;
		IIF(!Empty(curCltList.CltAddrHs), [, ]+Alltrim(curCltList.CltAddrHs), []) + ;
		IIF(!Empty(curCltList.CltAddrRm), [, ]+Alltrim(curCltList.CltAddrRm), []) + ;
		IIF(!Empty(curCltList.CltTel), [, ]+Alltrim(curCltList.CltTel), []), 254),3) As CltFullAdr, ;
		PADR(Ltrim(Iif(!Empty(curCltList.CltPhPSer), [ серия ]+Alltrim(curCltList.CltPhPSer), []) + ;
		IIF(!Empty(curCltList.CltPhPNum), [ номер ]+Alltrim(curCltList.CltPhPNum), []) + ;
		IIF(!Empty(curCltList.CltPhPID) Or !Empty(curCltList.CltPhPIB), [ выдан], []) + ;
		IIF(!Empty(curCltList.CltPhPIB), [ ]+Alltrim(curCltList.CltPhPIB), []) + ;
		IIF(!Empty(curCltList.CltPhPID), [ ]+Dtoc(Ttod(curCltList.CltPhPID)), [])), 254) As CltFullPh, ;
		curCltList.CltTypeID, ;
		curCltList.CltINN, ;
		curCltList.CltFullINN, ;
		curCltList.CltAddrZIP, ;
		curCltList.CltAddrReg, ;
		curCltList.CltAddrStl, ;
		curCltList.CltAddrStr, ;
		curCltList.CltAddrHs, ;
		curCltList.CltAddrRm, ;
		curCltList.CltTel, ;
		curCltList.CltJrdNM, ;
		curCltList.CltJrdKpp, ;
		curCltList.CltFullKPP, ;
		curCltList.CltLTAbbr, ;
		curCltList.CltLTNM, ;
		curCltList.CltPhysFNM, ;
		curCltList.CltPhysINM, ;
		curCltList.CltPhysONM, ;
		curCltList.CltFIO, ;
		curCltList.CltFIO_, ;
		curCltList.CltPhBDate, ;
		curCltList.CltPhPSer, ;
		curCltList.CltPhPNum, ;
		curCltList.CltPhPID, ;
		curCltList.CltPhPIB, ;
		curCltList.CltPhPDate ;
		FROM curCltList ;
		INTO Table ([tmp\]+tcCltListTable)
	*------------------------------------------------------------------------------

	*16.09.2004 10:40 -> уберем курсоры
	Use In Iif(Used([curCltList]),[curCltList],0)
	*------------------------------------------------------------------------------

	*16.09.2004 15:55 ->Создадим индекс для Relation-а
	Select (tcCltListTable)
	Index On cltid Tag cltid Of ([tmp\]+tcCltListTable)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spClientView()
* Called by.......: <NA>
* Parameters......: <tcQryParSID>
* Returns.........: <lcUniqueFileName>
* Notes...........: Просмотр клиентов
*------------------------------------------------------------------------------
Procedure spClientView
	Lparameters tcQryParSID

	*10.08.2005 14:58 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lcUniqueName, ;
		lcUniqueFilePath, ;
		lcCltJuridicalExpr, ;
		lcCltPhysicalExpr, ;
		lcClientExpr, ;
		luQryParCltNMEnabled, ;
		luQryParCltNM, ;
		lnConnectHandle, ;
		lnSqlExeResult,;
		luQryCltIDEnabled ,;
		luQryCrdCodEnabled ,;
		luQryCltID
	***
	lcOldAlias = Alias()
	lcUniqueName = [_c] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	lcCltJuridicalExpr = []
	lcCltPhysicalExpr = []
	lcClientExpr = []
	*------------------------------------------------------------------------------

	*10.08.2005 16:48 -> Читаем параметры
	If Pcount()=1 And Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)


		*10.08.2005 16:48 -> Формируем фильтр по наименованию клиента
		luQryParCltNMEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCltNMEnabled])
		*24.09.2007 16:48 -> Формируем фильтр по коду клиента
		luQryCltIDEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCltIDEnabled])
		*24.09.2007 16:48 -> Формируем фильтр по карте клиента
		luQryCrdCodEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCrdCodEnabled])
		***
		If !Isnull(luQryParCltNMEnabled) And Type([luQryParCltNMEnabled])==[L] And luQryParCltNMEnabled

			*10.08.2005 16:49 -> Получим наименование клиента
			luQryParCltNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCltNM])
			***
			If !Isnull(luQryParCltNM) And Type([luQryParCltNM])==[C]

				*10.08.2005 16:49 -> Формируем фильтры
				lcCltJuridicalExpr	= [WHERE UPPER(CltJuridical.CltJrdNM) LIKE '%] + Upper(Alltrim(luQryParCltNM)) + [%']
				lcCltPhysicalExpr	= [WHERE UPPER(LTRIM(CASE WHEN NOT CltPhysical.CltPhysFNM IS NULL AND CltPhysical.CltPhysFNM <> '' THEN ' ' + CltPhysical.CltPhysFNM ELSE '' END + ] + ;
					[CASE WHEN NOT CltPhysical.CltPhysINM IS NULL AND CltPhysical.CltPhysINM <> '' THEN ' ' + CltPhysical.CltPhysINM ELSE '' END + ] + ;
					[CASE WHEN NOT CltPhysical.CltPhysONM IS NULL AND CltPhysical.CltPhysONM <> '' THEN ' ' + CltPhysical.CltPhysONM ELSE '' END)) ] + ;
					[LIKE '%] + Upper(Alltrim(luQryParCltNM)) + [%']
				lcClientExpr		= [WHERE UPPER(Client.CltNM) LIKE '%] + Upper(Alltrim(luQryParCltNM)) + [%']
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------
		If !Isnull(luQryCltIDEnabled) And Type([luQryCltIDEnabled])==[L] And luQryCltIDEnabled
			*10.08.2005 16:49 -> Получим код клиента
			luQryCltID = oQryParMgr.ParamGet(tcQryParSID,[qpnCltID])
			***
			If !Isnull(luQryCltID) And Type([luQryCltID])==[C]
				*10.08.2005 16:49 -> Формируем фильтры
				lcClientExpr		=  Iif(Empty(Alltrim(lcClientExpr)),[WHERE ],lcClientExpr+' AND ') + [ Client.CltId = ] + Alltrim(luQryCltID)
			Endif
			*------------------------------------------------------------------------------
		Endif
		*------------------------------------------------------------------------------
		If !Isnull(luQryCrdCodEnabled) And Type([luQryCrdCodEnabled])==[L] And luQryCrdCodEnabled
			*10.08.2005 16:49 -> Получим код клиента
			luQryCrdCode = oQryParMgr.ParamGet(tcQryParSID,[qpcCrdCode])
			***
			If !Isnull(luQryCrdCode) And Type([luQryCrdCode])==[C]
				*10.08.2005 16:49 -> Формируем фильтры
				lcClientExpr		=  Iif(Empty(Alltrim(lcClientExpr)),[WHERE ],lcClientExpr+' AND ') + [ Client.CltId IN (SELECT CardOwnerID FROM Card WHERE  CardCode = '] + Alltrim(luQryCrdCode)+[')]
			Endif
			*------------------------------------------------------------------------------
		Endif
		*------------------------------------------------------------------------------
	Endif
	*------------------------------------------------------------------------------
	lcClientExpr = Iif(Empty(Alltrim(lcClientExpr)),[WHERE 0=1],lcClientExpr)
	lcCltJuridicalExpr = Iif(Empty(Alltrim(lcCltJuridicalExpr)),[WHERE 0=1],lcCltJuridicalExpr)
	lcCltPhysicalExpr = Iif(Empty(Alltrim(lcCltPhysicalExpr)),[WHERE 0=1],lcCltPhysicalExpr)

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spClientView ?lcClientExpr, ?lcCltJuridicalExpr, ?lcCltPhysicalExpr],lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1

		*11.08.2006 16:04 ->Вызовем обработчик ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		*11.08.2006 16:04 ->Создадим пустой курсор
		Create Cursor (lcUniqueName) ( ;
			cltid I, CltNM C(1), CltFullNM C(1), CltINN C(1) ;
			)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	***
	Copy To (lcUniqueFilePath)
	***
	Use In (lcUniqueName)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.08.2005 16:55 -> Закроем файл
	Use In Iif(Used(lcUniqueName),lcUniqueName,0)
	*------------------------------------------------------------------------------

	*10.08.2005 14:58 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*10.08.2005 14:58 -> Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCloseCheck()
* Called by.......: <NA>
* Parameters......: <tnCheckID>
* Returns.........: <none>
* Notes...........: Сброс чека
*------------------------------------------------------------------------------
Procedure spCloseCheck
	Lparameters tnCheckID

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Сбрасываем чек
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[UPDATE CheckSale ] + ;
			[SET CheckTypeID = ABS(CheckTypeID)] + ;
			[WHERE CheckID = ?tnCheckID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------
	Return .T.
Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCopyAccount()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <lnLastFrmID>
* Notes...........: Копирование калькуляционной карты
*------------------------------------------------------------------------------
Procedure spCopyAccount
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation

	*15.12.2004 16:49 ->Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnLastFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Узнаем тип документа
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spCopyAccount ?tnSrcFrmID, ?tnTargetFrmTypeID, ?tcOperation], ;
			[curLastFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	***
	lnLastFrmID = curLastFrmID.frmid
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*15.12.2004 16:50 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*16.12.2004 17:58 ->Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spCouponReport()
* Called by.......: <NA>
* Parameters......: <tnCheckID>
* Returns.........: <none>
* Notes...........: Выборка для отчета по талонам
*------------------------------------------------------------------------------
Procedure spCouponReport
	Lparameters tcQryParSID

	*02.08.2006 09:30 ->Объявление и инициализация переменных
	Local	lcOldDate, ;
		lcOldCentury, ;
		lcOldMark, ;
		lcFilterExpr, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParCashEnabled, ;
		luQryParCashTableNM, ;
		luQryParCashierEnabled, ;
		luQryParCashierTableNM, ;
		luQryParCltIspEnabled, ;
		luQryParIspIDTableNM, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])
	lcFilterExpr = []
	*------------------------------------------------------------------------------

	*02.08.2006 09:30 ->Создаем таблицу с окружением для отчёта
	Create Table Tmp\RptEnv Free (QryParSID C(10))
	Insert Into RptEnv (QryParSID) Values (tcQryParSID)
	*------------------------------------------------------------------------------

	*02.08.2006 09:30 ->Сформируем условия выбора по дате
	luQryParDateEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
	luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
	luQryParDateEndDate   = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
	***
	If !Isnull(luQryParDateEnabled)   And Type([luQryParDateEnabled])==[L]   And luQryParDateEnabled And ;
			!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
			!Isnull(luQryParDateEndDate)   And Type([luQryParDateEndDate])==[D]   And !Empty(luQryParDateEndDate)

		*02.08.2006 09:30 ->Установим формат даты YMD и CENTURY ON
		Set Date YMD
		Set Century On
		Set Mark To "/"
		*------------------------------------------------------------------------------

		*02.08.2006 09:31 ->Сформируем условия выбора
		lcFilterExpr = lcFilterExpr + [ AND CheckSale.CheckStamp >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[' AND CheckSale.CheckStamp < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
		*------------------------------------------------------------------------------

		*02.08.2006 09:31 ->Восстановим старый формат даты
		Set Date (lcOldDate)
		Set Century &lcOldCentury
		Set Mark To lcOldMark
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*02.08.2006 09:33 ->Формируем фильтр по кассе
	luQryParCashEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCashEnabled])
	***
	If !Isnull(luQryParCashEnabled) And Type([luQryParCashEnabled])==[L] And luQryParCashEnabled
		luQryParCashTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCashTableNM])
		If !Isnull(luQryParCashTableNM) And Type([luQryParCashTableNM])==[C] And File(luQryParCashTableNM+[.dbf])
			***
			lcFilterExpr = lcFilterExpr + ;
				[ AND CheckSale.CheckCashID IN (] + spGetTmpValueList(luQryParCashTableNM) + [)]

		Endif
	Endif
	*------------------------------------------------------------------------------

	*02.08.2006 09:34 ->Формируем фильтр по кассе
	luQryParCashierEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCashierEnabled])
	***
	If !Isnull(luQryParCashierEnabled) And Type([luQryParCashierEnabled])==[L] And luQryParCashierEnabled
		luQryParCashierTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCashierTableNM])
		If !Isnull(luQryParCashierTableNM) And Type([luQryParCashierTableNM])==[C] And File(luQryParCashierTableNM+[.dbf])
			***
			lcFilterExpr = lcFilterExpr + ;
				[ AND CheckSale.CheckCashierID IN (] + spGetTmpValueList(luQryParCashierTableNM) + [)]

		Endif
	Endif
	*------------------------------------------------------------------------------

	*02.08.2006 09:34 ->Формируем фильтр по кассиру
	luQryParCashierEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCashierEnabled])
	***
	If !Isnull(luQryParCashierEnabled) And Type([luQryParCashierEnabled])==[L] And luQryParCashierEnabled
		luQryParCashierTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCashierTableNM])
		If !Isnull(luQryParCashierTableNM) And Type([luQryParCashierTableNM])==[C] And File(luQryParCashierTableNM+[.dbf])
			***
			lcFilterExpr = lcFilterExpr + ;
				[ AND CheckSale.CheckCashierID IN (] + spGetTmpValueList(luQryParCashierTableNM) + [)]

		Endif
	Endif
	*------------------------------------------------------------------------------

	*02.08.2006 09:47 ->Формируем фильтр по организации
	luQryParCltIspEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCltIspEnabled])
	***
	If !Isnull(luQryParCltIspEnabled) And Type([luQryParCltIspEnabled])==[L] And luQryParCltIspEnabled
		luQryParIspIDTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCltISpIDTableNM])
		If !Isnull(luQryParIspIDTableNM) And Type([luQryParIspIDTableNM])==[C] And File(luQryParIspIDTableNM+[.dbf])
			***
			lcFilterExpr = lcFilterExpr + ;
				[ AND Coupon.CltID IN (] + spGetTmpValueList(luQryParIspIDTableNM) + [)]

		Endif
	Endif
	*------------------------------------------------------------------------------

	*02.08.2006 09:49 ->Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*02.08.2006 09:49 ->Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spCouponReport ?lcFilterExpr],[RptItog])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*02.08.2006 09:49 ->Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*02.08.2006 09:49 ->Сохраним курсоры на диск и закроем
	Select RptItog
	Copy To Tmp\RptItog.Dbf
	***
	Use In Select([RptItog])
	*------------------------------------------------------------------------------

	*02.08.2006 10:04 ->Индексируем таблицу
	Use RptItog In 0 Exclusive
	Select RptItog
	Index On OrgNM Tag OrgNM
	Index On OrgNM + Rtrim(CouponNM) Tag OrgCoupNM
	***
	Use In Select([RptItog])
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spDiscRecount()
* Called by.......: <NA>
* Parameters......: <tnFrmID, tnCltID>
* Returns.........: <none>
* Notes...........: Пересчет скидки в позициях заказа при смене клиента
*------------------------------------------------------------------------------
Procedure spDiscRecount
	Lparameters tnFrmID, tnCltID

	*--Объявление и инициализация переменных
	Local   lcOldAlias, ;
		lnConnectHandle, ;
		lnSqlExeResult

	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*--Коннектимся к БД через существующее соединение
	Set Database To BASIS
	***
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*--Выполняем процедуру смены скидки
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spDiscRecount ?tnFrmID, ?tnCltID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*--Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*--Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias # Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*--Возвращаем результат
	Return .T.
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFillCorr()
* Called by.......: <Form Data Request>
* Parameters......: <tnFrmID>
* Returns.........: <none>
* Notes...........: Заполнение корректирующего документа
*-------------------------------------------------------
Procedure spFillCorr
	Lparameters tnFrmID

	*08.09.2006 11:25 ->Объявление и инициализация переменных
	Local	lnConnectHandle, ;
		lnSqlExeResult, ;
		llResult
	*------------------------------------------------------------------------------

	*08.09.2006 11:25 ->Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*08.09.2006 11:25 ->Заполненяем корректирующий документа
	lnSqlExeResult = 0
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFillCorr ?tnFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	*------------------------------------------------------------------------------

	*08.09.2006 11:26 ->Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFormCopy()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <lnLastFrmID>
* Notes...........: Копирование документа
*------------------------------------------------------------------------------
Procedure spFormCopy
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation

	*15.12.2004 16:49 ->Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnLastFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	Use Tmp\listadd In 0
	If Reccount('listadd') = 0
		Insert Into listadd Values (tnSrcFrmID)
	Else
		If Messagebox('Объединить помеченые записи?' ,4+32+256+4096 ,'Объединение записей' ,200) = 2
			Use In listadd
			Erase Tmp\listadd.Dbf
			Return
		Endif
	Endif
	*** Создаем XML - документ по помеченым записям
	m.lnCountLine = Cursortoxml("listadd", "lcXML", 1, 0) && так было 16)
	Use In listadd
	Erase Tmp\listadd.Dbf


	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Узнаем тип документа
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFormCopy  ?lcXML, ?tnTargetFrmTypeID, ?tcOperation], ;
			[curLastFrmID])

		**[EXECUTE spFormCopy  ?tnSrcFrmID, ?tnTargetFrmTypeID, ?tcOperation], ;

	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	***
	lnLastFrmID = curLastFrmID.frmid
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*15.12.2004 16:50 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*16.12.2004 17:58 ->Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFormCopyActRule()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <none>
* Notes...........: Копирование расходной накладной в акт производства
*------------------------------------------------------------------------------
Procedure spFormCopyActRule
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation

	*15.12.2004 16:49 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnLastFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFormCopyActRule ?tnSrcFrmID, ?tnTargetFrmTypeID, ?tcOperation], ;
			[curLastFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	***
	lnLastFrmID = curLastFrmID.frmid
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*15.12.2004 16:50 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*16.12.2004 17:58 -> Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFormCopyAuto()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <none>
* Notes...........: Формирует документ с включением в него из источника ;
* только блюд и модификаторов c последующей обработкой
* должно быть настроено копирование форм
*------------------------------------------------------------------------------
Procedure spFormCopyAuto
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation

	*15.12.2004 16:49 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		llIsOnlyBludo, ;
		lnSrcFrmID, ;
		lnLastFrmID, ;
		lnHalfReady, ;
		lnCounter, ;
		lnCirc, ;
		laCirc(1)
	***
	llIsOnlyBludo = .T.
	lnSrcFrmID = tnSrcFrmID
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*19.06.2006 11:20 -> Создаем акт производства с блюдами из текущего документа
	Do While .T.

		*19.06.2006 11:58 -> Выполняем копирование документа
		lnLastFrmID = spFormCopyBludo(lnSrcFrmID,tnTargetFrmTypeID,tcOperation,llIsOnlyBludo)
		llIsOnlyBludo = .F.
		lnCirc = Alen(laCirc)
		laCirc[lnCirc] = lnLastFrmID
		Dimension laCirc(lnCirc+1)
		lnSrcFrmID = lnLastFrmID
		*------------------------------------------------------------------------------

		*19.06.2006 11:58 -> Создаем акт производства
		lnHalfReady = spMakeActPro(lnLastFrmID)
		*------------------------------------------------------------------------------

		*19.06.2006 11:25 -> Проверяем на наличие полуфабрикатов, если их нет - выходим
		If lnHalfReady = 0
			Exit
		Endif
		*------------------------------------------------------------------------------

	Enddo
	*------------------------------------------------------------------------------

	*19.06.2006 12:06 -> Переопределяем цены поступления на продукты и на калькуляцию
	For lnCounter = Alen(laCirc) To 1 Step -1
		lnLastFrmID = laCirc[lnCirc]
		spReqActBay(lnLastFrmID,.F.)
	Endfor
	*------------------------------------------------------------------------------

	*15.12.2004 16:50 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*19.06.2006 12:12 -> Вывод сообщения
	Messagebox([Обработка документов завершена],64,[Информация])
	*------------------------------------------------------------------------------

	*16.12.2004 17:58 -> Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFormCopyBludo()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <none>
* Notes...........: Формирует документ с включением в него из источника ;
* только блюд и модификаторов
* должно быть настроено копирование форм
*------------------------------------------------------------------------------
Procedure spFormCopyBludo
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation,tlIsOnlyBludo

	*15.12.2004 16:49 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnLastFrmID, ;
		llIsOnlyBludo, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	If Pcount() = 3
		llIsOnlyBludo = (Messagebox([Выбирать только полуфабрикаты (без блюд)?],4+32+256, [Вопрос])= 7)
	Else
		llIsOnlyBludo = tlIsOnlyBludo
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFormCopyBludo ?tnSrcFrmID, ?tnTargetFrmTypeID, ?tcOperation, ?llIsOnlyBludo], ;
			[curLastFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	***
	lnLastFrmID = curLastFrmID.frmid
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*15.12.2004 16:50 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*16.12.2004 17:58 -> Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spFormCopyInventory()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <.T./.F.>
* Notes...........: Создание сличительной ведомости на основе инвентаризационной
*------------------------------------------------------------------------------
Procedure spFormCopyInventory
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation

	*11.05.2006 17:13 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnLastFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Узнаем тип документа
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFormCopyInventory ?tnSrcFrmID, ?tnTargetFrmTypeID, ?tcOperation], ;
			[curLastFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	***
	lnLastFrmID = curLastFrmID.frmid
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*11.05.2006 17:13 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*11.05.2006 17:12 -> Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spFormCopyScarce()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <.T./.F.>
* Notes...........: Создание дефицитной ведомости на основе документа
*------------------------------------------------------------------------------
Procedure spFormCopyScarce
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation

	*11.05.2006 17:13 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnLastFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Узнаем тип документа
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFormCopyScarce ?tnSrcFrmID, ?tnTargetFrmTypeID, ?tcOperation], ;
			[curLastFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	***
	lnLastFrmID = curLastFrmID.frmid
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*11.05.2006 17:13 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*11.05.2006 17:12 -> Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spFormJoin()
* Called by.......: <NA>
* Parameters......: <tnSrcFrmID,tnTargetFrmTypeID,tcOperation>
* Returns.........: <.T./.F.>
* Notes...........: Создание дефицитной ведомости на основе документа
*------------------------------------------------------------------------------
Procedure spFormJoin
	Lparameters tnSrcFrmID,tnTargetFrmTypeID,tcOperation
	*11.05.2006 17:13 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnLastFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	Use Tmp\listadd In 0
	If Reccount('listadd') = 0
		Insert Into listadd Values (tnSrcFrmID)
	Else
		If Messagebox('Объединить помеченые записи?' ,4+32+256+4096 ,'Объединение записей' ,2000) = 2
			Use In listadd
			Erase Tmp\listadd.Dbf
			Return
		Endif
	Endif
	*** Создаем XML - документ по помеченым записям
	m.lnCountLine = Cursortoxml("listadd", "lcXML", 1, 0) && так было 16)
	Use In listadd
	Erase Tmp\listadd.Dbf
	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Узнаем тип документа
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFormJoin ?lcXML, ?tnTargetFrmTypeID], ;
			[curLastFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	***
	lnLastFrmID = curLastFrmID.frmid
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*11.05.2006 17:13 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*11.05.2006 17:12 -> Вернем идентификатор вновь добавленного докумета
	Return lnLastFrmID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmAccCardPrint()
* Called by.......: <When Document Printed>
* Parameters......: <tnFrmID, tlAddSignature>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати внешних документов содержащих товары
*------------------------------------------------------------------------------
Procedure spFrmAccCardPrint
	Lparameters tcQryParSID

	*11.05.2005 12:53 -> Объявление и инициализация переменных
	Local	lnFrmID, ;
		llAddSignature, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*11.05.2005 12:54 -> Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*26.05.2004 21:18 -> Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

		*11.05.2005 12:55 -> Читаем состояние флажка "С печатью/Без печати"
		llAddSignature = oQryParMgr.ParamGet(tcQryParSID,[qplAddSign])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmAccCardPrint ?lnFrmID, ?llAddSignature],[RptItogHD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	SQLMoreResults(lnConnectHandle,[RptItogDT])
	SQLMoreResults(lnConnectHandle,[RptItogPrc])
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItogHD
	Copy To Tmp\RptItogHD.Dbf
	***
	Select RptItogDT
	Copy To Tmp\RptItogDT.Dbf
	***
	Select RptItogPrc
	Copy To Tmp\RptItogPrc.Dbf
	***
	Use In Select([RptItogHD])
	Use In Select([RptItogDT])
	Use In Select([RptItogPrc])
	*------------------------------------------------------------------------------

	*24.04.2006 13:59 -> Откроем сохраненные на диск таблицы
	Use Tmp\RptItogHD In 0
	Use Tmp\RptItogDT In 0
	Use Tmp\RptItogPrc In 0
	*------------------------------------------------------------------------------

	*05.08.2004 15:42 -> Составим список идентификаторов клиентов, упоминающихся в документе
	Select ;
		RptItogHD.cltid As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.OwnCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.DevCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExEmiCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExIspCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.CntCltID As Id ;
		FROM RptItogHD ;
		INTO Table Tmp\tmpCltIdList
	*------------------------------------------------------------------------------

	*05.08.2004 15:54 ->Получим подробные данные по клиентам
	spClientInfoExpand([tmpCltIdList],[RptCltInfo])
	*------------------------------------------------------------------------------

	*22.07.2004 20:50 -> Вернем список временных файлов, созданных для отчета
	Return [RPTITOGHD.DBF;RPTITOGDT.DBF;RptCltInfo.dbf;RptCltInfo.cdx;RPTITOGPRC.DBF]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmAccCardReport()
* Called by.......: <When Document Printed>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати калькуляционных карт по актам производства
*------------------------------------------------------------------------------
Procedure spFrmAccCardReport
	Lparameters tcQryParSID

	*11.05.2005 12:53 -> Объявление и инициализация переменных
	Local	lnFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*11.05.2005 12:54 -> Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*26.05.2004 21:18 -> Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmAccCardReport ?lnFrmID],[RptItogHD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	lnSqlExeResult = SQLMoreResults(lnConnectHandle,[RptItogDT])
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------


	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItogHD
	Copy To Tmp\RptItogHD.Dbf
	***
	Select RptItogDT
	Copy To Tmp\RptItogDT.Dbf
	***
	Use In Select([RptItogHD])
	Use In Select([RptItogDT])

	*24.04.2006 13:59 -> Откроем сохраненные на диск таблицы
	Use Tmp\RptItogHD In 0 Exclusive
	Use Tmp\RptItogDT In 0 Exclusive
	*------------------------------------------------------------------------------

	*04.09.2006 11:44 -> Создадим индекс для Relation-а
	Select RptItogHD
	Index On frmid Tag frmid Of Tmp\RptItogHD
	*------------------------------------------------------------------------------

	*05.08.2004 15:42 -> Составим список идентификаторов клиентов, упоминающихся в документе
	Select ;
		RptItogHD.OwnCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.DevCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExIspCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.CntCltID As Id ;
		FROM RptItogHD ;
		INTO Table Tmp\tmpCltIdList
	*------------------------------------------------------------------------------

	*05.08.2004 15:54 ->Получим подробные данные по клиентам
	spClientInfoExpand([tmpCltIdList],[RptCltInfo])
	*------------------------------------------------------------------------------

	*22.07.2004 20:50 -> Вернем список временных файлов, созданных для отчета
	Return [RPTITOGHD.DBF;RPTITOGHD.CDX;RPTITOGDT.DBF;RptCltInfo.dbf;RptCltInfo.cdx]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures For Basis
* Module/Procedure: spFrmAutoNum()
* Called by.......: <NA>
* Parameters......: <tnFrmTypeID,tnPointEmiOUID,tnPointIspOUID,tdDate>
* Returns.........: <lcFrmNum>
* Notes...........: Автонумератор
*------------------------------------------------------------------------------
Procedure spFrmAutoNum
	Lparameters tnFrmTypeID,tdDate,tnPointEmiOUID,tnPointIspOUID,tnFrmID
	If Pcount()<5
		tnFrmID = 0
	Endif
	*21.12.2004 18:09 ->Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnConnectHandle, ;
		lnSqlExeResult, ;
		lnOUID, ;
		lnOwnCltID, ;
		lcMask, ;
		lcFrmNum, ;
		lnStartPos, ;
		lnEndPos, ;
		lcSerialSection, ;
		lcSerialSectionValue, ;
		lnCounter
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Узнаем тип документа
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[SELECT ] + ;
			[FrmType.FrmTypeDirection ] + ;
			[FROM FrmType ] + ;
			[WHERE FrmType.FrmTypeID = ?tnFrmTypeID], ;
			[curFrmType])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return [б\н]
	Endif
	*------------------------------------------------------------------------------

	*21.12.2004 18:08 ->Вычисляем код подразделения
	lnOUID = Iif(curFrmType.FrmTypeDirection=2,tnPointIspOUID,tnPointEmiOUID)
	***
	If lnOUID = 0
		Return [б\н]
	Endif
	*------------------------------------------------------------------------------

	*22.12.2004 10:06 -> Закрываем курсор curFrmType
	Use In Select([curFrmType])
	*------------------------------------------------------------------------------

	*21.12.2004 18:18 ->Вычисляем идентификатор родителя подразделения
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[SELECT ] + ;
			[OrgUnit.CltID ] + ;
			[FROM OrgUnit ] + ;
			[WHERE OrgUnit.OUID = ?lnOUID], ;
			[curOrgUnit])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return [б\н]
	Endif
	***
	lnOwnCltID = curOrgUnit.cltid
	***
	If Empty(lnOwnCltID)
		*ASSERT .F. MESSAGE [STORED PROCEDURES FOR BASIS: невозможно сгенерировать номер по подразделению, не имеющему родителя-клиента]
		Return [б\н]
	Endif
	*------------------------------------------------------------------------------

	*22.12.2004 10:06 -> Закрываем курсор curOrgUnit
	Use In Select([curOrgUnit])
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Получим параметры автонумерации
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmAutoNum ?tnFrmTypeID, ?lnOUID], ;
			[curFrmTypeAutoNum])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return [б\н]
	Endif
	***
	If Reccount([curFrmTypeAutoNum])#1
		Messagebox('Нумерацию этого типа документа необходимо настроить...',0+64,'Обратитесь к администратору',5000)
		**ASSERT .F. MESSAGE [STORED PROCEDURES FOR BASIS: не найден параметр автонумератора для данного типа документа]
		**RETURN [ERROR]
		Return [б\н]
	Endif
	*------------------------------------------------------------------------------

	*21.12.2004 18:23 ->Генерируем счётчик
	lcFrmNum = []
	***
	If !Empty(curFrmTypeAutoNum.AutoNumMask) And curFrmTypeAutoNum.AutoNumIsEnabled
		lcFrmNum = Alltrim(curFrmTypeAutoNum.AutoNumMask)
		Do While [{]$lcFrmNum And [}]$lcFrmNum
			lnStartPos = At([{],lcFrmNum)
			lnEndPos = At([}],lcFrmNum)
			***
			If lnStartPos > lnEndPos
				Messagebox('Нумерацию этого типа документа необходимо настроить...',0+64,'Обратитесь к администратору',5000)
				*ASSERT .F. MESSAGE [STORED PROCEDURES FOR BASIS: некорректная маска автонумератора]
				*RETURN [ERROR]
				Return [б\н]
			Endif
			***
			lcSerialSection = Substr(lcFrmNum,lnStartPos+1,lnEndPos-lnStartPos-1)
			***
			Do Case
			Case Upper(lcSerialSection)==[NFRMIF]
				lcSerialSectionValue = Alltrim(Str(tnFrmID,10,0))
			Case Upper(lcSerialSection)==[YYYY]
				lcSerialSectionValue = Alltrim(Str(Year(tdDate)))
			Case Upper(lcSerialSection)==[YY]
				lcSerialSectionValue = Right(Alltrim(Str(Year(tdDate))),2)
			Case Upper(lcSerialSection)==[MM]
				lcSerialSectionValue = Alltrim(Str(Month(tdDate)))
			Case Upper(lcSerialSection)==[DD]
				lcSerialSectionValue = Alltrim(Str(Day(tdDate)))
			Case [n]$lcSerialSection Or [N]$lcSerialSection
				lnCounter = spFrmAutoNumGetCounter(Iif(curFrmTypeAutoNum.FrmTypeIDIsConst,curFrmTypeAutoNum.FrmTypeIDConst,tnFrmTypeID), ;
					IIF(curFrmTypeAutoNum.OwnCltIDIsConst,curFrmTypeAutoNum.OwnCltIDConst,lnOwnCltID), ;
					IIF(curFrmTypeAutoNum.OUIDIsConst,curFrmTypeAutoNum.OUIDConst,lnOUID))
				***
				If [N]$lcSerialSection
					lcSerialSectionValue = Padl(Alltrim(Str(lnCounter)),lnEndPos-lnStartPos-1,[0])
				Else
					lcSerialSectionValue = Alltrim(Str(lnCounter))
				Endif
			Otherwise
				lcSerialSectionValue = []
			Endcase
			***
			lcFrmNum = Stuff(lcFrmNum,lnStartPos,lnEndPos-lnStartPos+1,lcSerialSectionValue)
		Enddo
	Endif
	*------------------------------------------------------------------------------

	*22.12.2004 10:07 -> Закрываем таблицы
	Use In Iif(Used([curFrmTypeAutoNum]),[curFrmTypeAutoNum],0)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*23.12.2004 12:06 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*21.12.2004 19:01 ->Вернём сгенерированный номер
	Return lcFrmNum
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmAutoNumGetCounter()
* Called by.......: spFrmAutoNum()
* Parameters......: <tnFrmTypeID,tnOwnCltID,tnOUID>
* Returns.........: <lnCounter>
* Notes...........: Возвращаем счетчик автонумератора
*------------------------------------------------------------------------------
Procedure spFrmAutoNumGetCounter
	Lparameters tnFrmTypeID,tnOwnCltID,tnOUID

	*27.06.2006 15:17 -> Объявление и инициализация переменных
	Local 	lcOldAlias, ;
		lnConnectHandle, ;
		lnSqlExeResult, ;
		lnLastID, ;
		lnCounter
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Получим параметры автонумерации
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmAutoNumGetCounter ?tnFrmTypeID, ?tnOwnCltID, ?tnOUID], ;
			[curFrmNumCounter])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	***
	lnCounter = curFrmNumCounter.FrmNumCntVal
	***
	Use In Select([curFrmNumCounter])
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*23.12.2004 12:14 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*22.12.2004 12:15 -> Возвращаем значение счетчика
	Return lnCounter
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: SPFRMEXTERNALPARTFRMPRINT()
* Called by.......: <When Document Printed>
* Parameters......: <tnFrmID, tlAddSignature>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати внешних документов содержащих документы (суммы)
*-------------------------------------------------------
Procedure spFrmExternalPartFrmPrint
	Lparameters tcQryParSID

	*11.05.2005 12:53 ->Объявление и инициализация переменных
	Local	lnFrmID, ;
		llAddSignature, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*11.05.2005 12:54 ->Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*26.05.2004 21:18 ->Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

		*11.05.2005 12:55 ->Читаем состояние флажка "С печатью/Без печати"
		llAddSignature = oQryParMgr.ParamGet(tcQryParSID,[qplAddSign])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmExternalPartFrmPrint ?lnFrmID, ?llAddSignature],[RptItogHD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	SQLMoreResults(lnConnectHandle,[RptItogDT])
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItogHD
	Copy To Tmp\RptItogHD.Dbf
	***
	Select RptItogDT
	Copy To Tmp\RptItogDT.Dbf
	***
	Use In Select([RptItogHD])
	Use In Select([RptItogDT])
	*------------------------------------------------------------------------------

	*24.04.2006 13:59 -> Откроем сохраненные на диск таблицы
	Use Tmp\RptItogHD In 0
	Use Tmp\RptItogDT In 0
	*------------------------------------------------------------------------------

	*05.08.2004 15:42 ->Составим список идентификаторов клиентов, упоминающихся в документе
	Select ;
		RptItogHD.cltid As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.OwnCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.DevCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExEmiCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExIspCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.CntCltID As Id ;
		FROM RptItogHD ;
		INTO Cursor curCltIdList
	*------------------------------------------------------------------------------

	*21.04.2006 17:34 -> Получим подробные данные по клиентам
	spClientInfoExpand([curCltIdList],[RptCltInfo])
	*------------------------------------------------------------------------------

	*23.09.2004 17:24 ->Составим список идентификаторов расчётных счетов клиентов
	Select ;
		RptItogHD.CltSAccID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.OwnSAccID As Id ;
		FROM RptItogHD ;
		INTO Cursor curSAccIdList
	*------------------------------------------------------------------------------

	*21.04.2006 17:34 -> Получим подробные данные по расчётным счетам
	spSAccInfoExpand([curSAccIdList],[RptSAccInfo])
	*------------------------------------------------------------------------------

	*22.07.2004 20:50 -> Вернем список временных файлов, созданных для отчета
	Return [RptItogHD.dbf;RptItogDT.DBF;RptCltInfo.dbf;RptCltInfo.cdx;RptSAccInfo.dbf;RptSAccInfo.cdx]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmExternalPartFrmPrintDetail()
* Called by.......: <When Document Printed>
* Parameters......: <tnFrmID, tlAddSignature>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати документов содержащих данные в таблице FrmPayDetail
*-------------------------------------------------------
Procedure spFrmExternalPartFrmPrintDetail
	Lparameters tcQryParSID

	*11.05.2005 12:53 ->Объявление и инициализация переменных
	Local	lcResult, ;
		lnFrmID, ;
		llAddSignature, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*12.01.2005 10:35 -> Вызываем процедуру выборки формирующую данные без FrmPayDetail
	lcResult = spFrmExternalPartFrmPrint(tcQryParSID)
	*------------------------------------------------------------------------------

	*11.05.2005 12:54 ->Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*26.05.2004 21:18 ->Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

		*11.05.2005 12:55 ->Читаем состояние флажка "С печатью/Без печати"
		llAddSignature = oQryParMgr.ParamGet(tcQryParSID,[qplAddSign])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmExternalPartFrmPrintDetail ?lnFrmID],[RptItogPD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсор на диск и закроем
	Select RptItogPD
	Copy To Tmp\RptItogPD.Dbf
	***
	Use In Select([RptItogPD])
	*------------------------------------------------------------------------------

	*24.04.2006 13:59 -> Откроем сохраненную на диск таблицу
	Use Tmp\RptItogPD In 0
	*------------------------------------------------------------------------------

	*12.01.2005 10:48 -> Вернем список временных файлов, созданных для отчета
	Return lcResult + [;RPTITOGPD.DBF]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmExternalPartTvrPrint()
* Called by.......: <When Document Printed>
* Parameters......: <tnFrmID, tlAddSignature>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати внешних документов содержащих товары
*------------------------------------------------------------------------------
Procedure spFrmExternalPartTvrPrint
	Lparameters tcQryParSID

	*11.05.2005 12:53 -> Объявление и инициализация переменных
	Local	lnFrmID, ;
		llAddSignature, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*11.05.2005 12:54 ->Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*26.05.2004 21:18 ->Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

		*11.05.2005 12:55 ->Читаем состояние флажка "С печатью/Без печати"
		llAddSignature = oQryParMgr.ParamGet(tcQryParSID,[qplAddSign])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmExternalPartTvrPrint ?lnFrmID, ?llAddSignature],[RptItogHD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	SQLMoreResults(lnConnectHandle,[RptItogDT])
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItogHD
	Copy To Tmp\RptItogHD.Dbf
	***
	Select RptItogDT
	Copy To Tmp\RptItogDT.Dbf
	***
	Use In Select([RptItogHD])
	Use In Select([RptItogDT])
	*------------------------------------------------------------------------------

	*24.04.2006 13:59 -> Откроем сохраненные на диск таблицы
	Use Tmp\RptItogHD In 0 Exclusive
	Use Tmp\RptItogDT In 0 Exclusive
	***
	Select RptItogDT
	Index On TvrNm Tag TvrNm
	Set Order To
	*------------------------------------------------------------------------------

	*05.08.2004 15:42 -> Составим список идентификаторов клиентов, упоминающихся в документе
	Select ;
		RptItogHD.cltid As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.OwnCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.DevCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExEmiCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExIspCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.CntCltID As Id ;
		FROM RptItogHD ;
		INTO Cursor curCltIdList
	*------------------------------------------------------------------------------

	*21.04.2006 17:34 -> Получим подробные данные по клиентам
	spClientInfoExpand([curCltIdList],[RptCltInfo])
	*------------------------------------------------------------------------------

	*23.09.2004 17:24 -> Составим список идентификаторов расчётных счетов клиентов
	Select ;
		RptItogHD.CltSAccID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.OwnSAccID As Id ;
		FROM RptItogHD ;
		INTO Cursor curSAccIdList
	*------------------------------------------------------------------------------

	*21.04.2006 17:34 -> Получим подробные данные по расчётным счетам
	spSAccInfoExpand([curSAccIdList],[RptSAccInfo])
	*------------------------------------------------------------------------------

	*22.07.2004 20:50 -> Вернем список временных файлов, созданных для отчета
	Return [RptItogHD.dbf;RptItogDT.DBF;RptCltInfo.dbf;RptCltInfo.cdx;RptSAccInfo.dbf;RptSAccInfo.cdx]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmInternalPartTvrPrint()
* Called by.......: <When Document Printed>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати внутренних документов содержащих товары
*-------------------------------------------------------
Procedure spFrmInternalPartTvrPrint
	Lparameters tcQryParSID

	*11.05.2005 12:53 ->Объявление и инициализация переменных
	Local	lnFrmID, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*11.05.2005 12:54 ->Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*26.05.2004 21:18 ->Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------
	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmInternalPartTvrPrint ?lnFrmID],[RptItogHD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	SQLMoreResults(lnConnectHandle,[RptItogDT])
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItogHD
	Copy To Tmp\RptItogHD.Dbf
	***
	Select RptItogDT
	Copy To Tmp\RptItogDT.Dbf
	***
	Use In Select([RptItogHD])
	Use In Select([RptItogDT])
	*------------------------------------------------------------------------------

	*24.04.2006 13:59 -> Откроем сохраненные на диск таблицы
	Use Tmp\RptItogHD In 0 Exclusive
	Use Tmp\RptItogDT In 0 Exclusive
	*------------------------------------------------------------------------------

	*05.08.2004 15:42 -> Составим список идентификаторов клиентов, упоминающихся в документе
	Select ;
		RptItogHD.OwnCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.DevCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExEmiCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.ExIspCltID As Id ;
		FROM RptItogHD ;
		UNION ;
		SELECT ;
		RptItogHD.CntCltID As Id ;
		FROM RptItogHD ;
		INTO Cursor curCltIdList
	*------------------------------------------------------------------------------

	*05.08.2004 15:54 -> Получим подробные данные по клиентам
	spClientInfoExpand([curCltIdList],[RptCltInfo])
	*------------------------------------------------------------------------------

	*26.05.2006 10:41 -> Создаем индексы
	Select RptItogDT
	Index On Str(TvrCalc,10) + Iif(TvrQnt>0,[1],[2]) Tag TvrCalc Compact
	Index On Str(Nvl(MenuRate,0),10,3)+ Alltrim(TvrNm) Tag TvrMenu Compact
	Index On Alltrim(TvrNm) Tag TvrNm Compact
	Set Order To
	*INDEX ON STR(TvrCalc,10) + STR(tvridcalc,10) + IIF(TvrQnt>0,[1],[2]) TAG TvrCalc COMPACT
	*------------------------------------------------------------------------------

	*22.07.2004 20:50 ->Вернем список временных файлов, созданных для отчета
	Return [RPTITOGHD.DBF;RPTITOGDT.DBF;RptCltInfo.dbf;RptCltInfo.cdx]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored procedures for Basis
* Module/Procedure: spFrmInventoryPrint()
* Called by.......: <NA>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для отчета "Инвентаризационная ведомость"
*------------------------------------------------------------------------------
Procedure spFrmInventoryPrint
	Lparameters tcQryParSID

	*12.05.2006 11:02 -> Объявление и инициализация переменных
	Local	lnFrmID, ;
		lcOldAlias, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*12.05.2006 11:02 -> Создаем таблицу с окружением для отчёта
	Create Table Tmp\RptEnv Free (QryParSID C(10))
	Insert Into RptEnv (QryParSID) Values (tcQryParSID)
	*------------------------------------------------------------------------------

	*12.05.2006 11:02 ->Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*12.05.2006 11:02 -> Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmInventoryPrint ?lnFrmID],[RptItogHD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	SQLMoreResults(lnConnectHandle,[InvTotal])
	SQLMoreResults(lnConnectHandle,[RptItogDT])
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItogHD
	Copy To Tmp\RptItogHD.Dbf
	***
	Select InvTotal
	Copy To Tmp\InvTotal.Dbf
	***
	Select RptItogDT
	Copy To Tmp\RptItogDT.Dbf
	***
	Use In Select([RptItogHD])
	Use In Select([InvTotal])
	Use In Select([RptItogDT])
	*------------------------------------------------------------------------------

	*30.06.2006 13:25 -> Убираем повторяющеися значения
	*------------------------------------------------------------------------------

	*12.05.2006 11:29 -> Закроем таьлицы
	Use In Select([RptEnv])
	Use In Select([RptItogDT])
	*------------------------------------------------------------------------------

	*12.05.2006 11:29 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*12.05.2006 11:29 -> Вернем список временных таблиц для построения отчета
	Return [RptItogHD.dbf;RptItogDT.dbf;InvTotal.dbf;RptEnv.dbf]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmPartFrmView()
* Called by.......: <NA>
* Parameters......: <tcExecVar[,tuFrmID[,tuFrmPartFrmID]]>
*					<[NODATA]>
*					<[BYFRMID],tnFrmID>
*					<[BYFRMPARTFRMID],tnFrmID,tnFrmPartFrmID>
* Returns.........: <lcUniqueFileName>
* Notes...........: Получение данных для просмотра суммовых позиций документа
*-------------------------------------------------------
Procedure spFrmPartFrmView
	Lparameters tcExecVar,tuFrmID,tuFrmPartFrmID

	*21.04.2004 12:31 ->Объявление и инициализация переменных
	Local	lcUniqueName, ;
		lcUniqueFilePath, ;
		lcFilterExpr, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcUniqueName = [_d] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------

	*21.04.2004 12:33 ->Формируем фильтры в зависимости от типа запроса
	Do Case

	Case Type([tcExecVar])==[C] And tcExecVar==[NODATA]

		*21.04.2004 12:34 ->Формируем фильтр, для формирования пустой выборки
		lcFilterExpr = [WHERE 0=1]
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFRMID]

		*21.04.2004 12:32 ->Формируем фильтр для выбора суммовых позиций одного документа
		lcFilterExpr = [WHERE FrmPartFrm.FrmID = ]+Alltrim(Str(tuFrmID))
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFRMPARTFRMID]

		*21.04.2004 12:32 ->Формируем фильтр для выбора суммовых позиций одного документа
		lcFilterExpr = 	[WHERE FrmPartFrm.FrmID = ] + Alltrim(Str(tuFrmID)) + [ ] + ;
			[AND FrmPartFrm.FrmPartFrmID = ] + Alltrim(Str(tuFrmPartFrmID))
		*------------------------------------------------------------------------------

	Endcase
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ] + ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmPartFrmView ?lcFilterExpr],lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1

		*11.08.2006 15:29 ->Вызовем обработчик ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		*11.08.2006 15:30 ->Создадим пустой курсор
		Create Cursor (lcUniqueName) ( ;
			PartFrmID I, CntFrmNM C(1), CntFrmSum I, CntFrmVAT I, CntFrmId I, FrmNote C(100) ;
			)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	***
	Copy To (lcUniqueFilePath)
	***
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 ->Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmPartTvrView()
* Called by.......: <NA>
* Parameters......: <tcExecVar[,tuFrmID[,tnFrmPartFrmID]]>
*					<[NODATA]>
*					<[BYFRMID],tnFrmID>
*					<[BYFRMPARTTVRID],tnFrmID,tnFrmPartTvrID>
* Returns.........: <lcUniqueFileName>
* Notes...........: Получение данных для просмотра товарных позиций документа
*-------------------------------------------------------
Procedure spFrmPartTvrView
	Lparameters tcExecVar,tuFrmID,tuFrmPartTvrID

	*21.04.2004 12:31 ->Объявление и инициализация переменных
	Local	lcUniqueName, ;
		lcUniqueFilePath, ;
		lcFilterExpr, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcUniqueName = [_d] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------

	*21.04.2004 12:33 ->Формируем фильтры в зависимости типы запроса
	Do Case
	Case Type([tcExecVar])==[C] And tcExecVar==[NODATA]

		*21.04.2004 12:34 ->Формируем фильтр, для формирования пустой выборки
		lcFilterExpr = [WHERE 0=1]
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFRMID]

		*21.04.2004 12:32 ->Формируем фильтр для выбора товарных позиций одного документа
		lcFilterExpr = [WHERE  FrmID = ]+Alltrim(Str(tuFrmID))
		*		lcFilterExpr = [WHERE FrmPartTvr.FrmID = ]+ALLTRIM(STR(tuFrmID))
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFRMPARTTVRID]

		*21.04.2004 12:32 ->Формируем фильтр для выбора суммовых позиций одного документа
		lcFilterExpr = 	[WHERE  FrmID = ] + Alltrim(Str(tuFrmID)) + ;
			[AND  PartTvrID = ] + Alltrim(Str(tuFrmPartTvrID))
		*						[AND  FrmPartTvrID = ] + ALLTRIM(STR(tuFrmPartTvrID))
		*		lcFilterExpr = 	[WHERE FrmPartTvr.FrmID = ] + ALLTRIM(STR(tuFrmID)) + ;
		*						[AND FrmPartTvr.FrmPartTvrID = ] + ALLTRIM(STR(tuFrmPartTvrID))
		*------------------------------------------------------------------------------

	Endcase
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spFrmPartTvrView ?lcFilterExpr],lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1

		*11.08.2006 15:37 ->Вызовем обработчик ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		*11.08.2006 15:30 ->Создадим пустой курсор
		Create Cursor (lcUniqueName) ( ;
			PartTvrID I, TvrTypeID I, TvrIdCalc I, TvrID I, TvrNm C(1), TvrQnt I, TvrQntNett I, ;
			MsuShortNM C(1), TvrPrcBuy I, TvrSumBuy I, TvrPrcSale I, TvrSumSale I, MsuID I, frmid I, DiscPerc I , DeltaSumm I, DeltaPrc I ;
			)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	***
	Copy To (lcUniqueFilePath)
	***
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 ->Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spFrmPrBookView()
* Called by.......: <NA>
* Parameters......: <tcExecVar[,tuFrmID[,tnFrmPartFrmID]]>
*					<[NODATA]>
*					<[BYFRMID],tnFrmID>
*					<[BYFRMPARTTVRID],tnFrmID,tnFrmPartID>
* Returns.........: <lcUniqueFileName>
* Notes...........: Получение данных для просмотра проводок соответствующих документу
*-------------------------------------------------------
Procedure spFrmPrBookView
	Lparameters tcExecVar,tuFrmID,tuFrmPartID

	*05.08.2006 12:31 ->Объявление и инициализация переменных
	Local	lcUniqueName, ;
		lcUniqueFilePath, ;
		lcFilterExpr, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcUniqueName = [_d] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------
	*05.08.2006 12:33 ->Формируем фильтры в зависимости типы запроса
	Do Case
	Case Type([tcExecVar])==[C] And tcExecVar==[NODATA]

		*05.08.2006 12:34 ->Формируем фильтр, для формирования пустой выборки
		lcFilterExpr = [WHERE 0=1]
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFRMID]

		*05.08.2006 12:32 ->Формируем фильтр для выбора товарных позиций одного документа
		lcFilterExpr = [WHERE FrmPrBookView.PBookFrmID = ]+Alltrim(Str(tuFrmID))
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFRMPARTID]

		*05.08.2006 12:32 ->Формируем фильтр для выбора суммовых позиций одного документа
		lcFilterExpr = 	[WHERE FrmPrBookView.PBookID = ] + Alltrim(Str(tuFrmPartID))
		*------------------------------------------------------------------------------

	Endcase
	*------------------------------------------------------------------------------

	*05.08.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*05.08.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)

		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[ SELECT * FROM FrmPrBookView ] + lcFilterExpr ,lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1
		*11.08.2006 15:37 ->Вызовем обработчик ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		*11.08.2006 15:30 ->Создадим пустой курсор
		Create Cursor (lcUniqueName) ( ;
			PBookID I, PBookFrmId I, PBookSum Y, Debet I, Credit I, PBookProvID I, DebetID I, CreditID I, FrmPartId I ,PBookNote C(40);
			)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*05.08.2006 14:07 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	***
	Copy To (lcUniqueFilePath)
	***
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*05.08.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*05.08.2006 14:27 ->Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spGetAccNetto()
* Called by.......: <NA>
* Parameters......: <tnFrmID>
* Returns.........: <none>
* Notes...........: Определяем нетто и себестоимость для всего блюда
*------------------------------------------------------------------------------
Procedure spGetAccNetto
	Lparameters tnFrmID

	*09.06.2006 16:20 -> Объявление и инициализация переменных
	Local	lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[UPDATE Accounting SET ] + ;
			[AccPrice = AccExit.Price, ] + ;
			[AccNetto = AccExit.Netto ] + ;
			[FROM ( ] + ;
			[SELECT ] + ;
			[SUM(FrmPartTvr.TvrQnt*FrmPartTvr.TvrPrcBuy) AS Price, ] + ;
			[SUM(FrmPartTvr.TvrQntNetto) AS Netto ] + ;
			[FROM FrmPartTvr ] + ;
			[INNER JOIN Tovar ON Tovar.TvrID = FrmPartTvr.TvrID ] + ;
			[WHERE FrmPartTvr.FrmID = ?tnFrmID AND Tovar.TvrTypeID <> 6) AS AccExit ] + ;
			[WHERE Accounting.AccFrmID = ?tnFrmID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetBaseMsuList()
* Called by.......: <NA>
* Parameters......: <tnMsuID>
* Returns.........: <none>
* Notes...........:
*------------------------------------------------------------------------------
Procedure spGetBaseMsuList
	Lparameters tnMsuID

	*11.01.2006 15:42 -> Объявление и инициализация переменных
	Local   lcDependentName, ;
		lcIndependentName, ;
		lcDependentFilePath, ;
		lcIndependentFilePath, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcDependentName   = [_sp]+Sys(2015)
	lcIndependentName = [_sp]+Sys(2015)
	lcDependentFilePath   = [tmp\] + lcDependentName + [.dbf]
	lcIndependentFilePath = [tmp\] + lcIndependentName + [.dbf]
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spGetBaseMsuList ?tnMsuID],lcDependentName)
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	SQLMoreResults(lnConnectHandle,lcIndependentName)
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select (lcDependentName)
	Copy To (lcDependentFilePath)
	***
	Select (lcIndependentName)
	Copy To (lcIndependentFilePath)
	***
	Use In Select(lcDependentName)
	Use In Select(lcIndependentName)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 -> Вернем имена таблиц
	Return lcIndependentName+[;]+lcDependentName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spRentaStat()
* Called by.......: <When Document Printed>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для печати отчёта по продажам оборудования в прокат
*-----------------------------------------------------------------------------------
Procedure spGetCardInfo
	Lparameters lnCardId

	*21.04.2004 12:31 -> Объявление и инициализация переменных
	Local	lcValueList, ;
		lnConnectHandle, ;
		lnSqlExeResult,;
		wkdate
	***
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])



	*21.04.2006 10:33 -> Установим формат даты YMD и CENTURY ON
	Set Date YMD
	***
	Set Century On
	***
	Set Mark To "/"
	*------------------------------------------------------------------------------
	wkdate =Strtran(Dtoc(Datetime()),[/],[])
	*21.04.2006 10:33 -> Восстановим старый формат даты
	Set Date (lcOldDate)
	***
	Set Century &lcOldCentury
	***
	Set Mark To lcOldMark
	*------------------------------------------------------------------------------

	*------------------------------------------------------------------------------


	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.T.)
	*------------------------------------------------------------------------------
	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***

	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spAccessCount ?lnCardId,	?wkdate, 0,24],[RptItog])
	Enddo


	If lnSqlExeResult = -1
		Create Table Tmp\RptItog Free (CardID I, CardCode C(1), CardNo C(1), CardOwID I,;
			CardNote C(1), CardIsAct L, BdCntToday I, BdCnt I)
		*spHandleODBCError()
		*RETURN .F.
	Else
		Select RptItog
		Copy To Tmp\RptItog.Dbf
	Endif
	*------------------------------------------------------------------------------


	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------
	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	***
	Use In Select([RptItog])

	*26.01.2005 19:10 -> Вернем список файлов созданных для отчета
	Return [RptItog.dbf]  &&;RptItog.cdx]
	*------------------------------------------------------------------------------
Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spGetCfMsu()
* Called by.......: <NA>
* Parameters......: <tnOldMsuID, tnCurMsuID>
* Returns.........: <поправочный коэффициент для цены>
* Notes...........: Перевод из одной ЕИ в другую
*------------------------------------------------------------------------------
Procedure spGetCfMsu
	Lparameters tnOldMsuID, tnCurMsuID

	*09.06.2006 15:50 -> Объявление и инициализация переменных
	Local	lnCfBaseMsu, ;
		lnCfTargMsu, ;
		lnResultCf, ;
		lnSqlExeResult, ;
		llResult
	***
	lnCfBaseMsu = 000000000.00000
	lnCfTargMsu = 000000000.00000
	lnResultCf  = 000000000.00000
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Определяем коэффициент для текущей ЕИ
	lnSqlExeResult = 0
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[SELECT ] + ;
			[MeasureUnit.MsuQnt ] + ;
			[FROM MeasureUnit ] + ;
			[WHERE MeasureUnit.MsuID = ?tnOldMsuID], ;
			[curOldMsuID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	***
	lnCfBaseMsu = curOldMsuID.MsuQnt
	***
	Use In Select([curOldMsuID])
	*------------------------------------------------------------------------------

	*09.06.2006 16:02 -> Определяем коэффициент для целевой ЕИ
	lnSqlExeResult = 0
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[SELECT ] + ;
			[MeasureUnit.MsuQnt ] + ;
			[FROM MeasureUnit ] + ;
			[WHERE MeasureUnit.MsuID = ?tnCurMsuID], ;
			[curMsuID])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	***
	lnCfTargMsu = curMsuID.MsuQnt
	***
	Use In Select([curMsuID])
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*09.06.2006 15:55 -> Определяем коэффициент пересчета целевой ЕИ в базовую
	lnResultCf = lnCfTargMsu / Iif(lnCfBaseMsu = 0, 1, lnCfBaseMsu)
	*------------------------------------------------------------------------------

	*09.06.2006 15:55 -> Возвращаем результат
	Return lnResultCf
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetLastIncrementedID()
* Called by.......: <After Adding Record With Increment Key>
* Parameters......: <lcEditDBObjName>
* Returns.........: <lnLastIncrementedID>
* Notes...........: Возвращает последний идентификатор записи для LV/RV/Table
*					сгенерированный SPINCREMENTID()
*-------------------------------------------------------
Procedure spGetLastIncrementedID
	Lparameters lcEditDBObjName

	*01.04.2004 13:51 ->Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnEditDBObjectType, ;
		lcSourceTable, ;
		lnSqlExeResult, ;
		lnLastIncrementedID
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*01.04.2004 13:53 ->Узнаем тип объекта использованного для добавления
	lnEditDBObjectType = CursorGetProp([SourceType],lcEditDBObjName)
	*------------------------------------------------------------------------------

	*01.04.2004 13:56 ->Определим последний сгенерированный идентификатор
	Do Case
	Case lnEditDBObjectType	= 1	&& Local SQL View
		lcSourceTable = CursorGetProp([Tables],lcEditDBObjName)
		If ([,]$lcSourceTable)
			lcSourceTable = Left(lcSourceTable,At([,],lcSourceTable)-1)
		Endif
		If ([!]$lcSourceTable)
			lcSourceTable = Substr(lcSourceTable,At([!],lcSourceTable)+1)
		Endif
		***
		If !Used([LastIncrID])
			If File([LastIncrID.dbf])
				Use LastIncrID In 0
			Else
				Return 0
			Endif
		Endif
		***
		Select LastIncrID
		Locate All For Upper(Alltrim(LastIncrID.TableNM))==Upper(Alltrim(lcSourceTable))
		***
		If Found()
			lnLastIncrementedID = LastIncrID.LastId
		Else
			lnLastIncrementedID = 0
		Endif
		***
		Use In LastIncrID
		*------------------------------------------------------------------------------

	Case lnEditDBObjectType = 2 && Remote SQL View
		lcSourceTable = CursorGetProp([Tables],lcEditDBObjName)
		If ([,]$lcSourceTable)
			lcSourceTable = Left(lcSourceTable,At([,],lcSourceTable)-1)
		Endif
		If ([!]$lcSourceTable)
			lcSourceTable = Substr(lcSourceTable,At([!],lcSourceTable)+1)
		Endif
		***
		lnConnHandler = CursorGetProp([ConnectHandle],lcEditDBObjName)
		lnSqlExeResult = 0
		Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
			lnSqlExeResult = SQLExec(lnConnHandler, ;
				[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
				[EXECUTE spGetLastIncrementedID ?lcSourceTable],[tmp])
		Enddo
		***
		If lnSqlExeResult = -1
			spHandleODBCError()
			Return 0
		Endif
		lnLastIncrementedID = Tmp.LastId
		Use In Tmp
		*------------------------------------------------------------------------------

	Case lnEditDBObjectType	= 3	&& Table
		lcSourceTable = lcEditDBObjName
		If ([!]$lcSourceTable)
			lcSourceTable = Substr(lcSourceTable,At([!],lcSourceTable)+1)
		Endif
		***
		If !Used([LastIncrID])
			If File([LastIncrID.dbf])
				Use LastIncrID In 0
			Else
				Return 0
			Endif
		Endif
		***
		Select LastIncrID
		Locate All For Upper(Alltrim(LastIncrID.TableNM))==Upper(Alltrim(lcSourceTable))
		***
		If Found()
			lnLastIncrementedID = LastIncrID.LastId
		Else
			lnLastIncrementedID = 0
		Endif
		***
		Use In LastIncrID
		*------------------------------------------------------------------------------

	Endcase

	*01.04.2004 14:37 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*01.04.2004 14:37 ->Вернем значение
	Return lnLastIncrementedID
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetOpenDay()
* Called by.......: <NA>
* Parameters......: <tnCashID,tlForce>
* Returns.........: <none>
* Notes...........: Проверка открытия локального дня
* LastEditDate....: 14 November 2006
*------------------------------------------------------------------------------
Procedure spGetOpenDay
	Parameters tnCashID,tlForce

	*29.04.2006 16:16 ->Объявление и инициализация переменных
	Local   lnRecCount, ;
		ltStampOpenDay, ;
		lnSLID, ;
		ltPOSActCloseStamp, ;
		lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Проверим количество открытых системных дней
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[SELECT ] + ;
			[SalesLog.SalesLogID, ] + ;
			[SalesLog.StampOpenDay ] + ;
			[FROM SalesLog ] + ;
			[WHERE SalesLog.EOD = 0], ;
			[curSalesLog])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	***
	lnRecCount = Reccount([curSalesLog])
	ltStampOpenDay = curSalesLog.StampOpenDay
	lnSLID = curSalesLog.SalesLogID
	*------------------------------------------------------------------------------

	*29.04.2006 15:14 ->Закроем курсор
	Use In Select([curSalesLog])
	*------------------------------------------------------------------------------

	Do Case
	Case lnRecCount>1
		Return -2 && осталось открытыми более одного дня
	Case lnRecCount=0
		Return 0  && нет открытых дней
	Case lnRecCount=1

		If !tlForce And (Datetime()-ltStampOpenDay)/3600 > 24
			Return lnSLID*-1 && прошло более 24 часов с момента начала общей смены
		Endif

		*07.04.2006 16:45 -> Проверим, есть ли открытая локальная смена
		lnSqlExeResult = 0
		***
		Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
			lnSqlExeResult = SQLExec(lnConnectHandle, ;
				[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
				[SELECT ] + ;
				[POSActivity.POSActID, ] + ;
				[POSActivity.POSActCloseStamp ] + ;
				[FROM POSActivity ] + ;
				[INNER JOIN SalesLog ON SalesLog.SalesLogID = POSActivity.POSActSLID AND POSActivity.POSActCID = ?tnCashID ] + ;
				[WHERE SalesLog.SalesLogID = ?lnSLID], ;
				[curLocalDay])
		Enddo
		***
		If lnSqlExeResult = -1
			spHandleODBCError()
			Return .F.
		Endif
		***
		lnRecCount = Reccount([curLocalDay])
		ltPOSActCloseStamp = curLocalDay.POSActCloseStamp
		*------------------------------------------------------------------------------

		*29.04.2006 15:14 ->Закроем курсоры
		Use In Select([curLocalDay])
		*------------------------------------------------------------------------------

		Do Case
		Case lnRecCount=1 And !Isnull(ltPOSActCloseStamp)
			Return -1 && локальный день уже закрыт
		Case lnRecCount=0
			Return 0
		Endcase

	Otherwise
		Return -5 && неизвестная ошибка
	Endcase
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	Return lnSLID

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetPayDocExport()
* Called by.......: <NA>
* Parameters......: <tnFrmID>
* Returns.........: <lcUniqueNM>
* Notes...........: Выборка документов для экспорта в клиент-банк
*-------------------------------------------------------
Procedure spGetPayDocExport
	Lparameters	tnFrmID

	*16.01.2007 15:29 -> Объявление и инициализация переменных
	Local	lnConnectHandle, ;
		lnSqlExeResult, ;
		lcUniqueName, ;
		lcUniqueFilePath
	***
	lcUniqueName = [_d] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spGetPayDocExport ?tnFrmID],[PaymentPurpose])
	Enddo
	***
	If lnSqlExeResult = -1

		*09.01.2007 17:42 -> Вызовем обработчик ошибок
		spHandleODBCError()
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*26.01.2007 10:48 -> Получаем оставшиеся выборки
	SQLMoreResults(lnConnectHandle,[VatSumText])
	SQLMoreResults(lnConnectHandle,lcUniqueName)
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*09.01.2007 17:42 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	Copy To (lcUniqueFilePath)
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*09.01.2007 17:43 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 ->Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetPayDocExportAll()
* Called by.......: <NA>
* Parameters......: <tnFrmID>
* Returns.........: <lcUniqueNM>
* Notes...........: Выборка документов для экспорта в клиент-банк
*------------------------------------------------------------------------------
Procedure spGetPayDocExportAll
	Lparameters	tcFrmIDTableNM

	*16.01.2007 15:29 -> Объявление и инициализация переменных
	Local	lnConnectHandle, ;
		lnSqlExeResult, ;
		lcUniqueName, ;
		lcUniqueFilePath
	***
	lcUniqueName = [_d] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------

	*19.06.2007 14:33 -> Откроем таблицу со списком ID выбранных документов
	Use ([Tmp\] + tcFrmIDTableNM + [.dbf]) In 0 Alias (tcFrmIDTableNM)
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*19.06.2007 13:06 -> Создаём временную таблицу для хранения идентификаторов и заполняем данными из фокса
	lnSqlExeResult = 0
	***
	lnSqlExeResult = SQLExec(lnConnectHandle, [CREATE TABLE #] + tcFrmIDTableNM + [ (ID int)])
	***
	Select (tcFrmIDTableNM)
	***
	Scan All
		lnSqlExeResult = SQLExec(lnConnectHandle, [INSERT INTO #] + tcFrmIDTableNM + [ (ID) VALUES (] + Alltrim(Str(Evaluate(tcFrmIDTableNM + [.ID]))) + [)])
	Endscan
	***
	If lnSqlExeResult = -1

		*09.01.2007 17:42 -> Вызовем обработчик ошибок
		spHandleODBCError()
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spGetPayDocExportAll ?tcFrmIDTableNM],lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1

		*09.01.2007 17:42 -> Вызовем обработчик ошибок
		spHandleODBCError()
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*09.01.2007 17:42 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	Copy To (lcUniqueFilePath)
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*09.01.2007 17:43 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*19.06.2007 14:32 -> Удаляем таблицу со списком ID выбранных документов
	Use In Select(tcFrmIDTableNM)
	Erase ([Tmp\] + tcFrmIDTableNM + [.dbf])
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 ->Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetPayListDoc()
* Called by.......: <NA>
* Parameters......: <tnParFrmID>
* Returns.........: <lcUniqueNM>
* Notes...........: Формирование списка документов для включения в суммовые документы
*------------------------------------------------------------------------------
Procedure spGetPayListDoc()
	Lparameters	tnFrmID

	*23.09.2004 19:40 -> Объявление и инициализация переменных
	Local	lnConnectHandle, ;
		lnSqlExeResult, ;
		lcUniqueName, ;
		lcUniqueFilePath
	***
	lcUniqueName = [_d] + Sys(2015)
	lcUniqueFilePath = [tmp\] + lcUniqueName + [.DBF]
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spGetPayListDoc ?tnFrmID],lcUniqueName)
	Enddo
	***
	If lnSqlExeResult = -1

		*09.01.2007 17:42 -> Вызовем обработчик ошибок
		spHandleODBCError()
		*------------------------------------------------------------------------------

		*11.01.2007 13:07 -> Создадим пустой курсор
		Create Cursor (lcUniqueName) ( ;
			ID I, NM C(1) ;
			)
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*09.01.2007 17:42 -> Сохраним курсор в файл и закроем
	Select (lcUniqueName)
	Copy To (lcUniqueFilePath)
	Use In Select(lcUniqueName)
	*------------------------------------------------------------------------------

	*09.01.2007 17:43 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*21.04.2004 14:27 ->Вернем значение
	Return lcUniqueName
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetPaymentPurpose()
* Called by.......: <NA>
* Parameters......: <tnFrmID>
* Returns.........: <lcUniqueNM>
* Notes...........: Формирование строки назначение платежа для расчетных документов
*------------------------------------------------------------------------------
Procedure spGetPaymentPurpose
	Lparameters	tnFrmID

	*25.01.2007 11:57 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnConnectHandle, ;
		lnSqlExeResult, ;
		lcPaymentPurpose
	***
	lcOldAlias = Alias()
	lcPaymentPurpose = []
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spGetPaymentPurpose ?tnFrmID, ?lcPaymentPurpose],[PaymentPurpose])
	Enddo
	***
	If lnSqlExeResult = -1

		*09.01.2007 17:42 -> Вызовем обработчик ошибок
		spHandleODBCError()
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*25.01.2007 12:07 -> Сохраним курсор в файл и закроем
	If Reccount([PaymentPurpose]) > 0
		lcPaymentPurpose = PaymentPurpose.PaymentPurpose
	Endif
	Use In Select([PaymentPurpose])
	*------------------------------------------------------------------------------

	*09.01.2007 17:43 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*01.04.2004 14:37 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*25.01.2007 12:07 -> Вернем значение
	Return lcPaymentPurpose
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetResourceUsage()
* Called by.......: <NA>
* Parameters......: <tnMsuID, tdStartDate, tuValue>
* Returns.........: <Datetime / Numeric>
* Notes...........: Вычисление времени использования ресурса (конечная дата или количество ресурса)
* Last Editor.....: Владимир Боярских
* Last Edit.......: September 13, 2007
*------------------------------------------------------------------------------
Procedure spGetResourceUsage
	Lparameters tnMsuID, tdStartDate, tuValue

	*13.09.2007 13:51 -> Объявление и инициализация переменных
	Local   lnConnectHandle, ;
		lnSqlExeResult
	*------------------------------------------------------------------------------

	*13.09.2007 13:51 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.09.2007 14:00 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[SELECT ] + ;
			[MsuTransKoeff = dbo.MsuTransKoeff(MeasureUnit.BaseMsuID, MeasureUnit.MsuID, NULL) ] + ;
			[FROM MeasureUnit ] + ;
			[WHERE MeasureUnit.MsuID = ?tnMsuID],[curMsu])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.09.2007 14:11 -> Получим конечную дату использования ресурса
	If Type([tuValue]) == [N]
		&& Количество ресурса домножаем на коэффициент ед.изм. времени,
		&& домножаем на 60 секунд и прибавляем к начальной дате
		Return tdStartDate + (tuValue * curMsu.MsuTransKoeff * 60)
	Endif
	*------------------------------------------------------------------------------
	If Type([tuValue]) == [D]
		tuValue = Dtot(tuValue)

	Endif
	*13.09.2007 14:18 -> Получим количество использованного ресурса
	If Type([tuValue]) == [T]
		&& Из конечной даты вычитаем начальную и делим полученное количество
		&& на 60 секунд и на коэффициент ед.изм. времени
		If (curMsu.MsuTransKoeff * 60) # 0
			Return (tuValue - tdStartDate) / (curMsu.MsuTransKoeff * 60)
		Endif
	Endif
	*------------------------------------------------------------------------------

	*13.09.2007 14:12 -> Что-то сработало не так
	Return .F.
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetSaleSum()
* Called by.......: <NA>
* Parameters......: <tcQryParSID>
* Returns.........: <none>
* Notes...........: Расчитываем сумму продаж за период
*------------------------------------------------------------------------------
Procedure spGetSaleSum
	Lparameters tcQryParSID

	*28.02.2006 12:16 ->Объявление и инициализация переменных
	Local	lcOldDate, ;
		lcOldCentury, ;
		lcOldMark, ;
		lcOldAlias, ;
		lcFilterExpr, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate, ;
		luQryParCashEnabled, ;
		luQryParCashTableNM, ;
		luQryParCashierEnabled, ;
		luQryParCashierTableNM, ;
		luQryParTvrEnabled, ;
		luQryParTvrIDTableNM, ;
		lnSalesSum
	***
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])
	lcOldAlias	 = Alias()
	lcFilterExpr = []
	*------------------------------------------------------------------------------

	*06.03.2006 16:22 ->Дальнейшие параметры обрабатываем, если существует менеджер параметров
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*06.03.2006 16:22 ->Формируем фильтр по дате
		luQryParDateEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
		***
		If !Isnull(luQryParDateEnabled) And Type([luQryParDateEnabled])==[L] And luQryParDateEnabled

			*06.03.2006 16:22 ->Получим дату стартовую и конечную
			luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
			luQryParDateEndDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
			*------------------------------------------------------------------------------

			*21.04.2006 10:33 -> Установим формат даты YMD и CENTURY ON
			Set Date YMD
			***
			Set Century On
			***
			Set Mark To "/"
			*------------------------------------------------------------------------------

			*06.03.2006 16:22 ->Формируем условие
			Do Case
			Case	!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
					!Isnull(luQryParDateEndDate) And Type([luQryParDateEndDate])==[D] And !Empty(luQryParDateEndDate)
				*{
				lcFilterExpr = lcFilterExpr + [ AND CheckSale.CheckStamp >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[' AND CheckSale.CheckStamp < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
				*}
			Case	!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate)
				*{
				lcFilterExpr = lcFilterExpr + [ AND CheckSale.CheckStamp >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[']
				*}
			Case	!Isnull(luQryParDateEndDate) And Type([luQryParDateEndDate])==[D] And !Empty(luQryParDateEndDate)
				*{
				lcFilterExpr = lcFilterExpr + [ AND CheckSale.CheckStamp < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
				*}
			Endcase
			*------------------------------------------------------------------------------

			*21.04.2006 10:33 -> Восстановим старый формат даты
			Set Date (lcOldDate)
			***
			Set Century &lcOldCentury
			***
			Set Mark To lcOldMark
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

		*02.06.2006 11:34 ->Формируем фильтр по кассе
		luQryParCashEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCashEnabled])
		***
		If !Isnull(luQryParCashEnabled) And Type([luQryParCashEnabled])==[L] And luQryParCashEnabled
			luQryParCashTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCashTableNM])
			If !Isnull(luQryParCashTableNM) And Type([luQryParCashTableNM])==[C] And File(luQryParCashTableNM+[.dbf])

				*10.04.2006 11:35 -> Сформируем фильтр
				lcFilterExpr = lcFilterExpr+[ AND CheckSale.CheckCashID IN (]+spGetTmpValueList(luQryParCashTableNM)+[)]
				*------------------------------------------------------------------------------

			Endif
		Endif
		*------------------------------------------------------------------------------

		*02.06.2006 11:34 ->Формируем фильтр по кассиру
		luQryParCashierEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCashierEnabled])
		***
		If !Isnull(luQryParCashierEnabled) And Type([luQryParCashierEnabled])==[L] And luQryParCashierEnabled
			luQryParCashierTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCashierTableNM])
			If !Isnull(luQryParCashierTableNM) And Type([luQryParCashierTableNM])==[C] And File(luQryParCashierTableNM+[.dbf])

				*10.04.2006 11:35 -> Сформируем фильтр
				lcFilterExpr = lcFilterExpr+[ AND CheckSale.CheckCashierID IN (]+spGetTmpValueList(luQryParCashierTableNM)+[)]
				*------------------------------------------------------------------------------

			Endif
		Endif
		*------------------------------------------------------------------------------

		*02.06.2006 11:38 ->Формируем фильтр (Выбор товаров)
		luQryParTvrEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplTvrEnabled])
		***
		If !Isnull(luQryParTvrEnabled) And Type([luQryParTvrEnabled])==[L] And luQryParTvrEnabled

			*23.04.2006 00:32 ->Получим имя временной таблицы с идентификаторами товАРОВ
			luQryParTvrIDTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcTvrIDTableNM])
			***
			If !Isnull(luQryParTvrIDTableNM) And Type([luQryParTvrIDTableNM])==[C] And File([tmp\]+luQryParTvrIDTableNM+[.dbf])

				*10.04.2006 11:35 -> Сформируем фильтр
				lcFilterExpr = lcFilterExpr + ;
					[ AND CheckTrans.CheckTransTvrId IN (]+spGetTmpValueList(luQryParTvrIDTableNM)+[)]
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spGetSaleSum ?lcFilterExpr],[curSaleSum])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return 0
	Endif
	*------------------------------------------------------------------------------

	*06.03.2006 16:24 ->Сохраним сумму
	lnSalesSum = curSaleSum.SaleSum
	*------------------------------------------------------------------------------

	*06.03.2006 16:23 ->Закроем курсор
	Use In Select([curSaleSum])
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*06.03.2006 16:30 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*07.07.2006 16:51 -> Вернем результат
	Return lnSalesSum
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spGetTmpValueList()
* Called by.......: <N/A>
* Parameters......: <tcIDTableNM>
* Returns.........: <lcValueList>
* Notes...........: Получение списка значений идентификаторов из временной таблицы
*------------------------------------------------------------------------------
Procedure spGetTmpValueList
	Lparameters tcIDTableNM

	*10.04.2006 11:42 -> Объявление и инициализация переменных
	Local	luValue, ;
		lcValueList
	*------------------------------------------------------------------------------

	*10.04.2006 11:30 -> Откроем временную таблицу
	If !Used(tcIDTableNM)
		Use (tcIDTableNM) In 0
	Endif
	*------------------------------------------------------------------------------

	*10.04.2006 11:34 -> Сформируем список значений идентификаторов
	Select (tcIDTableNM)
	lcValueList = []
	***
	Scan All
		luValue = Evaluate(tcIDTableNM + [.ID])
		If Type([luValue]) == [N] And !Isnull(luValue)
			lcValueList = lcValueList + Alltrim(Str(luValue)) + [,]
		Endif
	Endscan
	***
	lcValueList = Left(lcValueList,Len(lcValueList)-1)
	*------------------------------------------------------------------------------

	*10.04.2006 11:35 -> Закроем временную таблицу
	Use In Select(tcIDTableNM)
	*------------------------------------------------------------------------------

	*10.04.2006 11:45 -> Вернем результат
	Return lcValueList
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spGetTvrLbl()
* Called by.......: <NA>
* Parameters......: <none>
* Returns.........: <none>
* Notes...........: Формирование временной таблицы для печати ценников и этикеток
*------------------------------------------------------------------------------
Procedure spGetTvrLbl
	Lparameters tcExecVar,tuParam1

	*08.08.2005 12:10 -> Объявление и инициализация переменных
	Local	lcFilterExpr, ;
		lcAliasListToClose, ;
		luQryParTLUTypeEnabled, ;
		luQryParTLUTypeIDTableNM, ;
		luQryParPrcTypeEnabled, ;
		luQryParPrcTypeID, ;
		lnConnectHandle, ;
		lnSqlExeResult

	Local Array aTvrLbl(1)
	***
	lcFilterExpr = [WHERE 1=0]
	lcAliasListToClose = []
	*------------------------------------------------------------------------------

	Do Case
	Case Type([tcExecVar])==[C] And tcExecVar==[NODATA]

		*21.04.2004 12:34 ->Формируем фильтр, для формирования пустой выборки
		lcFilterExpr = [WHERE 1=0 ]
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYTVRID]

		*21.04.2004 12:32 ->Формируем фильтр для выбора одного документа
		lcFilterExpr = [WHERE Tovar.TvrID = ]+Alltrim(Str(tuParam1))
		*------------------------------------------------------------------------------

	Case Type([tcExecVar])==[C] And tcExecVar==[BYFILTER]

		*24.08.2005 16:45 -> Установим фильтр
		lcFilterExpr = [WHERE 1=1]
		*------------------------------------------------------------------------------

		*08.08.2005 12:19 ->Формируем фильтр по типам идентификаторов
		luQryParTLUTypeEnabled = oQryParMgr.ParamGet(tuParam1,[qplTLUTypeEnabled])
		***
		If !Isnull(luQryParTLUTypeEnabled) And Type([luQryParTLUTypeEnabled])==[L] And luQryParTLUTypeEnabled

			*08.08.2005 12:20 -> Получим имя временной таблицы с типами идентификаторов
			luQryParTLUTypeIDTableNM = oQryParMgr.ParamGet(tuParam1,[qpcTLUTypeIDTableNM])
			***
			If !Isnull(luQryParTLUTypeIDTableNM) And Type([luQryParTLUTypeIDTableNM])==[C] And File([tmp\]+luQryParTLUTypeIDTableNM+[.dbf])

				*26.03.2007 15:57 ->Сформируем фильтр
				lcFilterExpr = lcFilterExpr + ;
					[ AND TvrLookUp.TLUTypeID IN (]+spGetTmpValueList(luQryParTLUTypeIDTableNM)+[)]
				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

		*27.04.2006 12:19 ->Формируем фильтр по типам прайс-листов
		luQryParPrcTypeEnabled = oQryParMgr.ParamGet(tuParam1,[qplPrcTypeEnabled])
		***
		If !Isnull(luQryParPrcTypeEnabled) And Type([luQryParPrcTypeEnabled])==[L] And luQryParPrcTypeEnabled

			*27.04.2006 12:20 -> Получим идентификатор прайс-листа
			luQryParPrcTypeID = oQryParMgr.ParamGet(tuParam1,[qpnPrcTypeID])
			***
			If !Isnull(luQryParPrcTypeID) And Type([luQryParPrcTypeID])==[N]
				lcFilterExpr = lcFilterExpr + [ AND Price.PrcTypeID = ]+Alltrim(Str(luQryParPrcTypeID))
			Endif
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

	Endcase
	*------------------------------------------------------------------------------

	*26.03.2007 17:11 ->Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 ->Привязываем
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[SELECT ] + ;
			[Tovar.TvrID, ] + ;
			[Tovar.TvrNM, ] + ;
			[ISNULL(TvrLookUp.TLUID,000000) AS TLUID, ] + ;
			[ISNULL(TvrLookUp.TLU,SPACE(13)) AS TLU, ] + ;
			[0 AS Qnt, ] + ;
			[ISNULL(Price.Price,0) AS Price ] + ;
			[FROM Tovar ] + ;
			[INNER JOIN Price ON Price.TvrID = Tovar.TvrID ] + ;
			[LEFT JOIN TvrLookUp ON TvrLookUp.TvrID = Tovar.TvrID ] + ;
			lcFilterExpr, [curTvrLbl])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------


	*26.03.2007 16:09->Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*09.08.2005 12:26 -> Сохраняем во временную таблицу результат
	Select * From curTvrLbl Into Table Tmp\TvrLbl.Dbf
	*------------------------------------------------------------------------------

	*09.08.2005 12:26 -> Закроем курсор
	Use In Iif(Used([curTvrLbl]),[curTvrLbl],0)
	*------------------------------------------------------------------------------

	*09.08.2005 12:26 -> Закроем временную таблицу
	Use In Iif(Used([TvrLbl]),[TvrLbl],0)
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spGetVatSumText()
* Called by.......: <NA>
* Parameters......: <tnFrmID, tlBlankIfZero>
* Returns.........: <lcVatSumText>
* Notes...........: Формирование строки с суммой налога для расчетных документов
*------------------------------------------------------------------------------
Procedure spGetVatSumText
	Lparameters	tnFrmID, tlBlankIfZero

	*25.01.2007 12:10 -> Объявление и инициализация переменных
	Local	lcOldAlias, ;
		lnConnectHandle, ;
		lnSqlExeResult, ;
		lcVatSumText
	***
	lcOldAlias = Alias()
	lcVatSumText = []
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*09.01.2007 17:41 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spGetVatSumText ?tnFrmID, ?tlBlankIfZero, ?lcVatSumText],[VatSumText])
	Enddo
	***
	If lnSqlExeResult = -1

		*09.01.2007 17:42 -> Вызовем обработчик ошибок
		spHandleODBCError()
		Return .F.
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*25.01.2007 12:07 -> Сохраняем строку
	If Reccount([VatSumText]) > 0
		lcVatSumText = VatSumText.VatSumText
	Endif
	Use In Select([VatSumText])
	*------------------------------------------------------------------------------

	*09.01.2007 17:43 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*01.04.2004 14:37 ->Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*25.01.2007 12:07 -> Вернем значение
	Return lcVatSumText
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spHandleODBCError()
* Called by.......: <NA>
* Parameters......: <taErrors>
* Returns.........: <none>
* Notes...........: Обработка ошибок ODBC
*------------------------------------------------------------------------------
Procedure spHandleODBCError

	*28.07.2006 09:38 ->Объявление и инициализация переменных
	Local	lnErrorRowsCount, ;
		lnCounter, ;
		lcErrorMessage,lcStErrorMessage,;
		lcWSNM   ,;
		ltDateTime,;
		lcUserNM
	***
	Local Array laErrors[1],laStErrors[1]
	***
	lcErrorMessage = []
	*------------------------------------------------------------------------------
	lcWSNM   = Sys(0)
	lcUserNM = Alltrim(Substr(lcWSNM,At([#],lcWSNM)+1))
	lcWSNM   = Alltrim(Left(lcWSNM,At([#],lcWSNM)-1))
	ltDateTime = Datetime()

	*21.01.2004 18:52 -> Прочитаем информацию об ошибке
	lnErrorRowsCount = Aerror(laErrors)
	lnStErrorRowsCount = Astackinfo(laStErrors)
	*------------------------------------------------------------------------------

	*28.07.2006 09:37 -> Последовательно обработаем все ошибки
	If !File('ErrorStack.dbf')
		Create Table ErrorStack Free (StLevel Int Null, PrgFl Varchar(254) Null, ObjModul Varchar(254) Null,;
			ObjModFl Varchar(254) Null,LineNum Int Null, SourCont Varchar(254) Null,;
			UserNm Varchar(254) Null,Stamp_ Datetime Null,WSNM  Varchar(254) Null)
	Else
		Use In Select('ErrorStack')
		Use ErrorStack In 0
	Endif
	Insert Into ErrorStack  From Array laStErrors
	Replace All UserNm With lcUserNM ,;
		WSNM   With lcWSNM   ,;
		Stamp_ With ltDateTime In ErrorStack  For Empty(WSNM)

	If !File('ErrorLog.dbf')
		Create Table ErrorLog Free(ErrNum1 Int Null, ErrorMs2 Varchar(254) Null, ErorrPar3 Varchar(254) Null,;
			WkArr4 Varchar(254) Null,TrgType5 Varchar(254) Null, ODBCConn6 Varchar(254) Null,;
			OleEx Int Null, ;
			UserNm Varchar(254) Null,Stamp_ Datetime Null,WSNM  Varchar(254) Null)
	Else
		Use In Select('ErrorLog')
		Use ErrorLog In 0
	Endif
	Insert Into ErrorLog From Array laErrors
	Replace All UserNm With lcUserNM ,;
		WSNM   With lcWSNM   ,;
		Stamp_ With ltDateTime In ErrorLog For Empty(WSNM)

	For lnCounter = 1 To lnErrorRowsCount
		If laErrors[lnCounter,5] # 50001
			lcErrorMessage = lcErrorMessage + Strtran(laErrors[lnCounter,3],pcvERRORHEADMSG,[* ]) + Chr(13)
		Endif
		Strtofile(Ttoc(Datetime())+[ -> ] + Strtran(laErrors[lnCounter,3],pcvERRORHEADMSG,[]) + Chr(13),[Error.log],1)

		*** Надо сохранить: сообщение об ошибке
		***  состояние стека
	Endfor
	*------------------------------------------------------------------------------
	Use In Select('ErrorStack')
	Use In Select('ErrorLog')
	*28.07.2006 09:46 -> Выводим сообщение пользователю
	If lnErrorRowsCount > 0
		*MESSAGEBOX(lcErrorMessage,16,[Ошибка соединения...])
		Messagebox('Возможны неверные данные ввода. Проверте данные и повторите операцию.',48,'Предупреждение')
	Endif
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored Procedures for Basis
* Module/Procedure: spInventoryBludo()
* Called by.......: <NA>
* Parameters......: <tnFrmID>
* Returns.........: <Кол-во подблюд (блюд содержащихся в блюдах)>
* Notes...........: Разворачивает блюда по ингридиентам
*------------------------------------------------------------------------------
Procedure spInventoryBludo
	Lparameters tnFrmID

	*19.06.2006 12:23 ->Объявление и инициализация переменных
	Local   lnConnectHandle, ;
		lnSqlExeResult, ;
		lnRecCnt
	*------------------------------------------------------------------------------

	*06.12.2006 12:12 ->Покажем сообщение для пользователя
	Wait Window [Ждите. Идет обработка данных...] Nowait Noclear
	Set Message To [Ждите. Идет обработка данных...]
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spInventoryBludo ?tnFrmID],[curTmp])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return
	Endif
	***
	lnRecCnt = curTmp.RecCnt
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*06.12.2006 12:13 ->Уберем сообщение
	Wait Clear
	Set Message To []
	*------------------------------------------------------------------------------

	*20.06.2006 12:39 -> Вывод сообщения пользователю
	Messagebox([Обработка документа успешно завершена. Развернуто блюд: ] + Alltrim(Str(lnRecCnt)) + [.],64,[Информация])
	*------------------------------------------------------------------------------

	*19.06.2006 12:30 -> Вернем результат
	Return .T.
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: Basis.pjx
* File............: Stored procedures for Basis
* Module/Procedure: spInventoryReport()
* Called by.......: <NA>
* Parameters......: <tcQryParSID>
* Returns.........: <Список временных файлов, созданных для отчета>
* Notes...........: Выборка для отчета "Сличительная ведомость"
*------------------------------------------------------------------------------
Procedure spInventoryReport
	Lparameters tcQryParSID

	*12.05.2006 11:02 -> Объявление и инициализация переменных
	Local	lnFrmID, ;
		lcOldAlias, ;
		lnConnectHandle, ;
		lnSqlExeResult
	***
	lcOldAlias = Alias()
	*------------------------------------------------------------------------------

	*12.05.2006 11:02 -> Создаем таблицу с окружением для отчёта
	Create Table Tmp\RptEnv Free (QryParSID C(10))
	Insert Into RptEnv (QryParSID) Values (tcQryParSID)
	*------------------------------------------------------------------------------

	*12.05.2006 11:02 ->Читаем параметры
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*12.05.2006 11:02 -> Читаем идентификатор документа, который будем печатать
		lnFrmID = oQryParMgr.ParamGet(tcQryParSID,[FrmID])
		*------------------------------------------------------------------------------

	Endif
	*------------------------------------------------------------------------------

	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)
	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*07.04.2006 16:45 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
			[EXECUTE spInventoryReport ?lnFrmID],[RptItogHD])
	Enddo
	***
	If lnSqlExeResult = -1
		spHandleODBCError()
		Return .F.
	Endif
	*------------------------------------------------------------------------------

	*13.04.2006 14:03 -> Получаем вторую результирующую выборку
	SQLMoreResults(lnConnectHandle,[RptItogDT])
	SQLMoreResults(lnConnectHandle)
	*------------------------------------------------------------------------------

	*07.04.2006 16:12 -> Делаем дисконнект: освобождаем соединение
	SQLDisconnect(lnConnectHandle)
	*------------------------------------------------------------------------------

	*10.04.2006 14:07 -> Сохраним курсоры на диск и закроем
	Select RptItogHD
	Copy To Tmp\RptItogHD.Dbf
	***
	Select RptItogDT
	Copy To Tmp\RptItogDT.Dbf
	***
	Use In Select([RptItogHD])
	Use In Select([RptItogDT])
	*------------------------------------------------------------------------------

	*12.05.2006 11:29 -> Восстановим текущий Alias
	If !Empty(lcOldAlias) And Used(lcOldAlias) And lcOldAlias#Alias()
		Select(lcOldAlias)
	Endif
	*------------------------------------------------------------------------------

	*12.05.2006 11:29 -> Вернем список временных таблиц для построения отчета
	Return [RptItogHD.dbf;RptItogDT.dbf;RptEnv.dbf]
	*------------------------------------------------------------------------------

Endproc
*******************************************************************************
******************************** END PROCEDURE ********************************
*******************************************************************************
*-------------------------------------------------------
* Project.........: BASIS.PJX
* File............: STORED PROCEDURES FOR BASIS
* Module/Procedure: spJurnal
* Called by.......: <NA>
* Parameters......: <tcQryParSID>
* Returns.........: <none>
* Notes...........: Формирование выборки для журнала-ордера
* LastEditDate....: 28 June 2007
* LastEditor......: Volga
*------------------------------------------------------------------------------
Procedure spJurnal
	Lparameters tcQryParSID

	*11.05.2007 12:13 -> Объявление и инициализация переменных
	Local	lcOldDate, ;
		lcOldCentury, ;
		lcOldMark, ;
		lcOldAlias, ;
		lcFilterExpr, ;
		luQryParDateEnabled, ;
		luQryParDateStartDate, ;
		luQryParDateEndDate, ;
		luQryParAccBuchEnabled, ;
		luQryParAccBuchID, ;
		luQryParAccBuchTableNM, ;
		luQryCorrAccBuchID, ;
		luQryParOUEnabled, ;
		luQryParOUID, ;
		luQryParOUTableNM, ;
		luQryParCLEnabled, ;
		luQryParCLID, ;
		luQryParCLTableNM, ;
		lnConnectHandle, ;
		lnSqlExeResult, ;
		luQryParOUSQLNM , ;
		luQryParClSqlNM
	***
	Store Null To luQryParOUSQLNM , ;
		luQryParClSqlNM , ;
		luQryCorrAccBuchID
	***
	lcOldDate = Set([DATE])
	lcOldCentury = Set([CENTURY])
	lcOldMark = Set([MARK])
	lcOldAlias = Alias()
	lcFilterExpr = [WHERE 0<>1]
	lcBalanceFilterExpr = [WHERE 0<>1]
	*------------------------------------------------------------------------------
	*07.04.2006 16:13 -> Коннектимся к БД через существующее соединение
	lnConnectHandle = SQLCONNECTBAS(pcvCONNECTIONNAME)

	*21.07.2005 12:13 ->Дальнейшие параметры обрабатываем, если существует менеджер параметров
	If Type([oQryParMgr])==[O] And !Isnull(oQryParMgr)

		*21.07.2005 15:37 ->Создаем таблицу с окружением для отчёта
		Create Table Tmp\RptEnv Free (QryParSID C(10), QryTypeNM C(40))
		Insert Into RptEnv (QryParSID) Values (tcQryParSID)
		*------------------------------------------------------------------------------

		*19.01.2007 15:06 -> Сформируем условия выбора по дате
		luQryParDateEnabled   = oQryParMgr.ParamGet(tcQryParSID,[qplDateEnabled])
		luQryParDateStartDate = oQryParMgr.ParamGet(tcQryParSID,[qpdDateStart])
		luQryParDateEndDate   = oQryParMgr.ParamGet(tcQryParSID,[qpdDateEnd])
		***
		If !Isnull(luQryParDateEnabled)   And Type([luQryParDateEnabled])==[L]   And luQryParDateEnabled And ;
				!Isnull(luQryParDateStartDate) And Type([luQryParDateStartDate])==[D] And !Empty(luQryParDateStartDate) And ;
				!Isnull(luQryParDateEndDate)   And Type([luQryParDateEndDate])==[D]   And !Empty(luQryParDateEndDate)

			*19.01.2007 15:06 -> Установим формат даты YMD и CENTURY ON
			Set Date YMD
			Set Century On
			Set Mark To "/"
			*------------------------------------------------------------------------------

			*19.01.2007 15:06 -> Сформируем условия выбора
			lcFilterExpr = lcFilterExpr + [ AND JurnalOrder.FrmDateAcc >= ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[' AND JurnalOrder.FrmDateAcc < ']+Strtran(Dtoc(luQryParDateEndDate+1),[/],[])+[']
			lcBalanceFilterExpr = lcBalanceFilterExpr + [ AND JurnalOrder.FrmDateAcc < ']+Strtran(Dtoc(luQryParDateStartDate),[/],[])+[']
			*------------------------------------------------------------------------------

			*19.01.2007 15:06 -> Восстановим старый формат даты
			Set Date (lcOldDate)
			Set Century &lcOldCentury
			Set Mark To lcOldMark
			*------------------------------------------------------------------------------

		Else

			*19.01.2007 15:05 -> Выведем сообщение о необходимости указать стартовую и конечную дату для построения отчёта
			Messagebox([Для построения данного отчёта необходимо указать стартовую и конечную дату отчётного периода],48,[Предупреждение])
			Return .F.
			*------------------------------------------------------------------------------

		Endif
		*------------------------------------------------------------------------------

		*23.04.2008 14:08 -> Формируем фильтр (Бухгалтерский счет)
		luQryParAccBuchEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplAccBuchEnabled])
		***
		If !Isnull(luQryParAccBuchEnabled) And Type([luQryParAccBuchEnabled])==[L] And luQryParAccBuchEnabled

			*23.01.2007 14:08 -> Получим идентификатор бухгалтерского счета
			luQryParAccBuchID = oQryParMgr.ParamGet(tcQryParSID,[qpnAccBuchID])
			*------------------------------------------------------------------------------
			*23.01.2007 14:08 -> Получим идентификатор бухгалтерского счета
			luQryParAccBuchTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcAccBuchTableNM])
			*------------------------------------------------------------------------------
			If !Isnull(luQryParAccBuchTableNM) And Type([luQryParAccBuchTableNM])==[C] And File([tmp\]+luQryParAccBuchTableNM+[.dbf])

				*11.05.2007 11:35 -> Сформируем фильтр
				luQryParBuchSQLNM = '#QryParBuchSQLNM'
				lnSqlExeResult = 0
				***
				Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
					lnSqlExeResult = SQLExec(lnConnectHandle, ;
						[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
						[CREATE TABLE ]+ luQryParBuchSQLNM + [(ID int) ])
					Use (luQryParAccBuchTableNM) In 0 Alias Buchid
					Select Buchid
					Scan All
						lnSqlExeResult = SQLExec(lnConnectHandle, ;
							[ INSERT INTO ] + luQryParBuchSQLNM + [ (ID)  VALUES ( ?Buchid.id )] )
					Endscan
					Use In Buchid
				Enddo
				***
				If lnSqlExeResult = -1
					spHandleODBCError()
					Return .F.
				Endif
			Endif
		Endif
		*------------------------------------------------------------------------------
		*23.04.2008 14:08 -> Формируем фильтр (Корреспондентский Бухгалтерский счет)
		luQryParCorBuchEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCorrAccEnabled])
		***
		If !Isnull(luQryParCorBuchEnabled) And Type([luQryParCorBuchEnabled])==[L] And luQryParCorBuchEnabled

			*23.01.2007 14:08 -> Получим идентификатор бухгалтерского счета
			luQryCorrAccBuchID = oQryParMgr.ParamGet(tcQryParSID,[qpnCorrAccBuchID])
			*------------------------------------------------------------------------------
		Endif
		*------------------------------------------------------------------------------

		*11.05.2007 14:08 -> Формируем фильтр (Список отделов)

		*11.05.2007 11:26 ->Формируем фильтр по подразделению
		luQryParOUEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplOUEnabled])
		***
		If !Isnull(luQryParOUEnabled) And Type([luQryParOUEnabled])==[L] And luQryParOUEnabled

			*11.05.2007 11:26 ->Получим имя таблицы с идентификаторами подразделений
			luQryParOUTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcOUIDTableNM])
			***
			If !Isnull(luQryParOUTableNM) And Type([luQryParOUTableNM])==[C] And File([tmp\]+luQryParOUTableNM+[.dbf])

				*11.05.2007 11:35 -> Сформируем фильтр
				luQryParOUSQLNM = '#QryParOUSQLNM'
				lnSqlExeResult = 0
				***
				Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
					lnSqlExeResult = SQLExec(lnConnectHandle, ;
						[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
						[CREATE TABLE ]+ luQryParOUSQLNM + [(ID int) ])
					Use (luQryParOUTableNM) In 0 Alias Ouid
					Select Ouid
					Scan All
						lnSqlExeResult = SQLExec(lnConnectHandle, ;
							[ INSERT INTO ] + luQryParOUSQLNM + [ (ID)  VALUES ( ?ouid.id )] )
					Endscan
					Use In Ouid
				Enddo
				***
				If lnSqlExeResult = -1
					spHandleODBCError()
					Return .F.
				Endif
			Endif
		Endif
		*11.05.2007 11:26 ->Формируем фильтр по клиентам
		luQryParCLEnabled = oQryParMgr.ParamGet(tcQryParSID,[qplCltEnabled])
		***
		If !Isnull(luQryParCLEnabled) And Type([luQryParCLEnabled])==[L] And luQryParCLEnabled

			*11.05.2007 11:26 ->Получим имя таблицы с идентификаторами клиентов
			luQryParCLTableNM = oQryParMgr.ParamGet(tcQryParSID,[qpcCltIDTableNM])
			***
			If !Isnull(luQryParCLTableNM) And Type([luQryParClTableNM])==[C] And File([tmp\]+luQryParCLTableNM+[.dbf])

				*11.05.2007 11:35 -> Сформируем фильтр
				luQryParClSqlNM = '#QryParCLSQLNM'
				lnSqlExeResult = 0
				***
				Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
					lnSqlExeResult = SQLExec(lnConnectHandle, ;
						[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
						[CREATE TABLE ]+ luQryParClSqlNM + [(ID int) ])
					Use (luQryParCLTableNM) In 0 Alias Ouid
					Select Ouid
					Scan All
						lnSqlExeResult = SQLExec(lnConnectHandle, ;
							[ INSERT INTO ] + luQryParClSqlNM + [ (ID)  VALUES ( ?ouid.id )] )
					Endscan
					Use In Ouid
				Enddo
				***
				If lnSqlExeResult = -1
					spHandleODBCError()
					Return .F.
				Endif

				*------------------------------------------------------------------------------

			Endif
			*------------------------------------------------------------------------------

		Endif

	Endif
	*------------------------------------------------------------------------------

	*------------------------------------------------------------------------------

	*13.04.2006 14:01 -> Установим свойство BatchMode в False, чтобы получать результирующие выборки с сервера по очереди командой SQLMoreResults
	SQLSetprop(lnConnectHandle,[BatchMode],.F.)
	*------------------------------------------------------------------------------

	*19.01.2007 13:12 -> Выполняем запрос
	lnSqlExeResult = 0
	***
	Do While (lnSqlExeResult = 0) And (lnSqlExeResult # -1)
		lnSqlExeResult = SQLExec(lnConnectHandle, ;
			[SET LOCK_TIMEOUT ] + pcvLOCKTIMEOUT + [ ] + ;
